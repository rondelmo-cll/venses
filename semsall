:- style_check(-singleton).


allen :-
   rete(Rete),
   bagof(
      N / RefInt, 
      NN ^ 
         (
         arco(N, NN, ref_int, Rete),
         foglia(NN, [RefInt], Rete),
         is_principale(N, Rete)
         ), 
      ListaPrincipali),
   attacca_relative(ListaPrincipali, ListaPrincRel, Rete),
   sort(ListaPrincRel,Lists),
   (Lists=[A], List=Lists; Lists\=[A], Lists=[A|_], List=[A]),
   apply(allen0, List).

 
attacca_relative(L,L,_).

attacca_relative_x([],_,[]).
attacca_relative_x([NPrinc/RefIntPrinc|AltrePrinc],ListaRel,PrincRel) :-
  bagof(N/RefInt,member(N/RefInt/NPrinc,ListaRel),Rel),
  attacca_relative_x(AltrePrinc,ListaRel,AltrePrincRel),
  append(Rel,[NPrinc/RefIntPrinc|AltrePrincRel],PrincRel), !.
attacca_relative_x([Princ|AltrePrinc],ListaRel,[Princ|AltrePrincRel]) :-
  attacca_relative_x(AltrePrinc,ListaRel,AltrePrincRel).
allen0(N/RefInt) :-
  assert(current_prop_node(N)), 
         nodo(N)::rel1::[Rel1],
         nodo(N)::rel2::[Rel2],
         nodo(N)::aspetto::Asp,
         RefInt = tr(F_id), 
  assert(aspetto_frase(F_id,Asp)), 
  frase_corrente(NoFr, _),                  
  anafora_temp(NoFr, Asp, F_id,Rel1,Rel2),
  abolish(current_prop_node/1),!.  


controllo_semantico(F_id,Asp/Pred/Args) :- 
   fact(_,isa,[arg:Id, _:ev],_,tes(F_id),_),
   fact(Id,Pred,Args,_,_,_),
   aspetto_frase(F_id, Asp),!.
controllo_semantico(F_id,attivita/Pred/Args) :- 
   fact(Id,Pred,Args,_,_,_),
   aspetto_frase(F_id,Asp),!.


controllo_semantico(F_id,Asp/Pred/Args) :- 
  frase_corrente(NoFr,_),
  1<NoFr,
  risolto(NoFr,SnX,Anaf,Pred), 
  (fact(_,inst_of,[ind:Id,class:C],_,_,_),
  fact(_,name,[Pred,Id],_,_,_);
   fact(_,isa,[ind:Id,class:Pred],_,_,_)),
  nodo(_)::F/R::pred::Pred1,
  Pred1\=Pred,
  nodo(_)::F1/R1::pred::Anaf,
  Args=[R:_,R1:Id],
  aspetto_frase(F_id,Asp),!.


anafora_temp(1, _, F_id,_,_) :-
  time_focus(_, Focus),
  !,
  allen_1(F_id,tr(F_id)), 
  asserta(time_focus(1, tes(F_id))), 
  !.

anafora_temp(NoFr, stato, F_id,tr(F_id)<td(F_id),tr(F_id)=tes(F_id)) :-
  time_focus(_, tes(TF_id)),
  !,
  allen_1(F_id,tr(F_id)),
  relazione(tr(TF_id),tes(TF_id),R1),
  constraints([af,dr,eq],R1,R),
  crea_intervallo(tr(TF_id),tr(F_id)),
  add_rel(tr(TF_id),tr(F_id),R),
  !.

anafora_temp(NoFr, Asp, F_id,tr(F_id)>>td(F_id),tr(F_id)=tes(F_id)) :-
  time_focus(_, tes(TF_id)),
  !,
  allen_1(F_id,tr(F_id)),
  relazione(tr(TF_id),tes(TF_id),R1),
  constraints([af,dr,eq],R1,R),
  crea_intervallo(tr(TF_id),tr(F_id)),
  add_rel(tr(TF_id),tr(F_id),R),
  !.

anafora_temp(NoFr, attivita, F_id,tr(F_id)<td(F_id),tr(F_id)=tes(F_id)) :-
  time_focus(_, tes(TF_id)),
  !,
  allen_1(F_id,tr(F_id)),
  relazione(tr(TF_id),tes(TF_id),R1),
  constraints([af,ov],R1,R),
  crea_intervallo(tr(TF_id),tr(F_id)),
  add_rel(tr(TF_id),tr(F_id),R),
  asserta(time_focus(NoFr, tes(F_id))), 
  !.

anafora_temp(NoFr, Asp, F_id,tr(F_id)<td(F_id),tr(F_id)=tes(F_id)) :-
  time_focus(_, tes(TF_id)),
  !,
    Asp\=attivita,
  allen_1(F_id,tr(F_id)),
  relazione(tr(TF_id),tes(TF_id),R1),
  constraints([af,me],R1,R),
  crea_intervallo(tr(TF_id),tr(F_id)),
  add_rel(tr(TF_id),tr(F_id),R),
  asserta(time_focus(NoFr, tes(F_id))), 
  !.

/* imperfetto caso particolare */
anafora_temp(NoFr,_, F_id,tr(F_id)<td(F_id),incluso(tr(F_id),tes(F_id))) :-
  time_focus(_, tes(TF_id)),
  controllo_semantico(TF_id,accomp/Pred1/Arg1),
  controllo_semantico(F_id,attivita/Pred2/Arg2),
  (Role1=agente;Role1=agent),
  (Role2=tema_aff;Role2=theme_aff),
  (Role3=tema_nonaff;Role3=theme_unaff),
  (nogen_member(Role2:Id1,Arg1),
  nogen_member(Role3:Id1,Arg2)
  ; 
  nogen_member(Role1:Id1,Arg1),
  nogen_member(Role3:Id1,Arg2)), 
  !,
  allen_1(F_id,tr(TF_id)),
  relazione(tr(TF_id),tes(TF_id),R1),
  constraints([eq],R1,R),            
  crea_intervallo(tr(TF_id),tr(F_id)),
  add_rel(tr(TF_id),tr(F_id),R),        
  add_rel(tes(TF_id),tes(F_id),[fb]),
  !.

anafora_temp(NoFr,_, F_id,tr(F_id)<td(F_id),Rel2) :-
  (Rel2 = incluso(tr(F_id),tes(F_id)) 
   ;
   Rel2 = (tes(F_id) < tr(F_id))),
  time_focus(_, tes(TF_id)),
  !,
  allen_1(F_id,tr(TF_id)),
  relazione(tr(TF_id),tes(TF_id),R1),
  constraints([eq,dr],R1,R),
  crea_intervallo(tr(TF_id),tr(F_id)),
  add_rel(tr(TF_id),tr(F_id),R), 
  !.
  
anafora_temp(NoFr, _, F_id,_,_) :-
  time_focus(_, Focus),
  !,
  allen_1(F_id,tr(F_id)), 
  asserta(time_focus(NoFr, tes(F_id))), 
  !.

allen_1(F_id,Ref_int) :-
  allen_1_x(F_id,Ref_int),!.

allen_1_x(F_id, RefInt) :-      
    una_rel(F_id,T),        
    allen_2(T, RefInt),   
    fail.
allen_1_x(_,_) :- !.          


allen_2(I1=I2,RefInt) :- 
                         crea_intervallo(I1,RefInt),
                         crea_intervallo(I2,RefInt),
                         add_rel(I1,I2,[eq]).
allen_2(I1<I2,RefInt) :- 
                         crea_intervallo(I1,RefInt),
                         crea_intervallo(I2,RefInt),
                         add_rel(I1,I2,[bf]).
allen_2(prec_imm(I1,I2),RefInt) :- 
                         crea_intervallo(I1,RefInt),
                         crea_intervallo(I2,RefInt),
                         add_rel(I1,I2,[me]).
allen_2(diverso(I1,I2),RefInt) :- 
                         crea_intervallo(I1,RefInt),
                         crea_intervallo(I2,RefInt),
                         add_rel(I1,I2,[eq]).
allen_2(contemporaneo(I1,I2),RefInt) :- 
                         crea_intervallo(I1,RefInt),
                         crea_intervallo(I2,RefInt),
                         add_rel(I1,I2,[eq]).
allen_2(incluso(I1,I2),RefInt) :- 
                         crea_intervallo(I1,RefInt),
                         crea_intervallo(I2,RefInt),
                         add_rel(I1,I2,[dr,st,fn]).
allen_2(_,_).


/* trova una relazione nel grafo 
   cerca le relazioni di frasi legate alla principale F_id */
una_rel(F_id,Rel1):- 
                      arco(N1,NN,ref_int,Rete),
                      foglia(NN,[tr(F_id)],Rete),
                      (arco(N1,N2,rel1,Rete);
                       arco(N1,N2,rel2,Rete);
                       arco(N1,N2,relavv,Rete);
                       arco(N1,N2,reltr,Rete);
                       arco(N1,N2,reltes,Rete)),
                       foglia(N2,[Rel],Rete),
                       una_rel_x(Rel,Rel1),!.  


una_rel_x(Rel,Rel1) :-
   Rel =.. [F,X,Y],
   (X=td(_) -> Op1 = td; Op1 = X),
   (Y=td(_) -> Op2 = td; Op2 = Y),
   Rel1 =.. [F,Op1,Op2].


scrivi_time_focus(TF) :-
  nl,write('NUOVO TIME FOCUS : '),
  write(TF), nl.


/* lista tutte le relazioni temporali presenti in memoria */
relazioni_temporali :- 
  listing(int_temp),
  listing(is_ref_int),
  listing(has_ref_int),  
  listing(rel_temp).


crea_intervallo(td, _) :-
   (
   int_temp(td),
   !
   ;
   assert(int_temp(td)),
   assert(is_ref_int(td))
   ),
   !.

/* avverbi deittici - IERI */
crea_intervallo(ieri, tr(F)) :-
   (
   int_temp(ieri),
   !
   ;
   crea_intervallo(td, _),
   assert(int_temp(ieri)),
   assert(
      has_ref_int(ieri, td)),
   add_rel(ieri, td, [bf])
   ),
   assert(
      has_ref_int(tr(F), ieri)),
   !.

crea_intervallo(giovedi, tr(F)) :-
   relazione(tr(F), td, [REL1]),
   (
   int_temp(giovedi),
   !
   ;
   crea_intervallo(td, _),
   assert(int_temp(giovedi)),
   assert(
      has_ref_int(giovedi, td)),
   add_rel(giovedi, td, [REL1])
   ),
   assert(
      has_ref_int(tr(F), giovedi)),
   !.

crea_intervallo(tr(F), tr(F)) :-
   crea_intervallo(tr(F), td),
   !.

/* Int non ha un reference interval */
crea_intervallo(Int, nil) :-
   assert_if_needed(int_temp(Int)),
   !.

/* Int non puo' avere come reference interval se' stesso */
crea_intervallo(Int, Int) :-
   assert_if_needed(int_temp(Int)),
   !.


/* Int ha come reference int. Ref_int */
crea_intervallo(Int, Ref_int) :-
   assert_if_needed(int_temp(Int)),
   assert_if_needed(int_temp(Ref_int)),
   assert_if_needed(is_ref_int(Ref_int)),
   assert_if_needed(has_ref_int(Int, Ref_int)),
   !.


relazione_diretta(I,J,R):-
  int_temp(I),
  int_temp(J),
  I @< J,
  rel_temp(_, I,J,R),
  ! ;
  int_temp(I),
  int_temp(J),
  I @> J,
  rel_temp(_, J,I,R1),
  inverti(R1,R),
  ! .




add_rel(I,J,[]) :-!.
add_rel(I,J,R) :-
 subset(R,[bf,af,dr,cn,ov,ob,me,mb,st,sb,fn,fb,eq]),
 !,
  (relazione_diretta(I,J,N),
  !,
  intersezione(R,N,X),
   (subset(X,N),
    !,
    scrivi_rel(I,J,X),
    assertz(todo(I,J)),
    aggiorna 
    ;
    true)
  ;
  scrivi_rel(I,J,R),
  assertz(todo(I,J)),
  aggiorna).
add_rel(_,_,_).

scrivi_rel(I, J, Rel) :-
  Rel\=[],
  I @< J,
  retract_if_possible(rel_temp(_, I,J,_)),
%  !.
  assert_rel_temp(I,J,Rel).

scrivi_rel(I, J, Rel) :-
  Rel\=[],
  I @> J,
  inverti(Rel, InvRel),
  retract_if_possible(rel_temp(_, J,I,_)),
%  !.
  assert_rel_temp(J, I, InvRel).


assert_rel_temp(I, J, Rel) :-
   gen_sym(infon, Inf),
   assert(rel_temp(Inf, I, J, Rel)),
   frase_corrente(NoFr, _),
   current_prop_node(Node),
   assert(confer_rel_temp(NoFr, Node, Inf)).

retract_if_possible(Clause) :-
   retract(Clause),
   !.
retract_if_possible(_).

assert_if_needed(Clause) :-
   call(Clause),
   !.
assert_if_needed(Clause) :-
   assert(Clause).

aggiorna :-
  retract(todo(I,J)),
  relazione_diretta(I,J,Nij),
  (bagof(K/Nki,(comparable(J,K),relazione_diretta(K,I,Nki)),L1),
   !;
   true), 
  (bagof(K/Njk,(comparable(I,K),relazione_diretta(J,K,Njk)),L2),
   aggiorna_y(I,J,Nij,L2),
   !;
   true),
  !,
  aggiorna.
aggiorna :- !.


aggiorna_x(_,_,_,[]) .
aggiorna_x(I,J,Nij,[K/Nki|AltriK]) :-
  constraints(Nki,Nij,Rkj),
  add_rel(K,J,Rkj), 
  aggiorna_x(I,J,Nij,AltriK),!.


aggiorna_y(_,_,_,[]).
aggiorna_y(I,J,Nij,[K/Njk|AltriK]) :-
  constraints(Nij,Njk,Rik),
  add_rel(I,K,Rik),
  aggiorna_y(I,J,Nij,AltriK),!.

comparable(I,K) :-
   has_ref_int(I,K).
comparable(I,K) :-
   has_ref_int(K,I).
comparable(I,K) :-
   has_ref_int(I,R),
   has_ref_int(K,R),
   K \= I.   

constraints(R1,R2,R3) :-
  constraints1(R1,R2,[],R3),!.

constraints1([],_,R3,R3).
constraints1([X1|C1],R2,R3in,R3out) :-
  constraints2(X1,R2,R3in,Rx),
  constraints1(C1,R2,Rx,R3out),!.

constraints2(_,[],R3,R3).
constraints2(X1,[X2|C2],R3in,R3out) :-
  con(X1,X2,R),
  unione(R,R3in,Rx),
  constraints2(X1,C2,Rx,R3out),!.


inv(bf,af).
inv(af,bf). 
inv(dr,cn).
inv(cn,dr).
inv(ov,ob).
inv(ob,ov).
inv(me,mb).
inv(mb,me).
inv(st,sb).
inv(sb,st).
inv(fn,fb).
inv(fb,fn).
inv(eq,eq).


 
inverti([],[]).
inverti([X|L],[Y|L1]) :- inverti(L,L1),
                         inv(X,Y),!.
 
unione([],X,X).
unione([X|R],Y,Z) :- nogen_member(X,Y),
                    !,
                    unione(R,Y,Z).
unione([X|R],Y,[X|Z]) :- unione(R,Y,Z),!.
 


vai_da(Inizio,Destinazione,Percorso) :-
      vai_da1([[Inizio]],Destinazione,Percorso).

vai_da1([Primo|_Resto],Destinazione,Primo) :-
      Primo = [Destinazione|_],!.
vai_da1([[Ultimo|Traccia] | Altri], Destinazione, Percorso) :-
      bagof([Z,Ultimo|Traccia],
             nodo_permesso(Ultimo,Traccia,Destinazione,Z), Lista),
      append(Lista,Altri,Nuove_Strade),
      vai_da1(Nuove_Strade,Destinazione,Percorso)
      ;
      vai_da1(Altri,Destinazione,Percorso),!.        


nodo_permesso(X,Traccia,Destinazione,Y) :-
      (has_ref_int(X,Y);  
       has_ref_int(Y,X),is_ref_int(Y);
       Y=Destinazione,\+ is_ref_int(Y),has_ref_int(Y,X)),
      \+ nogen_member(Y,Traccia),!.

constraint_along_path([X,Y|Altri],Constr) :-
      relazione_diretta(X,Y,Rel),
      constraint_along_path_1([Y|Altri],Rel,Constr), !.
 
constraint_along_path_1([_],C,C) :- !.
constraint_along_path_1([X,Y|Altri],Cin,Cout) :-
      relazione_diretta(X,Y,Rel),
      constraints(Cin,Rel,C),!,
      constraint_along_path_1([Y|Altri],C,Cout).   

path_rel(I,J,R) :- vai_da(J,I,Path),
                   constraint_along_path(Path,R),!.  

relazione_indiretta(I,J,R) :-
      bagof(Rel,path_rel(I,J,Rel),ListaRel),
      rix(ListaRel,R).

rix([R],R).
rix([Rel|AltreRel],NewRel) :-
    rix(AltreRel,Rx),
    intersezione(Rel,Rx,NewRel),!.

relazione(I,J,R) :-
    comparable(I,J),
    relazione_diretta(I,J,R),
    !.

relazione(I, J, R) :-
   (
   relazione_diretta(I, J, R1),
   !
   ;
   R1 = [bf, af, dr, cn, ov, ob, me, mb, st, sb, fn, fb, eq]
   ),
   (
   relazione_indiretta(I, J, R2),
   !
   ;
   R2 = [bf, af, dr, cn, ov, ob, me, mb, st, sb, fn, fb, eq]
   ),
   intersezione(R1, R2, R).

 /* relazioni tra gli intervalli,no info=no con,cio relazione impossibile*/
 /*con(r1,r2,[r]) := A r1 B, B r2 C, A [ri] C */
 
con(bf,bf,[bf]).
con(bf,dr,[bf,ov,me,dr,st]).
con(bf,cn,[bf]).
con(bf,ov,[bf]).
con(bf,ob,[bf,ov,me,dr,st]).
con(bf,me,[bf]).
con(bf,mb,[bf,ov,me,dr,st]).
con(bf,st,[bf]).
con(bf,sb,[bf]).
con(bf,fn,[bf,ov,me,dr,st]).
con(bf,fb,[bf]).
con(bf,eq,[bf]).
 
con(af,af,[af]).
con(af,dr,[af,ob,mb,dr,fn]).
con(af,cn,[af]).
con(af,ov,[af,ob,mb,dr,fn]).
con(af,ob,[af]).
con(af,me,[af,ob,mb,dr,fn]).
con(af,mb,[af]).
con(af,st,[af,ob,mb,dr,fn]).
con(af,sb,[af]).
con(af,fn,[af]).
con(af,fb,[af]).
con(af,eq,[af]).
 
 
con(dr,bf,[bf]).
con(dr,af,[af]).
con(dr,dr,[dr]).
con(dr,ov,[bf,ov,me,dr,st]).
con(dr,ob,[af,ob,mb,dr,fn]).
con(dr,me,[bf]).
con(dr,mb,[af]).
con(dr,st,[dr]).
con(dr,sb,[af,ob,mb,dr,fn]).
con(dr,fn,[dr]).
con(dr,fb,[bf,ov,me,dr,st]).
con(dr,eq,[dr]).
 
con(cn,bf,[bf,ov,me,cn,fb]).
con(cn,af,[af,ob,cn,mb,sb]).
con(cn,dr,[ov,ob,dr,cn,eq]).
con(cn,cn,[cn]).
con(cn,ov,[ov,cn,fb]).
con(cn,ob,[ob,cn,sb]).
con(cn,me,[ov,cn,fb]).
con(cn,mb,[ob,cn,sb]).
con(cn,st,[cn,fb,ov]).
con(cn,sb,[cn]).
con(cn,fn,[cn,sb,ob]).
con(cn,fb,[cn]).
con(cn,eq,[cn]).
 
con(ov,bf,[bf]).
con(ov,af,[af,ob,cn,mb,sb]).
con(ov,dr,[ov,dr,st]).
con(ov,cn,[bf,ov,me,cn,fb]).
con(ov,ov,[bf,ov,me]).
con(ov,ob,[ov,ob,dr,cn,eq]).
con(ov,me,[bf]).
con(ov,mb,[ob,cn,sb]).
con(ov,st,[ov]).
con(ov,sb,[cn,fb,ov]).
con(ov,fn,[dr,st,ov]).
con(ov,fb,[bf,ov,me]).
con(ov,eq,[ov]).
 
con(ob,bf,[bf,ov,me,cn,fb]).
con(ob,af,[af]).
con(ob,dr,[ob,dr,fn]).
con(ob,cn,[af,ob,mb,cn,sb]).
con(ob,ov,[ov,ob,dr,cn,eq]).
con(ob,ob,[af,ob,mb]).
con(ob,me,[ov,cn,fb]).
con(ob,mb,[af]).
con(ob,st,[ob,dr,fn]).
con(ob,sb,[ob,af,mb]).
con(ob,fn,[ob]).
con(ob,fb,[ob,cn,sb]).
con(ob,eq,[ob]).
 
con(me,bf,[bf]).
con(me,af,[af,ob,mb,cn,sb]).
con(me,dr,[ov,dr,st]).
con(me,cn,[bf]).
con(me,ov,[bf]).
con(me,ob,[ov,dr,st]).
con(me,me,[bf]).
con(me,mb,[fn,fb,eq]).
con(me,st,[me]).
con(me,sb,[me]).
con(me,fn,[dr,st,ov]).
con(me,fb,[bf]).
con(me,eq,[me]).
 
con(mb,bf,[ov,bf,me,cn,fb]).
con(mb,af,[af]).
con(mb,dr,[ob,dr,fn]).
con(mb,cn,[af]).
con(mb,ov,[ob,dr,fn]).
con(mb,ob,[af]).
con(mb,me,[st,sb,eq]).
con(mb,mb,[af]).
con(mb,st,[dr,fn,ob]).
con(mb,sb,[af]).
con(mb,fn,[mb]).
con(mb,fb,[mb]).
con(mb,eq,[mb]).
 
con(st,bf,[bf]).
con(st,af,[af]).
con(st,dr,[dr]).
con(st,cn,[bf,ov,me,cn,fb]).
con(st,ov,[bf,ov,me]).
con(st,ob,[ob,dr,fn]).
con(st,me,[bf]).
con(st,mb,[mb]).
con(st,st,[st]).
con(st,sb,[st,sb,eq]).
con(st,fn,[dr]).
con(st,fb,[bf,me,ov]).
con(st,eq,[st]).
 
con(sb,bf,[bf,ov,me,cn,fb]).
con(sb,af,[af]).
con(sb,dr,[ob,dr,fn]).
con(sb,cn,[cn]).
con(sb,ov,[ov,cn,fb]).
con(sb,ob,[ob]).
con(sb,me,[ov,cn,fb]).
con(sb,mb,[mb]).
con(sb,st,[st,sb,eq]).
con(sb,sb,[sb]).
con(sb,fn,[ob]).
con(sb,fb,[cn]).
con(sb,eq,[sb]).
 
con(fn,bf,[bf]).
con(fn,af,[af]).
con(fn,dr,[dr]).
con(fn,cn,[af,ob,mb,cn,sb]).
con(fn,ov,[ov,dr,st]).
con(fn,ob,[af,ob,mb]).
con(fn,me,[me]).
con(fn,mb,[af]).
con(fn,st,[dr]).
con(fn,sb,[af,ob,mb]).
con(fn,fn,[fn]).
con(fn,fb,[fn,fb,eq]).
con(fn,eq,[eq]).
 
con(fb,bf,[bf]).
con(fb,af,[af,ob,mb,cn,sb]).
con(fb,dr,[ov,dr,st]).
con(fb,cn,[cn]).
con(fb,ov,[ov]).
con(fb,ob,[ob,cn,sb]).
con(fb,me,[me]).
con(fb,mb,[sb,ob,cn]).
con(fb,st,[ov]).
con(fb,sb,[cn]).
con(fb,fn,[fn,fb,eq]).
con(fb,fb,[fb]).
con(fb,eq,[fb]).
 
con(eq,bf,[bf]).
con(eq,af,[af]).
con(eq,dr,[dr]).
con(eq,cn,[cn]).
con(eq,ov,[ov]).
con(eq,ob,[ob]).
con(eq,me,[me]).
con(eq,mb,[mb]).
con(eq,st,[st]).
con(eq,sb,[sb]).
con(eq,fn,[fn]).
con(eq,fb,[fb]).
con(eq,eq,[eq]).

con(bf,af,[bf,af,dr,cn,ov,ob,me,mb,st,sb,fn,fb,eq]).
con(af,bf,[bf,af,dr,cn,ov,ob,me,mb,st,sb,fn,fb,eq]).
con(dr,cn,[bf,af,dr,cn,ov,ob,me,mb,st,sb,fn,fb,eq]).


sinf('Supreme_Court', '106181061:n').
sinf(adjudge,' 200558050:v').
sinf(back_judge, '107096135:n').
sinf(chief_justice, '107153375:n').
sinf(102158378, [['judge''s_robe', academic_robe, academic_gown], hy-102764776, mp-102158189]).
sinf(cognovit_judgement, '100769113:n').
sinf(confession_of_judgement, '100769113:n').
sinf(default_judgement, '100769358:n').
sinf(do_justice, ['201715151:v', '201463723:v', '200400180:v']).
sinf(field_judge, '107261949:n').
sinf(fugitive_from_justice, '107282052:n').
sinf(injustice, ['103804255:n', '100479886:n']).
sinf(judge, ['201704695:v', '200657821:v', '200453556:v', '200453431:v', '200452184:v', '107350806:n', '107249386:n']).
sinf(judgement, ['104918568:n', '104495853:n', '104462241:n', '104348023:n', '103831455:n', '100768711:n', '100561563:n']).
sinf(judgement_by_default, '100769358:n').
sinf(judgement_in_personam, '100770295:n').
sinf(judgement_in_rem, '100770536:n').
sinf(judgement_of_dismissal, '100770760:n').
sinf(judgement_on_the_merits, '100770915:n').
sinf(judgement_on_the_pleadings, '100771093:n').
sinf(judgeship, '100390974:n').
sinf(judge_advocate, ['107351312:n', '107351187:n']).
sinf(judge_advocate_general, '107351422:n').
sinf(justice, ['107350806:n', '103801117:n', '100736721:n']).
sinf(justice_of_the_peace, '107353010:n').
sinf(line_judge, '107375369:n').
sinf(misjudge, '200452804:v').
sinf(personal_judgement, '100770295:n').
sinf(poetic_justice, '105440608:n').
sinf(prejudge, '200459860:v').
sinf(prejudgement, '104462403:n').
sinf(side_judge, '107575239:n').
sinf(sound_judgement, '103831455:n').
sinf(state_supreme_court, '106181266:n').
sinf(summary_judgement, '100771093:n').
sinf(supreme_court, '106181266:n').
sinf(trial_judge, '107651276:n').
sinf(103801117, [[justness, justice], hy-[103799301, 103783294]]).
sinf(103804255, [[unjustness, injustice], hy-103784289]).
sinf(103831455, [[perspicacity, sound_judgement, sound_judgment, judgement, judgment], hy-103642179]).
sinf(100390974, [[judicature, judgeship, judgship], hy-100385376]).
sinf(104348023, [[discernment, judgement, judgment, sagaciousness, sagacity], hy-104350566]).
sinf(104462241, [[judging, judgement, judgment], hy-104461523]).
sinf(104462403, [[prejudgement, prejudgment], hy-104462241]).
sinf(104495853, [[mind, judgement, judgment], hy-104564824]).
sinf(104849063, ['Judges', hy-104820634, mp-104851992]).
sinf(104918568, [[opinion, judgement, judgment], hy-104864856]).
sinf(100479886, [[iniquity, unfairness, injustice], hy-100472071]).
sinf(105440608, [[just_deserts, poetic_justice], hy-105438613]).
sinf(100561563, [[assessment, judgement, judgment], hy-100017487]).
sinf(106060223, [['Justice', 'Justice_Department', 'Department_of_Justice'], hy-106056130]).
sinf(106160177, [['World_Court', 'International_Court_of_Justice'], hy-106176884, mm-106156630]).
sinf(106181061, ['Supreme_Court', hy-106179088, mm-106188133]).
sinf(106188133, [judicial_branch, hy-106212528, mm-106187452]).
sinf(106179088, [federal_court, hy-106176884, mm-106001371]).
sinf(106181266, [[high_court, state_supreme_court, supreme_court], hy-106176884]).
sinf(107096135, [back_judge, hy-107271667]).
sinf(107153375, [chief_justice, hy-107350806]).
sinf(107249386, [[judge, evaluator], hy-106947830]).
sinf(107261949, [field_judge, hy-107271667]).
sinf(107282052, [[fugitive_from_justice, fugitive], hy-107193161]).
sinf(107350806, [[magistrate, jurist, justice, judge], hy-[107062449, 107440234]]).
sinf(107351312, [judge_advocate, hy-107169788]).
sinf(107351422, [judge_advocate_general, hy-107169788]).
sinf(107353010, [justice_of_the_peace, hy-107350806]).
sinf(107375369, [line_judge, hy-107271667]).
sinf(100736721, [[judicature, justice], hy-100736489]).
sinf(107575239, [side_judge, hy-107271667]).
sinf(107651276, [trial_judge, hy-107350806]).
sinf(100768711, [[judicial_decision, judgement, judgment], hy-100764878]).
sinf(100769113, [[cognovit_judgement, cognovit_judgment, confession_of_judgement, confession_of_judgment], hy-100768711]).
sinf(100769358, [[judgement_by_default, judgment_by_default, default_judgement, default_judgment], hy-100768711]).
sinf(100770295, [[personal_judgement, personal_judgment, judgement_in_personam, judgment_in_personam], hy-100768711]).
sinf(100770536, [[judgement_in_rem, judgment_in_rem], hy-100768711]).
sinf(100770760, [[dismissal, judgement_of_dismissal, judgment_of_dismissal], hy-100768711]).
sinf(100770915, [[judgement_on_the_merits, judgment_on_the_merits], hy-100768711]).
sinf(100771093, [[judgement_on_the_pleadings, judgment_on_the_pleadings, summary_judgement, summary_judgment], hy-100768711]).
sinf(110889566, [['Last_Day', 'Last_Judgement', 'Last_Judgment', 'Doomsday', 'Day_of_Judgement', 'Day_of_Judgment', 'Judgement_Day', 'Judgment_Day'], hy-110851114]).
sinf(200400180, [do_justice, hyp-201544040]).
sinf(200452184, [judge, en-200494502]).
sinf(200452804, [misjudge, hyp-200417819]).
sinf(200453431, [judge, hyp-200472610]).
sinf(200453556, [[judge, guess, approximate, gauge, estimate], hyp-200430966]).
sinf(200459860, [prejudge, hyp-200452184]).
sinf(200558050, [[hold, adjudge, declare], hyp-200452184]).
sinf(200657821, [[judge, label, pronounce], hyp-200558050]).
sinf(201463723, [do_justice, hyp-201462865]).
sinf(201704695, [[try, adjudicate, judge], hyp-200471542]).
sinf(201715151, [['do-well_by', do_justice], hyp-201713921]).
sinf('Day_of_Judgement', '110889566:n').
sinf('Department_of_Justice', '106060223:n').
sinf('ill-judged', '301827633:s').
sinf('International_Court_of_Justice', '106160177:n').
sinf('judge-s_robe', '102158378:n').
sinf('Judgement_Day', '110889566:n').
sinf('Judges', '104849063:n').
sinf('Justice', '106060223:n').
sinf('Justice_Department', '106060223:n').
sinf('Last_Judgement', '110889566:n').
sinf(107440234, [[functionary, official], hy-107581578]).
sinf(107062449, [adjudicator, hy-100004123]).
sinf(106947830, [authority, hy-106947056]).
sinf(100839315, [[battle_of_Monmouth_Court_House, 'Monmouth_Court_House'], hy-100612706, mp-[106624381, 100852246]]).
sinf(100846556, [[battle_of_Spotsylvania_Courthouse, 'Spotsylvania'], hy-100612706, mp-[106643534, 100849983]]).
sinf(102511950, ['Courtelle', hy-102163870]).
sinf(battle_of_Monmouth_Court_House, '100839315:n').
sinf(battle_of_Spotsylvania_Courthouse, '100846556:n').
sinf('Courtelle', '102511950:n').
sinf('International_Court_of_Justice', '106160177:n').
sinf('Monmouth_Court_House', '100839315:n').
sinf('World_Court', '106160177:n').
sinf(100004123, [[soul, human, mortal, somebody, someone, individual, person], hy-[100003731, 100002086], mm-105957883]).
sinf(107581578, [[trained_worker, skilled_worker], hy-106957738]).

aquawn_hierarchy(W2,NewProp):-
   sinf(W2,Codes),
   extract_nominal_code(Codes,Co),
   sinf(Co, [Infers,InfCodes]),
   aqextract_codes(InfCodes, Hyps),
   extract_synsets(Hyps, Syns),
   append(Infers,Syns,AllInfers),
   elaborate_infers(W2,AllInfers,Props),
   appiattisci(Props,PPros),
   sort(PPros,SortPro),
   aquatraverse_hierarchy(SortPro,NewProp),
   !.

extract_synsets(Codes1, Syns):-
   aqextractssynset(Codes1, Infs, Syns1),
   appiattisci(Syns1, Synoms1),
   aqextractssynset(Infs, Infs2, Syns2),
   appiattisci(Syns2, Synoms2),
   aqextractssynset(Infs2, Infs3, Syns3),
   appiattisci(Syns3, Synoms3),
   append(Synoms1, Synoms2, Synsets1),
   append(Synsets1, Synoms3, Syns),
   !.

aqextract_codes([], []):-!.
aqextract_codes([Code|InfCodes], [Cod|Codes]):-
   atom_to_term(Code,Pcode,_),
   Pcode=Inf-Cod,
   aqextract_codes(InfCodes, Codes),
   !.


aqextractssynset([], [], []):-!.
aqextractssynset([Code|Codes], [Infer|Infs], [Syn|Syns]):-
   sinf(Code,Synsets),
   (Synsets=[Syn], Infer=[]
     ;
    Synsets=[Syn, Infer]
     ;
    Synsets=[Syn|Infer]),
   aqextractssynset(Codes, Infs, Syns),
   !.
aqextractssynset([_-Code|Codes], [Infer|Infs], [Syn|Syns]):-
   sinf(Code,Synsets),
   (Synsets=[Syn], Infer=[]
     ;
    Synsets=[Syn, Infer]
     ;
    Synsets=[Syn|Infer]),
   aqextractssynset(Codes, Infs, Syns),
   !.
aqextractssynset(Codes, [], []):-!.


aquatraverse_hierarchy([],[]):-!.
aquatraverse_hierarchy([P|Pros],[P|NewProp]):-
   sinf(P,Codes),
   extract_nominal_code(Codes,Co),
   sinf(Co, [Infers,Hyps]),
   traverse_hierarchy(Pros,NewProp),
   !.

aquatraverse_hierarchy([P|Pros],[P|NewProp]):-
   recover_description(P, Preds),
   Preds\=P,
   list(Preds),
   on(Pre,Preds),
   sinf(P,Codes),
   extract_nominal_code(Codes,Co),
   sinf(Co, [Infers,Hyps]),
   traverse_hierarchy(Pros,NewProp),
   !.

aquatraverse_hierarchy([P|Pros],NewProp):-
   aquatraverse_hierarchy(Pros,NewProp),
   !.

extract_nominal_code(Codes,Co):-
   on(Code,Codes),
   name(Code,CodeBit),
   reverse(CodeBit,[Cat,_|Rest]),
   name(N,[Cat]),
   N=n,
   reverse(Rest,RevRest),
   name(Co,RevRest).
   

elaborate_infers(W,Infers,Props):-
   remove(W,Infers,Rest),
   gettopics(Topics),
   evaluate_best_topics(Topics,L),
   sort(L, Best),
   grade_best_topics(Best,Graded),
   recover_best_props(Graded,Props),
   !. 

grade_best_topics(Best,Graded):-
  bagof(Id, piu_recente(Id), Ids),
  togli_doppi(Ids, SortId),
  findall(Ind, (on(Ind, SortId),on(_-Ind-_,Best)),Inds),
  sort(Inds,Graded),
  !.

recover_best_props([],[]):-!.
recover_best_props([Id|Rest],[PP|Ps]):-
    setof(P, proprieta(Id, P), PP),
    recover_best_props(Rest,Ps),
    !.

evaluate_best_topics([],[]):-!.
evaluate_best_topics([W|Res],[L-Id-W|Ls]):-
     matchsem_topics(W,Id),
     nonvar(Id),
     findall(N,topic(N,_,Id),K),
     length(K,L),
     evaluate_best_topics(Res,Ls),
     !.
evaluate_best_topics([W|Res],Ls):-
     evaluate_best_topics(Res,Ls),
     !.

smemorizza(Mods, NoFr, Tops, Loc, Temp, Args, Indall) :-
   Args\=[],
   Tops=[Main-F0, Second-F1, Pot-F2, Ante],
   analyze_alltopics(Ante, NoFr, Mods, Main, main, Args, Args1, Ind1, NMain),
   analyze_alltopics(Ante, NoFr, Mods, Second, secondary, Args1, Args2, Ind2, NSecond),
   smem_other(Mods, Args2, [NMain,NSecond,Ante], NoFr, Temp, Loc, Ind3),
   append(Ind1, Ind2, Inds),
   append(Inds, Ind3, Indall).


analyze_alltopics(Antes, NoFr, Mods, Top, Type, Args, Args1, [Ind/SnX], New):-
     Top\=nil,
     Args\=[],
     remove(ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role)/P, Args, Args1),
    Altro=ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role),
    Tab=[Ref, Def, Part, Card, Pro, Ana, Class],
    Pro = +pro,
    Top\=nil,
    ( 
    Antes\=[],
     on(Ante-Top, Antes),
     mcoreference(NoFr, Ante, Id),
     bridging_expression(SnX, NoFr, Id, Ante, Altro, Ind)
     ;
     Top=you, Ante=customer,
     mcoreference(NoFr, Ante, Id),
     bridging_expression(SnX, NoFr, Id, Ante, Altro, Ind)
     ;
    (Top=we,
     legalptopic(NoFr, Altro, SnX, Arg),
     asserta(risolto(NoFr, SnX, narrator, Top))
     ;
      F\=sogg, F\=ogg, F\=subj, F\=obj,
      risolvi_pronomi_interni(Altro, Altri, Ante),
      legalptopic(NoFr, Altro, SnX, Arg),
      asserta(risolto(NoFr, SnX, Ante, Top))
      ;
      (F=sogg; F=ogg; F=subj; F=obj),
     legalptopic(NoFr, Altro, SnX, Arg),
     asserta(risolto(NoFr, SnX, indefinite, Top))),
     history_crea_arg(Arg, Mods, Ind)),
    asserisci_topic(NoFr, secondary, Ind, SnX),
    !.

analyze_alltopics(Antes, NoFr, Mods, Top, Type, Args, Args1, Inds, New):-
   analyze_topics(NoFr, Mods, Top, Type, Args, Args1, Inds, New),
   !.

smem_other(Costs, Args, [Top1,Sec,Ante], NoFr, Temp, Loc, Inds) :-
   (remove_alt(ref_ex(SnX,Top1,Tab,_,Gen,Num,Cat,F/Role)/P, Args, Args1)
     ; Args1=Args),
   (remove_alt(ref_ex(SnX1,Sec,Tab1,_,Gen1,Num1,Cat1,F1/Role1)/P1, Args1, Altri)
     ; Altri=Args1),
   asserisci_altri(Altri,NoFr),
   smem_others(Costs, Args, Altri, Ante, NoFr, Temp, Loc,Inds),
   !.   
smem_other(_, _, _, _, _, _, _).

smem_others(Costs, Args, [], _, NoFr, Temp, Loc, []) :-!.
smem_others(Costs, Args, [Altro/P|Altri], Antes, NoFr, Temp, Loc, [Ind/SnX|Inds]) :-
    Altro=ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role),
    Tab=[Ref, Def, Part, Card, Pro, Ana, Class],
    Pro = +pro,
    Top\=nil,
    ( 
     on(Ante-Top, Antes),
     mcoreference(NoFr, Ante, Id),
     bridging_expression(SnX, NoFr, Id, Ante, Altro, Ind)
     ;
     (F\=sogg, F\=ogg,
      risolvi_pronomi_interni(Altro, Altri, Ante),
      asserta(risolto(NoFr, SnX, Ante, Top))
      ;
      (F=sogg; F=ogg),
     asserta(risolto(NoFr, SnX, indefinite, Top))),
     legal_pot_topic(Args, NoFr, Altro, SnX, Altri1),
     once(sh_crea_arg(Costs, Altri1, Ind, Temp, Loc))),
    asserisci_topic(NoFr, potential, Ind, SnX),
    smem_others(Costs, Args, Altri, Antes, NoFr, Temp, Loc, Inds),
    !.

smem_others(Costs, Args, [Altro/P|Altri], Ante, NoFr, Temp, Loc, [Ind/SnX|Inds]) :-
    Altro=ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role),
    Top\=nil, 
    (integer(Top), 1000 < Top
     ; \+ integer(Top)),
    mcoreference(NoFr, Top, Id),
    asserisci_topic(NoFr, potential, Ind, SnX),
    smem_others(Costs, Args, Altri, Ante, NoFr, Temp, Loc, Inds),
    !.
smem_others(Costs, Args, [Altro/P|Altri], Ante, NoFr, Temp, Loc, [Ind/SnX|Inds]) :-
   legal_pot_topic(Args, NoFr, Altro, SnX, Altri1),
   once(sh_crea_arg(Costs, Altri1, Ind, Temp, Loc)),
   asserisci_topic(NoFr, potential, Ind, SnX),
   dynamic(ref/1),
   smem_others(Costs, Args, Altri, Ante, NoFr, Temp, Loc, Inds),
   !.
smem_others(Costs, Args, [Altro/P|Altri], Ante, NoFr, Temp, Loc, Inds) :-
   smem_others(Costs, Args, Altri, Ante, NoFr, Temp, Loc, Inds),
   !.

risolvi_pronomi_interni(Pron, [Altro/P|Altri], Ante):-
    Pron=ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role),
    Altro=ref_ex(SnX,Testa,Tab1,_,G,N,C,F/Role),
    matcha_features(Testa,Tab,P,G,N,Pers,Gen,Num,C),
    controlla_cat1(Cat,C),
    !.
    
in_frase(Rete, NoFr, NoCl, NoClOut) :-
   abolish(frase_corrente/2),
   asserta(frase_corrente(NoFr, File)),
   estrai_argomenti(Rete, RefList),
   RefList\=[],
   nl,nl,
   writenl('Centering and Topic Hierarchy'),
   write_argomenti('Topics & States', Rete, RefList),
   !,
   risolvi_esterni(NoFr, RefList, Args),
   discorso(NoFr, Args),
   stampa_stato('Topics & States', NoFr),
   !,
   (allen ; true),
   write_temporal_relations('Temporal Relations'),
   !,
   nl, 
   main_location(NoFr, tempo, temporale, RefList, Temp),
   main_location(NoFr, luogo, locativo, RefList, Loc),
   !,
   info_evaluation(NoFr),
	  !,
   memorizza(NoFr, Loc, Temp, RefList),
   write_rhet_structure('Info Evaluation', NoFr),
   !,
   memorizza_rels(NoFr,Lfs,Rels),
   write_ls_structure('L-Structure', Lfs, Rels),
   nl, 
   nl, 
   !,
   write_sentence_infons('Model', NoFr),
   connect_main_temp_loc(NoFr, Temp),  
   nl, 
   !,
   discourse_structure(NoFr, Node, NoCl, Ln, NoClOut, At),
   write_disc_structure('Discourse Structure', NoFr, Node, NoClOut, Ln, At).

in_frase(Rete, NoFr, NoCl, NoCl).

write_temporal_relations(Win) :-
   frase_corrente(NoFr, _),
   nl,
   findall(Inf-I-J-Rel,(
            confer_rel_temp(NoFr, Nodo, Inf), 
            rel_temp(Inf, I, J, Rel)), Rels),
   sort(Rels,Trels),
   writetrels(Trels),
   !.
   
writetrels([]):-!.
writetrels([Inf-I-J-Rel|Trels]):-
   writenl(rel_temp(Inf, I, J, Rel)),
   writetrels(Trels),
   !.


write_main_locations(Win, NoFr) :-
   nl, write_main_loc(NoFr),
   nl, write_main_temp(NoFr), nl, nl,
   !.

write_main_locations(_, _).

write_argomenti(Win, Rete, RefList) :-
%   estrai_argomenti(Rete, RefList),
   writenl('WEIGHTED LIST OF TOPICS : '),
   ppa(RefList, 0), nl,
   !.
write_argomenti(_, _, _).

corefer(NoFr, RefList, L) :-
   risolvi_esterni(NoFr, RefList, L),
   discorso(NoFr, L).

/******************
== Estrae da ogni frase la lista degli argomenti che potrebbero essere ripresi nella frase successiva. La lista e' composta di sintagmi nominali ordinati secondo il peso assegnato loro dalla regola pesa_lista.
La lista viene asserita nel database insieme all'indice di frase relativo. 
******************/
check_lista_refs(List,NList,RList):-
   length(List,L1),
   length(NList,L2),
   elimina_pPros(L1,L2,NList,List,RList),
   !.
  

elimina_pPros(L1,L2,List,NList,RList):-
%   L1\=L2,
   estrai_indici_refs(NList,RList),
   length(RList,L3),
   L3=L1,!.
      
elimina_pPros(L,L,NList,List,List):-!.

estrai_indici_refs([],[]):-!.
estrai_indici_refs([Ref|List],[Nodo|RList]):-
      (Ref=ref_ex(Nodo,Testa,Tab,Pers,Gen,Num,Cat,Funzione/Ruolo)
      ;
      Ref=ref_ex(Nodo,Testa,Contr,Tab,Pers,Gen,Num,Cat,Funzione/Ruolo)),
     estrai_indici_refs(List,RList),
     !.

estrai_argomenti(Rete,RefList) :-
   findall(Ind,
         (
         arco(N1,N2,tab_ref,Rete),
         arco(N1,N3,indice,Rete),
         foglia(N3,Ind,Rete)
         ),
         List),

   maplist(trova_pred,List,NList),
   retractall(ref_ex(_,_,_,_,_,_,_,_)),
   modifica_testa(NList,ListaArgs),
   checklist(assertz,ListaArgs),
   check_lista_refs(ListaArgs,NList,RList),
   maplist(trova_path_1,RList,PList),
   pesa_lista(PList,LisPes),
   crea_lista(LisPes,RefList),
   !.

trova_path_1(Ind,Ind/Path_length) :-
     foglia(N1,Ind,_),
     arco(N,N1,indice,_),
     trova_path_1_aux(n1,N,0,Path_length).

trova_path_1_aux(N1,N1,PL,PL).
trova_path_1_aux(N1,N2,PL1,PL2) :-
   arco(NX,N2,_,_),
   PLX is PL1 + 1,
   trova_path_1_aux(N1,NX,PLX,PL2).

search_sc(N, TestaX, Testa2, Pred, FX) :-
      1<N,
      NoFr is N - 1,
      TestaX\=Testa2,   
      info(NoFr, Node, FunRole, 
         View, Intens, Change, Rel, 
         VerbCat, Verb, TempRel, DiscRel, DiscDom, SubjConsc),
      find_subject(DiscDom, NoFr, SubjConsc, Pred),
        Pred\=narrator,
         TestaX\=Pred.

search_sc(N, TestaX, Testa2, Pred, FX) :-
      1<N,
      NoFr is N - 1,
      info(NoFr, Node, FunRole, 
         View, Intens, Change, Rel, 
         VerbCat, Verb, TempRel, DiscRel, DiscDom, SubjConsc),
      find_subject(DiscDom, NoFr, SubjConsc, Pred),
        Pred\=narrator,
         TestaX\=Pred.

search_sc(N, TestaX, Testa2, Pred, FX) :-
      1<N,
      NoFr is N - 1,
      info(NoFr, Node, FunRole, 
         View, Intens, Change, Rel, 
         VerbCat, Verb, TempRel, DiscRel, DiscDom, SubjConsc),
      find_subject(DiscDom, NoFr, SubjConsc, Pred),
        Pred\=narrator,
         TestaX\=Pred.

infer_antecedent(NumFrase, SnX, ListaArgs, ref_ex(SnX,T,Ta,P,G,Num,C,F/R), Types, L4) :-
       infer_agreement(NumFrase, ref_ex(SnX,T,Ta,P,G,Num,C,F/R), Types, Testa1), 
       append([est(SnX,Testa1)],ListaArgs,L3),
       modifica_testa1(L3,L4).


infer_agreement(NumFrase,  Ref1, [],  Testa1):- Testa1\=[],!.

infer_agreement(NumFrase,  Ref1, [Type | OtherType],  Testa1) :- 
       (infer_agree(NumFrase, Ref1, Type, Testa1)
        ;
        infer_agreement(NumFrase, Ref1, OtherType, Testa1)
       ).


infer_agree(NumFrase, Ref1, prop, Testa1) :-
       proposto(X), X\=nil,
       proposto(ref_ex(_,Test,_,P,G,Nu,C,F1/R1)),
        search_dmod(Test,Id),
       (ent(_,Id)
        ;
        Nu=sing,
        ind(_,Id)),
       matcha(NumFrase, Ref1, proposto, Testa1),
        Testa1\=indefinite.

infer_agree(NumFrase, Ref1, altri, Testa1) :-
       FrasePrec is NumFrase - 1,
       altri(X, FrasePrec), X\=nil,
       altri(ref_ex(_,Test,_,P,G,Nu,C,F1/R1),FrasePrec),
        search_dmod(Test,Id),
       (ent(_,Id)
        ;
        Nu=sing,
        ind(_,Id)),
       matcha(NumFrase, Ref1, altri, FrasePrec, Testa1),
        Testa1\=indefinite.

infer_agree(NumFrase, Ref1, Type, Testa1) :-
       (Type=sec, Funct=secondario
        ;
        Type=prin, Funct=principale
        ),
       Funct=..[F,X], X\=nil,
       matcha(NumFrase, Ref1, Funct, Testa1),
       Testa1\=indefinite.
    

infer_match_global(prop-altri, Pred, Ref1, N, N1, Testa1Y, Testa1) :-
       (proposto(ref_ex(_,Testa1Y,_,_,_,_,_,_)),
       is_a(Testa1Y,Pred),       
       matcha(N,Ref1,altri,N1,Testa1),
          Testa1 \= Testa1Y;
       altri(ref_ex(_,Testa1Y,_,_,_,_,_,_),N1),
       is_a(Testa1Y,Pred),
       matcha(N,Ref1,proposto,Testa1),
       Testa1 \= Testa1Y).

infer_match_global(prin-sec, Testa, RY, Ref1, N, N1, Testa1Y, Testa1) :-
       (
       (RY = tema_bound; RY = theme_bound),
       principale(ref_ex(_,Testa1,_,_,_,_,_,_)),
       is_a(Testa1,Testa), 
       matcha(N,Ref1,secondario,Testa1Y),
       Testa1 \= Testa1Y
       ;
       secondario(ref_ex(_,Testa1,_,_,_,_,_,_)),
       is_a(Testa1,Testa),
       matcha(N,Ref1,principale,Testa1Y),
        Testa1 \= Testa1Y
       ).

check_disjoint(N, Testa, Gen, [prop-sec], Tes, T):- 
      1<N,
      (proposto(Prop), Prop\=nil,
       proposto(ref_ex(_,Testa,_,_,_,_,_,_)),
       proprieta_compl(Id,Testa), T=Testa
       ;
       secondario(Pro), Pro\=nil,
       secondario(ref_ex(_,Test,_,_,_,_,_,_)),
       proprieta_compl(Id,Test), T=Test
       ),
       proprieta_sempl(Id,Tes),
       !.

check_disjoint(N, suocero, Gen, [main-sec, sec-main], Head1, Head2):- 
       1<N,
       fact(_,relat,[figlia,Id,Id1],1,Temp1,Loc1),
       (fact(_,name,[Head1, Id1], 1, _ ,_)
        ;
        fact(_,isa, [ind:Id1, class:Head1], 1, Temp, Loc)),
       fact(_, sposare, [Agen:Id2, Tema:Id],1,_,Loc1),
       (fact(_,name,[Head2, Id2], 1, _ ,_)
        ;
        fact(_,isa, [ind:Id2, class:Head2], 1, Temp2, Loc2)),
       (
       principale(ref_ex(_,Head1,_,_,_,_,_,_)),
%       topic(N,secondary,Id2),
       secondario(ref_ex(_,Head2,_,_,Gen,_,_,_))
         ;
       secondario(ref_ex(_,Head1,_,_,_,_,_,_)),
%       topic(N,main,Id2),
       principale(ref_ex(_,Head2,_,_,Gen,_,_,_))
         ;
       secondario(ref_ex(_,suocero,_,_,_,_,_,_)),
%       topic(N,main,Id2),
       principale(ref_ex(_,Head2,_,_,Gen,_,_,_))
       ),
       check_gender(Gen, Id2),
        Head2 \= Head1, !.

/* infers a set property from its split name single properties */
infer_split_ante(Testa1, [Id, Id1]):-
        proprieta_rec(Ids,Propp),
        set(_,Ids),
       principale(ref_ex(_,Test,_,P,G,Nu,C,F1/R1)),
        (fact(_,name, [Test, Id], 1, Temp, Loc);
        fact(_, isa, [arg:Id, arg:Test], 1, Temp1,Loc1)),
        proprieta_rec(Id1,Prop),
        ind(_,Id1),       
       inclus_in(Id1, Ids),
        (fact(_,name, [Test1, Id1], 1, Temp, Loc);
        fact(_, isa, [arg:Id1, arg:Test1], 1, Temp1,Loc1)),
          Test\=Test1,
       inclus_in(Id, Ids),
          Nu=sing, ind(_,Id),
        (Testa1= [Test,Test1]),
       !.

infer_split_ante(Testa1, [Id, Id1]):-
       (principale(ref_ex(_,Test,_,P,G,Nu,C,F1/R1))
        ;
        altri(ref_ex(_,Test,_,_,G,Nu,C,_/_), N1)),
        (fact(_,name, [Test, Id], 1, Temp, Loc);
        fact(_, isa, [arg:Id, arg:Test], 1, Temp1,Loc1)),
        proprieta_rec(Id1,Prop),
        ind(_,Id1),       
        (fact(_,name, [Test1, Id1], 1, Tem, Lo);
        fact(_, isa, [arg:Id1, arg:Test1], 1, Temp2,Loc2)),
       (principale(ref_ex(_,Test1,_,P,Ge,Nu,C,F1/R1))
        ;
        altri(ref_ex(_,Test1,_,_,Ge,Num,Ca,_/_), N1)
         ;
         search_actors(Test1)),
          Test\=Test1,
          Nu=sing, ind(_,Id),
        (Testa1= [Test,Test1]),
       !.

search_actors(Testa):-
disc_struc(At, NoFr-NoCl, Topics, SimpMainRel, Tint, TempRel,  DiscRel, Strc, SimplDiscDom, Point),
  on(Type:Id:Testa, Topics),!.

in_context(Rete, NoFr, NoCl, Ln, Loc, Temp, At) :-
   abolish(frase_corrente/2),
   asserta(frase_corrente(NoFr, File)),
   estrai_argomenti(Rete, RefList),
   write_argomenti('Topics & States', Rete, RefList),
   !,
   risolvi_esterni(NoFr, RefList, Args),
   discorso(NoFr, Args),
   stampa_stato('Topics & States', NoFr),
   !,
   (allen ; true),
   write_temporal_relations('Temporal Relations'),
   !,
   nl, 
   main_location(NoFr, tempo, temporale, RefList, Temp),
   main_location(NoFr, luogo, locativo, RefList, Loc),
   !,
   info_evaluation(NoFr),
	  !,
   memorizza(NoFr, Loc, Temp, Args),
   write_rhet_structure('Info Evaluation', NoFr),
   !,
   write_sentence_infons('Model', NoFr),
   connect_main_temp_loc(NoFr, Temp),
   !,
   discourse_structure(NoFr, Node, NoCl, Ln, NoCls, At),
   write_disc_structure('Discourse Structure', NoFr, Node, NoCl, Ln, At).

/*
d_structure(
   NoFr, Node, NoCl, 
   Topics, DiscRel, TempRel,
   fact(InfonId, Rel, Args, Pol, Temp, Loc),
   State, DiscMove, DiscLev, Attach_Cl)
*/

build_facts(NoFr, Node, Rel, Args, Pol, Temp, Loc):-
     vpred_smap(Node, rel:Rel, Rel),
     funcs_smap(funcs, NoFr, Node, Locs, inds(In, _), _, _),
     pol_smap(Node, Pol),
     current_main_loc(PrecNoFr, tempo, Tempr),
     current_main_loc(PrecNoFr, luogo, Locr),
     (Tempr=ref_ex(univ), Temp=univ;
     Tempr=ref_ex(Temp, _)),
     (Locr=ref_ex(univ), Loc=univ;
     Locr=ref_ex(Loc, _, _, _, _, _, _, _)),
     assign_index(NoFr, Loc, Temp, In, Args).

build_facts(NoFr, Node, Rel, Args, Pol, Temp, Loc):-
     nodo(N)::ip_ell/prop::nodo(N2),
     nodo(N1)::adjs::adj/Role::sem_mark::Rel,
     adjs_smap(funcs, NoFr, N, Locs, inds(In, _), _, _),
     pol_smap(N, Pol),
     current_main_loc(PrecNoFr, tempo, Tempr),
     current_main_loc(PrecNoFr, luogo, Locr),
     (Tempr=ref_ex(univ), Temp=univ;
     Tempr=ref_ex(Temp, _)),
     (Locr=ref_ex(univ), Loc=univ;
     Locr=ref_ex(Loc, _, _, _, _, _, _, _)),
     assign_index(NoFr, Loc, Temp, In, Args).


discourse_structure(NoFr, NNode, NoCl, Ln, Ncs, At) :-
   prop_roots(Nodes),
   nl,
   clauses_d_structure(Nodes, NNode, NoFr, NoCl, NCl, Lin, At),
   (NCl=[NoCl], Lin=NoCl,
    Ln is NoCl + 1, Ncs = NCl
    ; 
   append([NoCl], NCl, Ncc),
   sort(Ncc, Ncs), Ln=Lin).

/*
clauses_d_structure([], [], _, NoCl, [], NnoCl, []):-
   var(NoCl).

clauses_d_structure([], [], _, NoCl, [], NoCl, []):-!.

*/

clauses_d_structure([], [], _, NoCl, [], NoCl, []):-!.

clauses_d_structure([Nod-Fun/Role|Nodes], [Nod|Node], NoFr, NoCl, [NewNoCl|NoCls], Ln, [Nat|At]) :-
   clause_d_structure(
      NoFr, Nod, NoCl, 
      Topics, DiscRel, TempRel, MainRel, Stato, DiscMove, DiscLev, Nat),
   asserta(
      d_structure(
         NoFr, Nod, NoCl, Topics, DiscRel, 
         TempRel, MainRel, Stato, DiscMove, DiscLev)),
%   write_discourse_structure('Discourse Structure', NoFr, Node, NoCl, At),
  (Nodes\=[], NewNoCl is NoCl + 1
   ;
   Nodes=[], NewNoCl=NoCl),
  clauses_d_structure(Nodes, Node, NoFr, NewNoCl, NoCls, Ln, At).

clauses_d_structure([Nod-Fun/Role|Nodes], [Nod|Node], NoFr, NoCl, NoCls, Ln, At) :-
  clauses_d_structure(Nodes, Node, NoFr, NewNoCl, NoCls, Ln, At).


recover_preceding_d_structure(0,PrecDiscRel,PrecState, PrecDiscMove, PrecDiscLev):-
   d_structure(_, _, 0, _, PrecDiscRel, _, _, PrecState, PrecDiscMove, PrecDiscLev),
   !.
recover_preceding_d_structure(NoCl,PrecDiscRel,PrecState, PrecDiscMove, PrecDiscLev):-
   nonvar(NoCl), 
   (PrecNoCl is NoCl - 1,
    d_structure(_, _, PrecNoCl, _, PrecDiscRel, _, _, PrecState, PrecDiscMove, PrecDiscLev)
     ;
    d_structure(_, _, PreNoCl, _, PrecDiscRel, _, _, PrecState, PrecDiscMove, PrecDiscLev)),
   !.
recover_preceding_d_structure(1,[],[], [], []):-
   !.
recover_preceding_d_structure(0,[],[], [], []):-
   !.


check_rel_disc_info(Rel):-
      d_structure(
         NoFr, Nod, NoCl, Topics, DiscRel, 
         TempRel, MainRel, Stato, DiscMove, DiscLev),
    MainRel=..[fact,_, Rel1|_],
    Rel\=Rel1,
   !.

getstate(NoFr, State):-
   stato(NoFr, State),
   !.
getstate(NoFr, retaining):-!.

capturessinfo(NoFr, SnX, Rel, Args, Pol, Temp, Loc):-
    confer_infon(InfonId, NoFr, SnX, _, main),
    (
     fact(InfonId, Rel, Args, Pol, Temp, Loc)
     ;
     sit(InfonId, Rel, Args, Pol, Temp, Loc)
     ),
   !.

capturesstop(NoFr, SnX, Rel, Args, Pol, Temp, Loc):-
    confer_topic(NoFr, Type, Ind, SnX, _),
    (
     fact(_, isa, [ind:Ind, Class:_],Pol, Temp, Loc)
     ;
     sit(_, isa, [ind:Ind, Class:_],Pol, Temp, Loc)),
    Args=[_:Ind],
   !.
capturesstop(NoFr, SnX, Rel, Args, Pol, Temp, Loc):-
    confer_topic(NoFr, Type, Ind, SnX, _),
    (
     fact(_, Re, [ind:Ind, Class:_],Pol, Temp, Loc)
     ;
     sit(_, Re, [ind:Ind, Class:_],Pol, Temp, Loc)),
    Args=[_:Ind],
   !.

capturesstop(NoFr, SnX, Rel, Args, Pol, Temp, Loc):-
    confer_infon(InfonId, NoFr, SnX, _, Main),
    (
     fact(InfonId, Rel, Args, Pol, Temp, Loc)
     ;
     sit(InfonId, Rel, Args, Pol, Temp, Loc)
     ),
   !.

getrelsnx(Rel,SnX):-
    nodo(N)::pred::Rel,
    nodo(N)::F/R::indice::SnX,
   !.

clause_d_structure(Prop, Rel,FTopics, 
   NoFr, Node, NoCl, DiscRel, TempRel,
   fact(InfonId, Rel, Args, Pol, Temp, Loc),
   State, DiscMove, DiscLev, Attach_Cl)
   :-
   (
    capturessinfo(NoFr, SnX, Rel, Args, Pol, Temp, Loc)
    ;
    Prop=main/_,
    (
     fact(InfonId, Rel, Args, Pol, Temp, Loc)
     ;
     sit(InfonId, Rel, Args, Pol, Temp, Loc)
     ;
     build_facts(NoFr, Node, Rel, Args, Pol, Temp, Loc)
     )),
   getstate(NoFr, State),
   recover_preceding_d_structure(NoCl,PrecDiscRel,PrecState, PrecDiscMove, PrecDiscLev),
   !,   
   disc_move(NoCl, FTopics, TempRel, PrecDiscMove,
      DiscRel, PrecDiscRel, PrecState, State,  PrecDiscLev,
      DiscLev, DiscMove, Attach_Cl).

clause_d_structure(Prop, Rel,FTopics, 
   NoFr, Node, NoCl, DiscRel, TempRel,
   fact(InfonId, Rel, Args, Pol, Temp, Loc),
   State, DiscMove, DiscLev, Attach_Cl)
   :-
   check_rel_disc_info(Rel),
   (Prop=relp/prop,
    getrelsnx(Rel,SnX),
    capturesstop(NoFr, SnX, Rel, Args, Pol, Temp, Loc)
    ;
    Prop=_/prop,
    (capturesstop(NoFr, SnX, Rel, Args, Pol, Temp, Loc)
         ;
     build_facts(NoFr, Node, Rel, Args, Pol, Temp, Loc)
     )
    ;
    Prop=adj/_,
    (capturesstop(NoFr, SnX, Rel, Args, Pol, Temp, Loc)
     ;
     build_facts(NoFr, Node, Rel, Args, Pol, Temp, Loc)
     )
    ),
   getstate(NoFr, State),
   recover_preceding_d_structure(NoCl,PrecDiscRel,PrecState, PrecDiscMove, PrecDiscLev),
   !,   
   disc_move(NoCl, FTopics, TempRel, PrecDiscMove,
      DiscRel, PrecDiscRel, PrecState, State,  PrecDiscLev,
      DiscLev, DiscMove, Attach_Cl),!.

/*
clause_d_structure(
   NoFr, Node, NoCl, 
   FTopics, DiscRel, TempRel,
   fact(InfonId, Rel, Args, Pol, Temp, Loc),
   State, DiscMove, DiscLev, Attach_Cl)
   :-
   findall(
      Type:Ind:Pred,
      ( 
      trova_topics(NoFr, Type, Pred, Ind), nonvar(Ind)
      ),
      Topics),
   filter_topics(Topics, FTopics),
   once(info(
      NoFr, Nod, Prop, _, _,_, _,
      _, Rel, TempRel, DiscRel, _, _)),
    (nodo(N)::pred::Rel,
     nodo(N)::F/R::indice::SnX,
     confer_topic(NoFr, Type, Ind, SnX, _),
    (
     fact(_, Re, [ind:Ind, class:_],Pol, Temp, Loc)
     ;
     sit(_, Re, [ind:Ind, class:_],Pol, Temp, Loc)),
    Args=[_:Ind],
    Fact=fact(idx, Re, Args, Pol, Temp, Loc)
    ;
    Prop=_/prop,
    (confer_topic(NoFr, Type, Ind, SnX, _),
    fact(_, Re, [ind:Ind, class:_],Pol, Temp, Loc),
    Args=[_:Ind],
    Fact=fact(idx, Re, Args, Pol, Temp, Loc)
         ;
     build_facts(NoFr, Node, Re, Args, Pol, Temp, Loc)
     )
    ;
    Prop=adj/_,
    (confer_topic(NoFr, Type, Ind, SnX, _),
    fact(_, Re, [ind:Ind, class:_],Pol, Temp, Loc),
    Args=[_:Ind],
    Fact=fact(idx, Re, Args, Pol, Temp, Loc)    
         ;
     build_facts(NoFr, Node, Re, Args, Pol, Temp, Loc)
     )
    ),
   stato(NoFr, State),
   recover_preceding_d_structure(NoCl,PrecDiscRel,PrecState, PrecDiscMove, PrecDiscLev),
   !,   
   disc_move(NoCl, FTopics, TempRel, PrecDiscMove,
      DiscRel, PrecDiscRel, PrecState, State,  PrecDiscLev,
      DiscLev, DiscMove, Attach_Cl).
*/

filter_topics(Topics, Tops):-
    filtertopics(Topics, FTopics),
    sort(FTopics, NTopics),
    (remove(T:Id:Pred-sc, NTopics, Top),
     remove(T:Id:Pred, Top, Tops)
     ;
     Tops=NTopics),
    !.

filtertopics([], []):-!.
filtertopics([A, A|Topics], [A|FTopics]):-
    filtertopics(Topics, FTopics),!.

filtertopics([T:Id:Pred, T1:Id:Pred|Topics], [T:Id:Pred|FTopics]):-
    filtertopics(Topics, FTopics),!.

filtertopics([T:Id:Pred-sc, T1:Id:Pred|Topics], [T:Id:Pred|FTopics]):-
    filtertopics(Topics, FTopics),!.

filtertopics([T:Id:Pred, T1:Id:Pred-sc|Topics], [T:Id:Pred|FTopics]):-
    filtertopics(Topics, FTopics),!.

filtertopics([A|Topics], [A|FTopics]):-
    filtertopics(Topics, FTopics),!.

trova_topics(NoFr, Type, Pred, Ind) :-
   extract_tpi(Type, Pred, SnX),
   semantic_ind(NoFr, Type, Ind, SnX, Pred).

semantic_ind(NoFr, Type, nil, SnX, indefinite-sc):-!.
semantic_ind(NoFr, Type, nil, SnX, indefinite):-!.

semantic_ind(NoFr, Type, Ind, SnX, Pred-sc):-
   confer_topic(NoFr, Type, Ind, SnX, _),!.

semantic_ind(NoFr, Type, Ind, SnX, Pred):-
   confer_topic(NoFr, Type, Ind, SnX, _),!.

semantic_ind(NoFr, Type, Ind, SnX, Pred-sc):-
   (ind_description(Ind, Pred)
     ;
    nonvar(Pred)
   ),!.

semantic_ind(NoFr, Type, Ind, SnX, Pred):-
   (ind_description(Ind, Pred)
     ;
    nonvar(Pred)
   ),!.

extract_tpi(main, Pred, SnX):-
   principale(ref_ex(SnX,Pred-sc,_,_,_,_,_,_)).

extract_tpi(secondary, Pred, SnX):-
   secondario(ref_ex(SnX,Pred-sc,_,_,_,_,_,_)).

extract_tpi(expected, Pred, SnX):-
   proposto(ref_ex(SnX,Pred-sc,_,_,_,_,_,_)).

extract_tpi(main, Pred, SnX):-
   principale(ref_ex(SnX,Pred,_,_,_,_,_,_)).

extract_tpi(secondary, Pred, SnX):-
   secondario(ref_ex(SnX,Pred,_,_,_,_,_,_)).

extract_tpi(expected, Pred, SnX):-
   proposto(ref_ex(SnX,Pred,_,_,_,_,_,_)).


infer_topics(NoCl, Topics, Lev, to(NoFr-PrecNoCl)):-
     PrecNoCl is NoCl - 1,
     d_structure(
      NoFr, _, PrecNoCl, PrecTopics, _, _, _, _, _, Lev),      
   (on(expected:Ind:Pred, Topics)
    ;
    on(main:Ind:Pred, Topics)),
   confer_infon(InfonId, NoFr, _, _, main),
   (fact(InfonId, Rel, Args, Pol, Temp, Loc)
    ;
    sit(InfonId, Rel, Args, Pol, Temp, Loc)),
   on(_:Ind, Args).


write_disc_structure(Win, NoFr, [], [], NoC, []).

write_disc_structure(Win, NoFr, Nodes, NoCls, NoC, Ats):-
%   remove(NoC, NoCls, Ncls),
   (is_list(NoCls), Ncls=NoCls, Nods=Nodes;
    atomic(NoCls), Ncls=[NoCls], Nods=[Nodes]),
   w_d_s(Win, NoFr, Nods, Ncls, NoC, Ats).

write_disc_structure(_, _, _, _, _, _).

w_d_s(Win, NoFr, [N|Nodes], [NC|NoCls], NoC, [At|Ats]):-
   write_discourse_structure(Win, NoFr, N, NC, At),
   w_d_s(Win, NoFr, Nodes, NoCls, Nn, Ats),!.

w_d_s(_, _, _, _, _, _).

write_discourse_structure(Win, NoFr, N, NoCl, At):-
   d_structure(
      NoFr, Node, NoCl, Topics, DiscRel, 
      TempRel, MainRel, Stato, DiscMove, DiscLev),
   (info(
          NoFr, Node, _, _, _,_, _,
          _, _, _, _, DiscDom, Subject); DiscDom=objective, Subject=objective),
   simplify_domain(MainRel,DiscDom, SimplDiscDom),
   simplify_main_rel(MainRel, SimpMainRel),
   functor(At, Attach, _),
   (Attach=new;
    Attach=to, Move=up;
    Move=Attach
    ), 
   build_temp_int(Move, NoFr-NoCl, FrCl, TempRel, Tint, Strc),
   find_subject(SimplDiscDom, NoFr, Subject, Point), 
   asserta(
      disc_struc(At,
         NoFr-NoCl, Topics, SimpMainRel, Tint, TempRel, 
         DiscRel, Strc, SimplDiscDom, Point)),
   write_dis_struc(Win, NoFr, Node, NoCl, At, DiscLev, 
        Topics, SimpMainRel, Attach, Move, Tint, TempRel, 
        DiscRel, Strc, SimplDiscDom, Point).


write_dis_struc(Win, NoFr, Node, NoCl, At, DiscLev, Topics, SimpMainRel,
        Attach, Move, Tint, TempRel, DiscRel, Strc, SimplDiscDom, Point)
   :-  
    nl,
   ( 
    Attach=new,
    Tab is DiscLev * 3,
    tab(Tab), 
    write('root:'), 
    writenl(At)
    ;
    Attach=to,
    Tab is DiscLev * 3,
    tab(Tab), 
    write('up:'), 
    writenl(At)
    ;
    Attach=down,
    Tab is DiscLev * 6,
    tab(Tab), 
    write('down:'), 
    writenl(At)
    ;
   Tab is DiscLev * 6,
   tab(Tab), 
   write('same_level:'),  
   writenl(At)
   ),
   tab(Tab), write('clause:'), writenl(NoFr-NoCl),
   tab(Tab), write('topics:'), writenl(Topics),
   tab(Tab), write('main_fact:'), writenl(SimpMainRel),
   At=..[_,FrCl],
   (
   tab(Tab), write('ref_int:'), writenl(Tint),
   tab(Tab), write('temp_rel:'), writenl(TempRel)
    ;
    genre(legal)),
   tab(Tab), write('disc_rel:'), writenl(DiscRel),
   tab(Tab), write('disc_seg:'), writenl(Strc),
   tab(Tab), write('disc_dom:'), writenl(SimplDiscDom),
   tab(Tab), write('p_o_view:'), writenl(Point),
   !.
write_dis_struc(_, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _).
   
build_temp_int(_, 1-1, _, TempRel, tint(T1, []), Strc):-
   nonvar(TempRel),
   arg(1,TempRel,T1),
   arg(2,TempRel,T2),
   Strc = 1-[1],
   retractall(current_temp_int(_, _, _)),
   assert(current_temp_int(1-1, tint(T1, []), Strc)).

build_temp_int(Move, NoFr-NoCl, At, TempRel, Tint, CurrStr):-
   time_focus(_, TF), TF=nil,
   nonvar(TempRel),
   TempRel =.. [TR, Tes1, Tes2],
   (NoCl=1, PNoCl=1; 1 < NoCl, PNoCl is NoCl - 1),
%   current_temp_int(_-PNoCl, tint(OldTF, OldInts), OldNoCl-Strc),
   build_interval(NoCl, PNoCl, PNoCl, nil, TF, Move, Tes1,TR, OldInts, [], NewTF, NewInts, CurrStr),
   Tint=tint(NewTF, NewInts),
   assertz(current_temp_int(NoFr-NoCl, Tint, CurrStr)).

build_temp_int(Move, NoFr-NoCl, At, TempRel, Tint, CurrStr):-
   time_focus(_, TF),
   nonvar(TempRel),
   TempRel =.. [TR, Tes1, Tes2],
   (NoCl=1, PNoCl=1; 1 < NoCl, PNoCl is NoCl - 1),
   current_temp_int(_-PNoCl, tint(OldTF, OldInts), OldNoCl-Strc),
   build_interval(NoCl, PNoCl, OldNoCl, OldTF, TF, Move, Tes1,TR, OldInts, Strc, NewTF, NewInts, CurrStr),
   Tint=tint(NewTF, NewInts),
   assertz(current_temp_int(NoFr-NoCl, Tint, CurrStr)).
    


build_interval(2, PrecNoCl, OldNoCl, TF, TF, Move, Tes1, TR, OldInts, Strc, TF, NewInts, CurrStr):-
   NewInts=[Tes1],
   append(Strc, [2], NewStr),
   CurrStr = OldNoCl-NewStr.

build_interval(NoCl, PrecNoCl, OldNoCl, TF, TF, down, Tes1, TR, OldInts, Strc, TF, NewInts, CurrStr):-
   NewInts=[Tes1],
   NewStr = [NoCl],
   CurrStr = PrecNoCl-NewStr.

build_interval(NoCl, PrecNoCl, OldNoCl, OldTF, TF, Move, Tes1, TR,OldInts, Strc, TF, [], CurrStr):-
    OldTF\=TF,
    NewStr = [NoCl],
    CurrStr = PrecNoCl-NewStr.


build_interval(NoCl, PrecNoCl, OldNoCl, TF, TF, Move, Tes1, before,OldInts, Strc, TF, NewInts, CurrStr):-
   NewInts=[Tes1],
   NewStr = [NoCl],
   CurrStr = PrecNoCl-NewStr.

build_interval(NoCl, PrecNoCl, OldNoCl, TF, TF, Move, Tes1, TR,OldInts, Strc, TF, NewInts, CurrStr):-
   append(OldInts, [Tes1], NewInts),
   append(Strc, [NoCl], NewStr),
   CurrStr = OldNoCl-NewStr.

build_interval(NoCl, PrecNoCl, OldNoCl, OldTF, TF, Move, Tes1, TR,OldInts, Strc, OldTF, NewInts, CurrStr):-
   OldTF\=TF,
   Move\=up,
   append(OldInts, [Tes1], NewInts),
   append(Strc, [NoCl], NewStr),
   CurrStr = OldNoCl-NewStr.


build_interval(NoCl, PrecNoCl, OldNoCl, OldTF, TF, up, Tes1, TR,OldInts, Strc, TF, NewInts, CurrStr):-
   OldTF\=TF,
   current_temp_int(At, tint(PrecTf, OldTints), PrecStr),
   NewTF=TF,
   NewInts=[PrecTf],
   At = PrecFr-PrecCl,
   NewStr = [NoCl],
   CurrStr = PrecCl-NewStr.

build_interval(NoCl, PrecNoCl, OldNoCl, TF, TF, same_level, Tes1, TR, OldInts, Strc, TF, NewInts, CurrStr):-
   genre(legal),
   append(OldInts, [Tes1], NewInts),
   append(Strc, [NoCl], NewStr),
   CurrStr = OldNoCl-NewStr.

build_interval(NoCl, PrecNoCl, OldNoCl, OldTF, TF, Move, Tes1, TR, OldInts, Strc, TF, NewInts, CurrStr):-
   genre(legal),
   NewInts=[OldTF],
   NewStr = [NoCl],
   CurrStr = PrecNoCl-NewStr.


find_subject(_, NoFr, nil, narrator):-!.
find_subject(objective, NoFr, Subject, legislator):-
   genre(legal). 

find_subject(objective, NoFr, Subject, narrator). 

find_subject(subjective, NoFr, Subject, Tes):- 
     Subject=sc(_-Root, Index, Pred),
     1<NoFr,risolto(_,SnY,Tes,Pred). 

find_subject(subjective, NoFr, Subject, Pred):- 
    Subject=sc(_-Root, Index, Pred),
    allowablesoc(Pred). 

find_subject(implicit_subjective, NoFr, Subject, Pred):- 
    Subject=sc(_-Root, Index, Pred),
    allowablesoc(Pred). 

find_subject(explicit_subjective, NoFr, Subject, Pred):- 
    Subject=sc(_-Root, Index, Pred),
    allowablesoc(Pred). 

find_subject(Subjective+P, NoFr, Subject, Pred):- 
    Subjective=.. [pre_subjective, _-Root, Index, Pred],
    Subject=sc(_-Root, Index, Pred),
    allowablesoc(Pred).  

% pre_subjective(2-n3, sn42, john)+explicit_subjective

simplify_main_rel(MainRel, SimpMainRel) :-
   MainRel=..[Fact, _, Rel, Args, Pol, _, Loc],
   nonvar(Rel), atomic(Rel),
   ((Rel=essere; Rel=be; Rel=have; Rel=avere),
   simplify_args_pred(Args, Rel, NewRel, NewArgs)
   ;
   simplify_args(Args, NewArgs),
   NewRel=Rel),
   atomic(NewRel),
   SimpMainRel=..[NewRel, NewArgs, Pol, Loc].

simplify_args_pred([prop: Ind | Args], _, NewRel, [Id:Rel | NewArgs]) :-
   (
   fact(Ind, NewRel, [nil:Id], _, _, _),
   fact(Inf, isa, [_:Id, _:Rel], _, _, _)
   ;
   fact(Ind, NewRel, [nil:Id], _, _, _),
   fact(Inf, name, [Rel, Id], _, _, _)
   ;
   in(_, Id, Ind),
   in(_, Id1, Ind), Id\=Id1,
   fact(Inf, isa, [_:Id, _:NewRel], _, _, _)
   ;
   sit(Ind, NewRel, [nil:Id], _, _, _),
   sit(Inf, isa, [_:Id, _:Rel], _, _, _)
   ),
   !,
   simplify_args( Args, NewArgs).


simplify_args_pred([Role1: Ind1, Role2 : Ind2], Rel, NewRel, [Ind1:Role1, Ind2:Role2]) :-
    new_pred(Rel,NewRel),   !.


simplify_args([prop: Ind | Args], [Id:Rel | NewArgs]) :-
   (
   fact(Ind, role, [Rel, _, Id], _, _, _)
   ;
   sit(Ind, role, [Rel, _, Id], _, _, _)
   ),
   simplify_args( Args, NewArgs).

simplify_args([prop: Ind | Args], [Ind:Rel | NewArgs]) :-
   (
   fact(_, isa, [ind:Ind, class:Rel], _, _, _)
   ;
   sit(_, isa, [ind:Ind, class:Rel], _, _, _)
   ;
   fact(_, isa, [arg:Ind, arg:Rel], _, _, _)
   ;
   sit(_, isa, [arg:Ind, arg:Rel], _, _, _)
   ), Rel\=ev, Rel\=st, Rel\=pr,
   simplify_args( Args, NewArgs).

simplify_args([prop: Ind | Args], [Ind:Rel | NewArgs]) :-
   (
   fact(Ind, Rel, _, _, _, _)
   ;
   sit(Ind, Rel, _, _, _, _)
   ),
   simplify_args( Args, NewArgs).

simplify_args([propq: Ind | Args], [Ind:Rel | NewArgs]) :-
   (
   fact(Ind, Rel, _, _, _, _)
   ;
   sit(Ind, Rel, _, _, _, _)
   ),
   simplify_args( Args, NewArgs).

simplify_args([propint: Ind | Args], [Ind:Rel | NewArgs]) :-
   (
   fact(Ind, Rel, _, _, _, _)
   ;
   sit(Ind, Rel, _, _, _, _)
   ),
   simplify_args( Args, NewArgs).

simplify_args([propadj: Ind | Args], [Ind:Rel | NewArgs]) :-
   (
   fact(Ind, Rel, _, _, _, _)
   ;
   sit(Ind, Rel, _, _, _, _)
   ),
   simplify_args( Args, NewArgs).

simplify_args([Role : Ind | Args], [Ind:Desc | NewArgs]) :-
   (ind_description(Ind, Desc)    ;
    role_ind_description(Ind, Role, Desc)),
   simplify_args( Args, NewArgs).

simplify_args([Ind | Args], [Ind:Desc | NewArgs]) :-
   atomic(Ind),
   ind_description(Ind, Desc),
   simplify_args( Args, NewArgs).

simplify_args([Ind | Args], [Id:Desc | NewArgs]) :-
   Ind=ind(Isy, Id, Desc),
   (nonvar(Desc);
    var(Desc),
       (ind_description(Id, Desc)
    ;
    role_ind_description(Id, Role, Desc))
    ),
   simplify_args( Args, NewArgs).
   
simplify_args([], []) :-
   !.

ind_description(Ind, Name) :-
   fact(_, name, [Name, Ind], 1, _, _),
   !.

ind_description(Ind, Class) :-
    in(_,Ind,Id),
     (fact(_, isa, [_:Id, _:Class], _, _, _);
      sit(_,isa, [_:Id, _:Class], _, _, _)).

ind_description(Ind, Class) :-
     (fact(_, isa, [_:Ind, _:Class], _, _, _);
      sit(_,isa, [_:Ind, _:Class], _, _, _);
      fact(_, inst_of, [_:Ind, _:Class], _, _, _)), Class\=sloc, 
     !.

ind_description(Ind, Class) :-
    class(_,Ind),
    fact(_, Class, [Ind], _, _, _).

ind_description(Ind, Class) :-
    fact(_, Class, [arg:Ind], _, _, _).

ind_description(Ind, disc_set:Set) :-
    ent(_,Ind),
    fact(_, prop, [arg:Ind, disc_set:Set], _, _, _).

role_ind_description(Ind, Role, Class) :-
    new_ind(Ind), 
    nodo(N)::_/Role::pred::Class.

role_ind_description(_, Role, Class) :-
    nodo(N)::_/Role::pred::Class.

simplify_domain(_,objective, objective) :-
   !.
simplify_domain(_,pre_subjective(_, _, _), objective) :-
   !.
simplify_domain(_,_, subjective) :-
   !.

/* ************************************************************************ */

cont_discorso(N,Args) :-
       N1 is N - 1,
       Args=[ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX)/_|Altri],
       stato(N1,Stato),
       contdiscs(Stato,N,N1,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri),
       !.

contdiscs(resume,N,N1,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri) :-
      disc_resume(N,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri),
      !.

contdiscs(Stato,N,N1,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri) :-
      (Stato=cambia;Stato=retaining;Stato=shifting),
      disc_cambia(N,N1,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri),
      !.

contdiscs(Stato,N,N1,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri) :-
       (Stato=retaining;Stato=cambia;Stato=resume),
      disc_retain(N,N1,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri),
      !.

contdiscs(Stato,N,N1,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri) :-
      disc_cont(N,N1,Stato,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri),
      !.
    
/*  -sc  r_prin, r_prop, a_prin, a_sec, State=continua
30 il Pred  un sc che sostituisce il pron indefinito */
create_disc_grid2(N, SnX-TestaY-sc, Pred, Altri, r_prin, r_prop, a_prin, a_sec, continua):-
       nonvar(TestaY),
       principale(Prin),
       proposto(ref_ex(_,TestaY,TabX,PersX,GenX,NumX,CcX,FX/RX)),
       retract(proposto(Pro)),
       retract(principale(Prin)),
       assert(stato(N,continua)),
       assert(proposto(nil)),
       assert(principale(Prin)),
       recover_sec(altri, ref_ex(_,TestaY,TabX,PersX,GenX,NumX,CcX,FX/RX), Altri, N),!.     

create_disc_grid2(N, TestaX-sc, Ref1, Altri, r_prin, r_prop, a_prin, a_sec, continua):-
       nonvar(TestaX),
       principale(Prin),
       N1 is N - 1,
       once(altri(ref_ex(_,TestaY,TabA,PersA,GenA,NumA,CatA,_),N1)),
       retract(proposto(Pro)),
       retract(principale(Prin)),
       assert(stato(N,continua)),
       assert(proposto(nil)),
       assert(principale(Ref1)),
       recover_sec(altri, ref_ex(_,TestaY,TabA,PersA,GenA,NumA,CatA,_), Altri, N),!.     


/*  -sc  r_prop, r_altri, a_prin, a_sec, State=continua
31 il best candidate e' il principale e il proposto diviene secondario */
create_disc_grid2(N, TestaX-sc, Ref1, Altri, r_prop, r_altri, a_prin, a_sec, 
        continua) :-
       principale(ref_ex(_,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)),
       retract(principale(_)),
       assert(principale(Ref1)),        
       retract(proposto(Prop)),
       assert(proposto(nil)),       
       retract(secondario(_)),
       assert(secondario(ref_ex(SnP,PredP,_,PersP,GenP,NumP,CatP,_))),
       asserisci_altri(Altri,N),
       assert(stato(N,continua)),!.


create_disc_grid2(N, TestaX-sc, Ref1, Altri, r_prop, r_altri, a_prin, a_sec, 
        continua) :-
       retract(proposto(ref_ex(SnP,PredP,TabP,PersP,GenP,NumP,CatP,_))),
       assert(proposto(nil)),       
       retract(secondario(_)),
       assert(secondario(ref_ex(SnP,PredP,_,PersP,GenP,NumP,CatP,_))),
       retract(principale(_)),
       assert(principale(Ref1)),        
       asserisci_altri(Altri,N),
       assert(stato(N,continua)),!.

/*  -sc  r_sec, r_prin, a_prop, a_sec, State=continua
32 il best candidate e' il secondario che diviene principale e il primo degli altri diviene secondario */
create_disc_grid2(N, TestaX-sc, Ref1, Altri, r_sec, r_prin, a_prop, a_sec, 
       continua) 
       :-
       secondario(ref_ex(_,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)),
       once(altri(ref_ex(_,TestaP,TabA,PersA,GenA,NumA,_,_),N1)),
       elimina(ref_ex(Sn,TestaP,_,Pers,Gen,Num,Cat,_/_)/_,Altri, La),
       principale(Prin),
       retract(proposto(_)),
       retract(principale(_)),
       assert(proposto(Ref1)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       retract(secondario(_)),
       assert(secondario(ref_ex(Sn,TestaP,_,Pers,Gen,Num,Cat,_))),
       asserisci_altri(La,N),
       assert(stato(N,retaining)),!.

checkitenglfeats(CcX,Feat):-
   nogen_member(sociale,CcX), Feat=sociale;
    nogen_member(legale,CcX), Feat=legale;
    nogen_member(sostanza,CcX), Feat=sostanza
    ;
    nogen_member(social,CcX), Feat=social;
    nogen_member(legal,CcX), Feat=legal;
    nogen_member(substance,CcX), Feat=substance,
    !.
    
/*  8 lo stato  cambia: si cerca un sc e lo si sostituisce al pronome indefinite come new main */

disc_cambia(N,N1,ref_ex(SnX,TestaX-sc,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
/*    
(elimina(ref_ex(SnY,indefinite-sc,_,Pers,Gen,Num,Cat,_/_)/_,Altri,La)
     ;
     La=Altri),
*/
    create_disc_grid3(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       Altri, r_prin, r_prop, a_prin, a_sec, continua),
       !.

disc_cambia(N,N1,ref_ex(SnX,indefinite-sc,TabX,PersX,GenX,NumX,CcX,FX/Tema),Altri)
    :-
    TabX=[+ ref, + def, nil, nil, + pro, + ana, + me],
    search_sc(N, TestaX, Testa2, Pred, FX),
    search_dmod(Pred,Id),
    create_disc_grid2(N, indefinite, Pred, Altri, r_prin, r_prop, a_prin, a_sec, continua),
       !.

/*  1 il primo  uguale al proposto */
disc_cambia(N,N1,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
   (TestaX=T-sc, Ref=ref_ex(SnX,T,TabX,PersX,GenX,NumX,CcX,FX/RX);
    TestaX\=T-sc, Ref=ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX)),
   create_disc_grid3(N, Ref, Altri, r_prop, r_prin, a_prin, a_sec, continua),
   !.

disc_cambia(N,N1,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
   TestaX=T-sc, Ref=ref_ex(SnX,T,TabX,PersX,GenX,NumX,CcX,FX/RX),
    create_disc_grid2(N, TestaX-sc, Ref, Altri, r_prop, r_altri, a_prin, a_sec, continua),
   !.

disc_cambia(N,N1,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
      principale(ref_ex(SnY,Testa2,_,PersS,GenS,NumS,CatS,_/_)),
      search_sc(N, TestaX, Testa2, Testa2, FX),
      create_disc_grid3(N, ref_ex(SnY,Testa2,_,PersS,GenS,NumS,CatS,_/_), Altri, r_prin, r_prop, a_prin, a_sec, 
        continua),
       !.

/*  2  lo stato e' cambia
    si passa in continua: il primo argomento  un nome proprio e ne esiste un secondo con la stessa funzione grammaticale. Assieme costituiscono un set da coriferire con il proposto nome comune plurale. Si chiamano i fatti corrispondenti ai nomi dal model e si cerca la proprieta corrispondente, se coincide si continua con il proposto e si mette in secondario quello precedente   */

disc_cambia(N,N1,ref_ex(SnX,TestaX,[+ref,def0,nil,nil,-pro,-ana,-class],PersX,GenX,sing,CcX,FX/RX),Altri)
   :-
   Altri\=[],
   proposto(ref_ex(_,TestaP,_,PersP,GenP,plur,_,_)),
   nogen_member(ref_ex(SnY,TestaY,[+ref,def0,nil,nil,-pro,-ana,-class],PersY,GenY,sing,CatY,FX/RY)/Py, Altri),
   fact(_,name, [TestaY, Id], 1, univ, univ),
   in(_, Id, Idx),
   fact(_,isa,[ind:Idx,class:TestaP],1,Temp, Loc),
   set(_, Idy),
   card(_, Idy, 2),
   in(_, Idy, Idx),
   elimina(ref_ex(SnY,TestaY,_,_,_,_,_,_/_)/_,Altri,L),
   retract(principale(_)),
   assert(principale(ref_ex(SnX,TestaP,_,PersP,GenP,NumP,CatY,FX/RX))),               
   retract(secondario(Sec)),
   assert(secondario(Sec)),
   retract(proposto(_)),
   assert(proposto(nil)),
   assert(stato(N,cambia)),
   asserisci_altri(L,N),
   !.

disc_cambia(N,N1,Ref1,Altri):-
   Ref1=ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),
   noton(+pro, TabX),
   checkitenglfeats(CcX,Feat),
   create_disc_grid4(N, Ref1, Altri, Feat, continua),
   !.

/*  4 lo stato e' cambia si passa in continua: il primo  uguale al proposto   */
disc_cambia(N,N1,Ref1,Altri)
   :-
   create_disc_grid3(N, Ref1, Altri, r_prop, r_altri, a_prin, a_sec, continua),
    !.

/*  3  lo stato e' cambia
    si passa in retaining: il primo argomento e' indefinito ed il secondo coriferisce al proposto oppure ad altri: il primo viene sistemato in proposto e il secondo in secondario  */

disc_cambia(N,N1,Ref1,Altri)
   :-
   create_disc_grid3(N, Ref1, Altri, r_prop, r_altri, a_prop, a_sec, retaining),
    !.

/*  6 lo stato e' cambia
    si passa in continua: l'argomento proposto e altri dello stato precedente coincidono con i primi due dello stato attuale - quindi i due argomenti vengono sistemati come proposto e secondario   */

disc_cambia(N,N1,Ref1,Altri)
   :-
   (create_disc_grid3(N, Ref1, Altri, r_altri, r_prop, a_prop, a_sec, continua) 
    ; 
   create_disc_grid3(N, Ref1, Altri, r_altri, r_prop, a_prop, a_sec, retaining) 
    ),
    !.
/*  7 lo stato  cambia: il secondo argomento  uguale al primo degli altri o al proposto, si passa in retaining */

/*  10 il primo  un oggetto */
disc_cambia(N,N1,ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R),Altri)
   :-
   member(oggetto,Cat),!, 
  (R=tema_nonaff
    ;
   elimina(ref_ex(SnY,TestaY,_,PersY,GenY,NumY,CatY,sogg_foc/tema_nonaff)/_,
           Altri,La)),
   retract(secondario(_)),
   assert(secondario(ref_ex(SnY,TestaY,_,PersY,GenY,NumY,CatY,_/_))),
   proposto(ref_ex(SnP,TestaP,TabP,PersP,GenP,NumP,CatP,_)),
   retract(principale(_)),
   assert(principale(ref_ex(SnP,TestaP,_,PersP,GenP,NumP,CatP,_))),
   retract(proposto(_)),
   assert(proposto(nil)),
   asserisci_altri(La,N),
   asserta(po_view(N,TestaP)),
   assert(stato(N,continua)),
   !.

/* il primo  indefinito e non ci sono altri argomenti che riprendono quello proposto precedentemente */

disc_cambia(N,N1,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
   Altri\=[],
   proposto(ref_ex(SnY,TestaP,TabP,PersP,GenP,NumP,_,_)),
   TabX = [+ref,-def,nil,nil,-pro,-ana,+class],
   (
    (nogen_member(sociale,CcX)
     ;nogen_member(social,CcX)
     ;nogen_member(role,CcX)),
    current_main_loc(N1, luogo, LocInfo),
    arg(1, LocInfo, Ind),
    arg(2, LocInfo, Pred),
    infer_mereology(TestaX,Pred),
    retract(proposto(_)),
    retract(principale(_)),
    retract(secondario(_)),
    assert(principale(ref_ex(SnY,TestaP,_,PersP,GenP,NumP,_,_))),
    assert(stato(N,cambia)),
    assert(proposto(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
    assert(secondario(nil)),
    asserisci_altri(Altri,N)
   ;

    retract(proposto(_)),
    retract(principale(_)),
    retract(secondario(_)),
    assert(principale(nil)),
    assert(stato(N,retaining)),
    assert(proposto(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
    assert(secondario(ref_ex(SnY,TestaP,_,PersP,GenP,NumP,_,_))),
    asserisci_altri(Altri,N)),
    !.


/* 1  lo stato e' retaining
    si passa in continua: il proposto  un nome proprio che viene
ripreso da una sua propriet conosciuta nel mondo; si cerca il fatto
che asserisce questa propriet che deve coincidere con la testa del
primo argomento della frase corrente    */
disc_retain(N,N1,ref_ex(SnX,TestaX-sc,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
      proposto(ref_ex(SnY,Testa2,_,PersS,GenS,NumS,CatS,_/_)),
      search_sc(N, TestaX, Testa2, [], FX),
      create_disc_grid5(N, SnX-TestaX-sc, Altri, r_prop, r_altri, a_prin, a_sec, continua),
        !.

disc_retain(N,N1,ref_ex(SnX,TestaX-sc,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
      principale(ref_ex(SnY,Testa2,_,PersS,GenS,NumS,CatS,_/_)),
      search_sc(N, TestaX, [], [], FX),
      create_disc_grid2(N, TestaX-sc, Pred, Altri, r_prin, r_prop, a_prin, a_sec, 
        continua),
       !.

disc_retain(N,N1,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
   Altri\=[],
   proposto(ref_ex(_,TestaP,_,PersP,GenP,NumP,Cat,_)),
   Altri=[ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CcY,FY/RY)/Py|LA],
   TabX = [+ref,+def,nil,Card,-pro,-ana,+class],
   NumX=sing,
   fact(_,name, [TestaP, Id], 1, Temp, Loc),
   in(_, Id, Idx),
   fact(_,isa,[ind:Idx,class:TestaX],1,Te,Lo),
   principale(ref_ex(_,TestaX,_,Pers,Gen,Num,Cc,F/R)),
   retract(principale(_)),
   assert(principale(ref_ex(SnX,TestaP,_,PersP,GenP,NumP,Cat,FX/RX))),               
   retract(secondario(_)),
   assert(secondario(ref_ex(_,TestaY,_,PersY,GenY,NumY,CcY,FY/RY))),
   retract(proposto(_)),
   assert(proposto(nil)),
   assertz(risolto(N, SnX, TestaX, TestaP)),     % memorizza risolti 
   assert(stato(N,resume)),
   asserisci_altri(LA,N),
   !.

/* 2 c' un proposto nella frase precedente */
disc_retain(N,N1,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
   Altri\=[],
   proposto(ref_ex(SnP,TestaP,_,PersP,GenP,NumP,Cat,_)),
   TabX = [+ref,def0,nil,nil,-pro,-ana,-class],
   NumX=sing,
   fact(_,name, [TestaX, Id], 1, Temp, Loc),
   in(_, Id, Idx),
   fact(_,isa,[ind:Idx,class:TestaP],1,Te,Lo),
   retract(principale(_)),
   assert(principale(ref_ex(SnP,TestaP,_,PersP,GenP,NumP,Cat,FX/RX))),               
   retract(secondario(_)),
   assert(secondario(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
   retract(proposto(_)),
   assert(proposto(nil)),
   assertz(risolto(N, SnX, TestaP, TestaX)),     % memorizza risolti 
   assert(stato(N,resume)),
   asserisci_altri(Altri,N),
   !.


/*  3  lo stato attuale e_ continua o resume e il primo argomento e_ un deittico quantificato: maggiore, altri, ecc.  */
disc_retain(N,N1,Ref1,Altri) :-
   create_disc_grid3(N, Ref1, Altri, r_prop, r_prin, a_prin, a_sec, cont_analyze),
   !.

/* 4 */
disc_retain(N,N1,Ref1,Altri) :-
   create_disc_grid3(N, Ref1, Altri, r_prop, r_altri, a_prin, a_sec, continua),
   !.


/* 6 */
disc_retain(N,N1,Ref1,Altri) :-
   Ref1=ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),
   noton(+pro, TabX),
   checkitenglfeats(CcX,Feat),
   create_disc_grid4(N, Ref1, Altri, Feat, continua),
   !.

 /* 5 */
disc_retain(N,N1,Ref1,Altri)
   :-
   create_disc_grid3(N, Ref1, Altri, r_prin, r_altri, a_prin, a_sec, ContCamb),
   !.

/*  1 */
/*  13 */
disc_cont(N,N1,Stato,ref_ex(SnX,TestaX-sc,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
  (Stato=continua;Stato=resume;Stato=shifting),
   nonvar(TabX),
   (TabX=[+ ref, + def, nil, nil, - pro, + ana, + me, - subj]
    ;
    TabX=[+ ref, + def, nil, nil, + pro, + ana, + me]
    ;
    TabX=[+ ref, + def, nil, nil, + pro, - ana, + me]),
   (
    Altri=[ref_ex(SnY,TestaY-sc,TabY,PersY,GenY,NumY,CcY,FY/RY)/Py|LA],
    create_disc_grid(N, N1, SnY-TestaY-sc, SnX-TestaX-sc, LA, r_prin, r_sec, a_prin, a_sec, continua)
     ;
    Altri=[ref_ex(SnY,TestaY-sc,TabY,PersY,GenY,NumY,CcY,FY/RY)/Py|LA],
    create_disc_grid(N, N1, SnY-TestaY-sc, SnX-TestaX-sc, LA, r_prin, r_altri, a_prin, a_sec, continua)
     ;
    Altri=[ref_ex(SnY,TestaY-sc,TabY,PersY,GenY,NumY,CcY,FY/RY)/Py|LA],
    create_disc_grid2(N, SnY-TestaY-sc, TestaX, LA, r_prin, r_prop, a_prin, a_sec, continua)
    ;
    create_disc_grid2(N, pron, TestaX, Altri, r_prin, r_prop, a_prin, a_sec, continua)
    ;
    create_disc_grid5(N, TestaX, Altri, r_prin, r_altri, a_prin, a_sec, continua)
    ),
    !.


disc_cont(N,N1,Stato,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
      TabX = [+ref,def0,nil,Card,-pro,-ana,-class],
      principale(ref_ex(SnY,Testa2,_,PersS,GenS,NumS,CatS,_/_)),
      search_sc(N, TestaX, Testa2, Pred, FX),
       create_disc_grid2(N, Pred-sc, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       Altri, r_sec, r_prin, a_prop, a_sec, continua), 
       !.

disc_cont(N,N1,Stato,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
    elimina(ref_ex(SnY,indefinite,_,Pers,Gen,Num,Cat,_/_)/_,Altri,La),
    create_disc_grid3(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       La, r_prin, r_prop, a_prin, a_sec, continua),
       !.

disc_cont(N,N1,Stato,ref_ex(SnX,indefinite,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
      principale(ref_ex(SnY,Testa2,_,PersS,GenS,NumS,CatS,_/_)),
      search_sc(N, indefinite, Testa2, Pred, FX),
      create_disc_grid5(N, Pred, Altri, r_prin, r_sec, a_prin, a_sec, continua),
       !.

disc_cont(N,N1,Stato,Ref1,Altri)
   :-
   Ref1=ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),
   noton(+pro, TabX),
   checkitenglfeats(CcX,Feat),
   create_disc_grid4(N, Ref1, Altri, Feat, continua),
   !.

/*   3  lo stato attuale e_ continua o resume e il primo argomento e_ un deittico quantificato: maggiore, altri, ecc.  */
disc_cont(N,N1,Stato,Ref1,Altri)
   :-
   Stato = cont_analyze,        
   create_disc_grid3(N, Ref1, Altri, r_prin, r_altri, a_prin, a_sec, cont_analyze),
   !.

/* 1  lo stato e'continua: il secondario  un nome proprio che viene
ripreso da una sua propriet conosciuta nel mondo; si cerca il fatto
che asserisce questa propriet che deve coincidere con la testa del
primo argomento della frase corrente    */
disc_cont(N,N1,continua,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
   Altri\=[],
   secondario(ref_ex(_,TestaP,_,PersP,GenP,NumP,Cat,_)),
   Altri=[ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CcY,FY/RY)/Py|LA],
   TabX = [+ref,+def,nil,Card,-pro,-ana,+class],
   NumX=sing,
   fact(_,name, [TestaP, Id], 1, Temp, Loc),
   in(_, Id, Idx),
   fact(_,isa,[ind:Idx,class:TestaX],1,Te,Lo),
   principale(ref_ex(_,TestaX,_,Pers,Gen,Num,Cc,F/R)),
   retract(principale(_)),
   assert(principale(ref_ex(SnX,TestaP,_,PersP,GenP,NumP,Cat,FX/RX))),               
   retract(secondario(_)),
   assert(secondario(ref_ex(_,TestaY,_,PersY,GenY,NumY,CcY,FY/RY))),
   retract(proposto(_)),
   assert(proposto(nil)),
   assertz(risolto(N, SnX, TestaX, TestaP)),     % memorizza risolti 
   assert(stato(N,resume)),
   asserisci_altri(LA,N),
   !.

/*  4 lo stato attuale  continua: il principale e il secondario vengono inferiti dal modello e sono rispettivamente il best candidate e il secondo; il principale precedente non corrisponde al best match*/ 
disc_cont(N,N1,Stato,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
   (Stato = continua ; Stato = cont_analyze),           
   Altri\=[],
   principale(ref_ex(_,TestaP,_,Pers,Gen,Num,Cc,F/R)),
   TestaP\=TestaX,
   Altri=[ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CcY,FY/RY)/Py|LA],
   RX\=tema_bound,RX\=theme_bound,
   ( TabX \= [+ref,+def,nil,nil,-pro,-ana,-class],
     TabY \= [+ref,+def,nil,nil,-pro,-ana,-class]),
   fact(_,name, [TestaX, Id], 1, univ, univ),
   fact(_,name, [TestaY, Id1], 1, univ, univ),
   retract(principale(_)),
   assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),               
   retract(secondario(_)),
   assert(secondario(ref_ex(SnY,TestaY,_,PersY,GenY,NumY,CcY,FY/RY))),
   retract(proposto(_)),
   assert(proposto(nil)),
   assert(stato(N,resume)),
   asserisci_altri(LA,N),
   !.
/*  5 lo stato attuale  continua: esiste un candidato che  sogg_foc, e viene messo nel principale; il best candidate viene messo nel secondario */ 
disc_cont(N,N1,Stato,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
   (Stato = continua ; Stato = cont_analyze),        
   Altri\=[],
   elimina(ref_ex(SnY,TestaY,_,PersY,GenY,NumY,CcY,sogg_foc/_)/_,Altri,L),
   TabX = [+ref,+def,nil,nil,-pro,-ana,-class],
   fact(_,name, [TestaX, Id], 1, univ, univ),
   in(_, Id, Idx),
   fact(_,isa,[ind:Idx,class:TestaP],1,Te,Lo),
   principale(ref_ex(_,TestaP,_,Pers,Gen,Num,Cc,F/R)),
   retract(principale(_)),
   assert(principale(ref_ex(SnY,TestaY,_,PersY,GenY,NumY,CcY,FY/RY))),
   retract(secondario(_)),
   assert(secondario(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),               
   retract(proposto(_)),
   assert(proposto(nil)),
   assert(stato(N,shifting)),
   asserisci_altri(L,N),
   !.

/*  6 il principale non coincide con il best candidate e nemmeno il secondario oppure  vuoto; il best candidate esiste nel modello e viene messo nel proposto mentre il principale precedente viene messo nel secondario */
disc_cont(N,N1,Stato,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
   (Stato = retaining ; Stato = continua ; Stato = cont_analyze),        
   principale(ref_ex(SnP,TestaP,_,Pers,Gen,Num,Cc,F/R)),
   TestaP\=TestaX,
   (secondario(ref_ex(SnS,TestaS,_,Per,Ge,Nu,C,_)),
    TestaX\=TestaS
    ;
    secondario(nil)),
   (TabX = [+ref,+def,nil,Card,-pro,-ana,+class],
    (Num=plur,
     trova_card(SnX,NumX,Part, Quant, Card,Card0),
     card(_, Id, Card0),
      (in(_,Idx,Id),
       fact(_,isa,[ind:Idx,class:TestaX],1,Te,Lo)
       ;
       set(_, Id),
      fact(_,isa,[ind:Id,class:TestaX],1,Te,Lo))
    ;
    Num=sing),
    fact(_,isa,[ind:Idx,class:TestaX],1,Te,Lo)
   ;
   (TabX = [+ ref, def0, nil, nil, - pro, - ana, - class]
    ;
    TabX = [+ ref, + def, nil, nil, + pro, + ana, + me]),
   fact(_,name,[TestaX,Id],1,Te,Lo)),
   retract(proposto(_)),
   assert(proposto(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
   retract(secondario(_)),
   assert(secondario(ref_ex(SnP,TestaP,_,Pers,Gen,Num,Cc,F/R))),               
   retract(principale(_)),
   assert(principale(nil)),
%   assertz(risolto(N, SnX, TestaX, TestaX)),     % memorizza risolti 
   assert(stato(N,resume)),
   asserisci_altri(Altri,N),
   !.

/*  7 il best candidate coincide con il principale e non con il secondario ed esiste un nome proprio negli altri: poi il best candidate  una propriet nel modello e il secondario asserisce un fatto relativo ad esso; il nome proprio della lista Altri viene cercato nel modello e diviene proposto mentre il best candidate diviene secondario */
disc_cont(N,N1,Stato,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
   (Stato = continua ; Stato = cont_analyze),        
   Altri\=[],
   principale(ref_ex(SnP,TestaP,_,Pers,Gen,Num,Cc,F/R)),
   TestaP=TestaX,
   secondario(ref_ex(SnS,TestaS,_,Per,Ge,Nu,C,_)),
   TestaX\=TestaS,
   Altri=[ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CcY,FY/RY)/Py|LA],
   TabY = [+ ref, def0, nil, nil, - pro, - ana, - class],
   Nu=NumY,
   fact(_,isa,[ind:Idx,class:TestaX],1,T,L),
   fact(_,TestaS,[Idx],1,Te,Lo),
   fact(_,name,[TestaY,Id],1,Tem,Loc),
   in(_,Id,Idx),
   retract(proposto(_)),
   assert(proposto(ref_ex(SnY,TestaY,_,PersY,GenY,NumY,CcY,FY/RY))),
   retract(secondario(_)),
   assert(secondario(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),               
   retract(principale(_)),
   assert(principale(nil)),
   assert(stato(N,resume)),
   asserisci_altri(Altri,N),
   !.

disc_cont(N,N1,Stato,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
   (Stato = continua ; Stato = cont_analyze),        
   principale(ref_ex(SnP,TestaP,_,Pers,Gen,Num,Cc,F/R)),
   TestaP=TestaX,
   secondario(ref_ex(SnS,TestaS,_,Per,Ge,Nu,C,_)),
   TestaX\=TestaS,
   (Altri=[],
    retract(secondario(_)),
    assert(secondario(ref_ex(SnS,TestaS,_,Per,Ge,Nu,C,_))),        
    asserisci_altri(Altri,N)
   ;
    recover_sec(altri,Altri,N)
   ),
   retract(proposto(_)),
   assert(proposto(nil)),
   retract(principale(_)),
   assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
   assert(stato(N,continua)),
   !.

/*  8  stato precedente : continua o retaining
   il primo argomento della frase attuale coincide con quello principale stato = continua */

disc_cont(N,N1,Stato,Ref1,Altri)
   :-
   (Stato = continua ; Stato = retaining ; Stato = cont_analyze),
   create_disc_grid3(N, Ref1, Altri, r_prin, r_altri, a_prin, a_sec, continua), 
     !.

/*  9 stato precedente : continua o retaining
   il primo argomento della frase attuale non coincide con quello principale l' argomento principale e' comunque membro della lista argomenti della frase attuale stato = retaining  */

disc_cont(N,N1,Stato,Ref1,Altri)
   :-
   (Stato = continua ; Stato = retaining ; Stato = cont_analyze),
   create_disc_grid3(N, Ref1, Altri, r_altri, r_prop, a_prop, a_sec, Stato),
   !.

/*  10 */
disc_cont(N,N1,retaining,Ref1,Altri)
   :-
create_disc_grid3(N, Ref1, Altri, r_prin, r_prop, a_prin, a_sec, continua),
   !.

/*  11 */
disc_cont(N,N1,retaining,Ref1,Altri)
   :-
create_disc_grid3(N, Ref1, Altri, r_prop, r_prin, a_prin, a_sec, continua),
   !.


/*  12 il principale viene introdotto ed  il primo nella lista degli argomenti, il secondario  il principale precedente ed  presente nella lista degli args come lista */
disc_cont(N,N1,continua,ref_ex(Sn,Testa,_,Per,Ge,Nu,Ca,_/_),Altri)
   :-
   Altri\=[],
   principale(ref_ex(Sn1,Testa1,_,Pers1,Gen1,Num1,Cat1,_/_)),
   nogen_member(ref_ex(SnX,Testa2,_,Pers,Gen,Num,Cat,_/_)/_,Altri),
   nogen_member(Testa1,Testa),
   retract(principale(_)),
    assert(principale(ref_ex(Sn1,Testa1,_,Pers1,Gen1,Num1,Cat1,_/_))),               
    retract(proposto(_)),
    assert(proposto(ref_ex(SnX,Testa2,_,Pers,Gen,Num,Cat,_/_))),
    retract(secondario(_)),
    assert(secondario(ref_ex(Sn,Testa,_,Per,Ge,Nu,Ca,_/_))),
    elimina(ref_ex(SnX,Testa2,_,Pers,Gen,Num,Cat,_/_)/_,Altri, LA),
    asserisci_altri(LA,N),
    assert(stato(N,retaining)),!.


/* 14 Il primo ref_ex della frase corrente  secondario della precedente: diventa proposto.C' un'anafora che riprende il principale della precedente: diventa topic secondario.
 */

disc_cont(N,N1,Stato,Ref1,Altri)
   :-
   create_disc_grid3(N, Ref1, Altri, r_sec, r_prin, a_prop, a_sec, continua),
   !.

/* 15 */
disc_cont(N,N1,Stato,Ref1,Altri)
   :-
   create_disc_grid3(N, Ref1, Altri, r_altri, r_prop, a_prop, a_sec, retaining),
   !.

recover_sec(_, [], N) :-
    retract(secondario(_)),
    assert(secondario(nil)),
    asserisci_altri([],N),
    !.

recover_sec(nil, Altri, N) :-
   (
    secondario(ref_ex(_,Testa2,_,_,_,_,_,_/_)),
    efface(ref_ex(SnY,Testa2,_,PersS,GenS,NumS,CatS,FS/RS)/_,Altri,Altri1),
    retract(secondario(_)),
    assert(secondario(ref_ex(SnY,Testa2,_,PersS,GenS,NumS,CatS,FS/RS))),
    asserisci_altri(Altri1,N)
    ;
    scarica_secondario(N),
    asserisci_altri(Altri,N),
    assert(secondario(nil))
    ), !.

recover_sec(altri, Altri, N) :-
    Altri\=[], 
    Altri=[ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CcY,FY/RY)/Py|LA],
    Py < 125,
    retract(secondario(Sec)),
    (TabY\=[+ ref, + def, nil, nil, + pro, - ana, + class],
    check_human_sec(N,ref_ex(SnY,TestaY,_,PersY,GenY,NumY,CcY,FY/RY),Altri,LA)
    ;
    assert(secondario(nil)),
    asserisci_altri(Altri,N)),
    !.

recover_sec(altri, Altri, N) :-
    (secondario(Sec),
     retract(secondario(_)),
     assert(secondario(Sec))
     ;
     retract(secondario(_)),
     assert(secondario(nil))
    ),
    asserisci_altri(Altri,N),
    !.

recover_sec(prop, Altri, N) :-     
    Altri=[ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CcY,FY/RY)/Py|LA],
    scarica_proposto(N),
    scarica_secondario(N),
    check_human_sec(N,ref_ex(SnY,TestaY,_,PersY,GenY,NumY,CcY,FY/RY),Altri,LA),
    !.

recover_sec(altri, [], Altri, N) :-
    scarica_secondario(N),
    assert(secondario(nil)),
    asserisci_altri(Altri,N),
    !.
recover_sec(altri, ref_ex(SnY,indefinite,_,PersY,GenY,NumY,CcY,FY/RY), Altri, N) 
    :-
    secondario(Sec),
    retract(secondario(_)),
    assert(secondario(Sec)),
    asserisci_altri(Altri,N),
    !.

recover_sec(altri, ref_ex(SnY,TestaY,_,PersY,GenY,NumY,CcY,FY/RY), Altri, N) 
    :-
    (nogen_member(sociale,CcY);
    nogen_member(social,CcY)),
    secondario(Sec),
    retract(secondario(_)),
    assert(secondario(Sec)),
    asserisci_altri(Altri,N),
    asserta(altri(ref_ex(SnY,TestaY,_,PersY,GenY,NumY,CcY,FY/RY),N)),
    !.

recover_sec(altri, Ref1, Altri, N) :-
    scarica_secondario(N),
    assert(secondario(Ref1)),
    asserisci_altri(Altri,N),
    !.

check_human_sec(N,ref_ex(SnY,TestaY,_,PersY,GenY,NumY,CcY,FY/RY),Altri,LA):- 
    (nogen_member(role,CcY);nogen_member(sociale,CcY);nogen_member(umano, CcY);nogen_member(hum,CcY);
     nogen_member(hum_set,CcY);nogen_member(soc,CcY)),
    !,
    assert(secondario(ref_ex(SnY,TestaY,_,PersY,GenY,NumY,CcY,FY/RY))),
    asserisci_altri(LA,N).

check_human_sec(N,_,Altri,LA):- 
    assert(secondario(nil)),
    asserisci_altri(Altri,N),
    !.
/*  -sc  r_prin, r_altri, a_prin, a_sec, State=continua
33 ci sono due pronomi individuati dal sc, il best candidate e' il principale e il primo degli altri diviene secondario */
create_disc_grid(N, N1, SnY-TestaY-sc, SnX-TestaX-sc, Altri, r_prin, r_sec, a_prin, a_sec, continua) :-
       secondario(ref_ex(_,TestaY,TabA,PersA,GenA,NumA,CatA,_)),
       principale(ref_ex(_,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)),
       retract(proposto(_)),
       retract(principale(_)),
       assert(proposto(nil)),
       assert(stato(N,continua)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(altri, ref_ex(_,TestaY,TabA,PersA,GenA,NumA,CatA,_),Altri, N),!.     

create_disc_grid(N, N1, SnY-TestaY-sc, SnX-TestaX-sc, Altri, r_prin, r_altri, a_prin, a_sec, continua) :-
       once(altri(ref_ex(_,TestaY,TabA,PersA,GenA,NumA,CatA,_),N1)),
       principale(ref_ex(_,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)),
       retract(proposto(_)),
       retract(principale(_)),
       assert(proposto(nil)),
       assert(stato(N,continua)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(altri, ref_ex(SnY,TestaY,TabA,PersA,GenA,NumA,CatA,_),Altri, N),!.     

/*  -sc  r_sec, r_prin, a_prop, a_sec, State=continua
35 il best candidate e' il secondario che diviene principale e il primo degli altri diviene secondario */
create_disc_grid5(N, SnX-TestaX-sc, Altri, r_sec, r_prop, a_prin, a_sec, 
       continua) 
       :-
       nonvar(TestaX),
       secondario(ref_ex(_,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)),
       retract(principale(_)),
       assert(stato(N,continua)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       retract(proposto(Prop)),
       assert(proposto(nil)),
       recover_sec(altri, Prop, Altri, N),     
       !.

create_disc_grid5(N, SnX-TestaX-sc, Altri, r_prop, r_sec, a_prin, a_sec, 
       continua) 
       :-
       proposto(ref_ex(_,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)),
       retract(principale(_)),
       assert(stato(N,continua)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       retract(proposto(Prop)),
       assert(proposto(nil)),
       recover_sec(altri, Altri, N),     
       !.

create_disc_grid5(N, SnX-TestaX-sc, Altri, r_prop, r_altri, a_prin, a_sec, 
       continua) 
       :-
       proposto(ref_ex(_,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)),
       retract(principale(_)),
       assert(stato(N,continua)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       retract(proposto(Prop)),
       assert(proposto(nil)),
       once(altri(ref_ex(_,TestaY,_,PersA,GenA,NumA,CatA,_),N1)),
       recover_sec(altri, ref_ex(_,TestaY,_,PersA,GenA,NumA,CatA,_), Altri, N),     
       !.

create_disc_grid5(N, SnX-TestaX-sc, Altri, r_prop, r_altri, a_prin, a_sec, 
        continua) :-
       N1 is N - 1,
       once(altri(ref_ex(_,TestaX,TabA,PersA,GenA,NumA,CatA,_),N1)),
       retract(principale(_)),
       assert(principale(ref_ex(_,TestaX,_,PersA,GenA,NumA,CatA,_))),        
       retract(proposto(ref_ex(SnP,PredP,TabP,PersP,GenP,NumP,CatP,_))),
       assert(proposto(nil)),       
       retract(secondario(_)),
       assert(secondario(ref_ex(SnP,PredP,_,PersP,GenP,NumP,CatP,_))),
       asserisci_altri(Altri,N),
       assert(stato(N,continua)),!.

create_disc_grid5(N, Pred, Altri, r_prin, r_sec, a_prin, a_sec, 
       continua) 
       :-
       nonvar(Pred),
       principale(ref_ex(_,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)),
       (TestaX=Pred;on(Pred,TestaX)),
       retract(principale(_)),
       assert(stato(N,continua)),
       assert(principale(ref_ex(SnX,Pred,_,PersX,GenX,NumX,CcX,FX/RX))),
       retract(proposto(Prop)),
       assert(proposto(nil)),
       recover_sec(altri, Prop, Altri, N),     
       !.

/* 37 */
create_disc_grid5(N, Pred, Altri, r_prin, r_altri, a_prin, a_sec, 
       continua) 
       :-
       nonvar(Pred),
       principale(ref_ex(_,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)),
       (TestaX=Pred;on(Pred,TestaX)),
       retract(principale(_)),
       assert(stato(N,continua)),
       assert(principale(ref_ex(SnX,Pred,_,PersX,GenX,NumX,CcX,FX/RX))),
       retract(proposto(Prop)),
       assert(proposto(nil)),
       once(altri(ref_ex(_,TestaY,_,PersA,GenA,NumA,CatA,_),N1)),
       recover_sec(altri, ref_ex(_,TestaY,_,PersA,GenA,NumA,CatA,_), Altri, N),     
       !.

disc_resume(N,ref_ex(SnX,TestaX,[+ref,def0,nil,nil,-pro,-ana,-class],PersX,GenX,sing,CcX,FX/RX),Altri)
   :-
   Altri\=[],
   principale(ref_ex(_,TestaP,_,PersP,GenP,plur,_,_)),
   nogen_member(ref_ex(SnY,TestaY,[+ref,def0,nil,nil,-pro,-ana,-class],PersY,GenY,sing,CatY,FX/RY)/Py, Altri),
   fact(_,name, [TestaY, Id], 1, univ, univ),
   in(_, Id, Idx),
   fact(_,isa,[ind:Idx,class:TestaP],1,Temp, Loc),
   set(_, Idy),
   card(_, Idy, 2),
   in(_, Idy, Idx),
   elimina(ref_ex(SnY,TestaY,_,_,_,_,_,_/_)/_,Altri,L),
   retract(principale(_)),
   assert(principale(ref_ex(SnX,TestaP,_,PersP,GenP,NumP,CatY,FX/RX))),               
   secondario(Sec),
   retract(secondario(_)),
   assert(secondario(Sec)),
   retract(proposto(_)),
   assert(proposto(nil)),
   assertz(risolto(N, SnX, TestaX, TestaP)),     % memorizza risolti 
   assertz(risolto(N, SnY, TestaT, TestaP)),     % memorizza risolti 
   assert(stato(N,continua)),
   asserisci_altri(L,N),
   !.

disc_resume(N,ref_ex(SnX,TestaX-sc,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
      proposto(ref_ex(SnY,Testa2,_,PersS,GenS,NumS,CatS,_/_)),
      search_sc(N, TestaX, Testa2, [], FX),
      create_disc_grid5(N, SnX-TestaX-sc, Altri, r_prop, r_altri, a_prin, a_sec, continua),
        !.

disc_resume(N,ref_ex(SnX,TestaX-sc,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
      principale(ref_ex(SnY,Testa2,_,PersS,GenS,NumS,CatS,_/_)),
      search_sc(N, TestaX, [], [], FX),
      create_disc_grid2(N, TestaX-sc, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), Altri, r_prin, r_prop, a_prin, a_sec, 
        continua),
       !.

disc_resume(N,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
     proposto(ref_ex(SnP,Pred,TabP,PersP,GenP,NumP,_,_)),
     secondario(ref_ex(_,TestaA,TabA,PersA,GenA,NumA,CatA,_)),
     search_dmod(Pred,Id),
     (TestaX=Pred 
        ;
      TestaX\=Pred,  
      search_dmod(TestaX,Id)
      ),
      retract(proposto(_)),
      assert(proposto(nil)),
      retract(secondario(_)),
      principale(X), 
      (X\=nil,
       retract(principale(X)),
       assert(secondario(X))
       ;
       X=nil, retract(principale(X)),
       assert(secondario(ref_ex(_,TestaA,_,PersA,GenA,NumA,CatA,_)))
       ),
      assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),        
      asserisci_altri(Altri,N),
      assert(stato(N,continua)),
        !.

disc_resume(N,ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri)
   :-
      (proposto(ref_ex(_,Pred,TabP,PersP,GenP,NumP,CatP,_)),
       secondario(ref_ex(_,TestaA,TabA,PersA,GenA,NumA,CatA,_)),
       on(ref_ex(_,TestaA,_,PersA,GenA,NumA,_,_)/_, Altri)
       ;
       secondario(ref_ex(_,Pred,TabP,PersP,GenP,NumP,CatP,_)),
       proposto(ref_ex(_,TestaA,TabA,PersA,GenA,NumA,CatA,_))
       ),
       search_dmod(Pred,Id),
       principale(X), 
       (X\=nil,
       retract(principale(ref_ex(SnY,TestaY,_,PersY,GenY,NumY,CcY,FY/RY)))
       ;
        X=nil, retract(principale(X))
       ),
        assert(principale(ref_ex(SnY,Pred,_,PersP,GenP,NumP,CatP,_))),        
        retract(proposto(_)),
       (TestaX=Pred, assert(proposto(nil))
        ;
        assert(proposto(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))
        )),
        retract(secondario(_)),
        assert(secondario(ref_ex(_,TestaA,_,PersA,GenA,NumA,CatA,_))),
        asserisci_altri(Altri,N),
        assert(stato(N,continua)),
        !.

disc_resume(N,Ref1,Altri) :-
   create_disc_grid3(N, Ref1, Altri, r_prop, r_prin, a_prin, a_sec, continua),
   !.

discorso(N,[]) :-
       N1 is N - 1,
       stato(N1,Stato),
   assert(stato(N,Stato)),
   !.

discorso(1,Args) :-
    Args\=[],
   (elimina(
      ref_ex(SnX,Testa,_,Pers,Gen,Num,Cat,F/R)/_, Args, La),F=foc
   ; elimina(
      ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)/_, Args, La),F=sogg_foc,Tab \= [+ref,Def,Part,nil,+pro,-ana,+class]
; elimina(
      ref_ex(SnX,Testa,_,Pers,Gen,Num,Cat,F/R)/_, Args, La),F=sogg_top
   ; elimina(
      ref_ex(SnX,Testa,_,Pers,Gen,Num,Cat,F/R)/_, Args, La),F=topic
   ; elimina(
      ref_ex(SnX,Testa,_,Pers,Gen,Num,Cat,F/R)/_, Args, La),F=fuoco
   ),
   !,
   assert(principale(ref_ex(SnX,Testa,_,Pers,Gen,Num,Cat,F/R))),
   assert(proposto(nil)),
   assert(secondario(nil)),
   asserisci_altri(La,1),
   assert(stato(1,shifting)).

discorso(1,Args) :-
   Args\=[],
   Args=[ref_ex(SnX,Testa,_,Pers,Gen,Num,Cat,F/R)/W,ref_ex(SnX1,Testa1,_,Pers1,Gen1,Num1,Cat1,F1/R1)/W1|ListaAltri],
   !,
   (Testa\=indefinite,
    assert(proposto(ref_ex(SnX,Testa,_,Pers,Gen,Num,Cat,F/R))),
    append([ref_ex(SnX1,Testa1,_,Pers1,Gen1,Num1,Cat1,F1/R1)/W1],ListaAltri,ListaAltri1)
   ;
   Testa1\=indefinite,
   assert(proposto(ref_ex(SnX1,Testa1,_,Pers1,Gen1,Num1,Cat1,F1/R1))),
    append([ref_ex(SnX,Testa,_,Pers,Gen,Num,Cat,F/R)/W],ListaAltri,ListaAltri1)
   ),
   assert(principale(nil)),
   assert(secondario(nil)),
   asserisci_altri(ListaAltri1,1),
   assert(stato(1,cambia)).

/* lo stato e' shifting
    si passa in continua */

discorso(N,Args) :-
    Args\=[],
       N1 is N - 1,
       stato(N1,shifting),
       efface(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)/Px,Args,La),
       principale(ref_ex(_,Testa,_,Pers,Gen,Num,Cat1,_/_)),
        (secondario(ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CcY,FY/RY))
         ;
         altri(ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CcY,FY/RY),N1)
         ),
       (fact(_,name, [TestaY, Id], 1, univ, univ);
       fact(_,isa,[ind:Id,class:TestaY],1,Temp, Loc)),
       retract(proposto(_)),
       assert(proposto(nil)),
       retract(principale(_)),
       assert(principale(ref_ex(SnX,Testa,_,Pers,Gen,Num,Cat,F/R))),
       retract(secondario(_)),
       assert(secondario(ref_ex(SnY,TestaY,_,PersY,GenY,NumY,CcY,FY/RY))),
       assert(stato(N,continua)),
       asserisci_altri(La,N).

discorso(N,Args) :-
    Args\=[],
       N1 is N - 1,
       stato(N1,shifting),
       efface(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)/Px,Args,La),
       principale(ref_ex(_,Testa,_,Pers,Gen,Num,Cat1,_/_)),
        (secondario(ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CcY,FY/RY))
         ;
         altri(ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CcY,FY/RY),N1)
         ),
       TabY = [+ref,def0,nil,nil,-pro,-ana,-class],
       Num=sing,
       fact(_,name, [TestaY, Id], 1, univ, univ),
       in(_, Id, Idx),
       fact(_,isa,[ind:Idx,class:TestaP],1,Temp, Loc),
       elimina(ref_ex(Snp,TestaP,_,_,_,_,_,_/_)/_,La,L),
       retract(proposto(_)),
       assert(proposto(ref_ex(Snp,TestaY,_,PersY,GenY,NumY,CcY,FY/RY))),
       retract(principale(_)),
       assert(principale(nil)),
       retract(secondario(_)),
       assert(secondario(ref_ex(SnX,Testa,_,Pers,Gen,Num,Cat,_/R))),
       assert(stato(N,resume)),
       asserisci_altri(L,N).

discorso(N,Args) :-
    Args\=[],
       N1 is N - 1,
       stato(N1,shifting),
       efface(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)/Px,Args,La),
       principale(ref_ex(_,Testa,_,Pers,Gen,Num,Cat1,_/_)),
       retract(proposto(_)),
       retract(secondario(_)),
       retract(principale(_)),
       assert(principale(ref_ex(SnX,Testa,_,Pers,Gen,Num,Cat,_/R))),
       assert(proposto(nil)),
       assert(secondario(nil)),
       assert(stato(N,continua)),
       asserisci_altri(La,N).

discorso(N,Args) :-
   cont_discorso(N,Args),!.


/* lo stato e' qualsiasi -
   non si puo' passare ne in cambia ne in retaining
   allora si passa in shifting se c'e' in FUOCO o TOPIC
 N.B. al primo passaggio in cambia si asserisce come argomento
      secondario quello principale della frase precedente */

discorso(N,Args) :- 
    Args\=[],
       1<N,
       N1 is N - 1,
       elimina(ref_ex(SnY,Testa,_,Pers,Gen,Num,Cat,Fun/_)/_,Args,La),
       (Fun=fuoco ; Fun=foc ; Fun=sogg_foc ; Fun=sogg_top),
      (principale(ref_ex(SnX,Testa1,_,Pers1,Gen1,Num1,Cat1,_/_)),
       Testa1\=Testa,
       scarica_secondario(N),
       assert(secondario(ref_ex(SnX,Testa1,_,Pers1,Gen1,Num1,Cat1,_/_)))
      ;
       principale(ref_ex(SnX,Testa1,_,Pers1,Gen1,Num1,Cat1,_/_)),
       Testa1=Testa,
       scarica_secondario(N),
       once(altri(Ref1,N1)),       
       assert(secondario(Ref1))
      ;
       principale(nil)),
       retract(principale(_)),
       assert(principale(ref_ex(SnY,Testa,_,Pers,Gen,Num,Cat,_/_))),
       retract(proposto(_)),
       assert(proposto(nil)),
       asserisci_altri(La,N),
       assert(stato(N,shifting)),
       !.
/* il best candidate non matcha con il principale n con il proposto ma esiste nel DM; 1. il secondario ha le stesse cat sem del best candidate allora il proposto o il principale viene messo nel secondario e nel principale viene messo il best candidate; 2. il principale  vuoto e il proposto viene messo nel secondario, mentre il best candidate diventa il proposto; 3.lo stesso di 2*/ 

discorso(N,Args) :- 
    Args\=[],
       1<N,
       N1 is N - 1,
       Args=[ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)/_|Altri],
       fetch_sc(N1, Factive, Change, Rel, VerbCat, DiscDom, Test),
       nonvar(Test),
       Test\=TestaX,
       secondario(ref_ex(SnY,Test,TabY,PersY,GenY,NumY,CcY,FY/RY)),
       retract(secondario(_)),
       assert(secondario(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       retract(principale(_)),
       assert(principale(ref_ex(SnY,Test,_,PersY,GenY,NumY,CcY,FY/RY))),
       retract(proposto(_)),
       assert(proposto(nil)),
       assert(stato(N,continua)),
       asserisci_altri(Altri,N),
       !.

discorso(N,Args) :- 
    Args\=[],
       1<N,
       N1 is N - 1,
   Args=[ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)/_|Altri],
   (proposto(ref_ex(SnP,TestaP,_,Pers,Gen,Num,Cc,F/R)),
    State=retaining;
   principale(ref_ex(SnP,TestaP,_,Pers,Gen,Num,Cc,F/R))),
   TestaP\=TestaX,
   (TabX = [+ref,+def,nil,Card,-pro,-ana,+class],
    (NumX=plur,
     card(_, Id, Card0),
      (in(_,Idx,Id),
       fact(_,isa,[ind:Idx,class:TestaX],1,Te,Lo)
       ;
       set(_, Id),
      fact(_,isa,[ind:Id,class:TestaX],1,Te,Lo)),
    State=resume
    ;
    NumX=sing),
    fact(_,isa,[ind:Idx,class:TestaX],1,Te,Lo),
    State=resume
    ;
    TabX = [+ ref, def0, nil, nil, - pro, - ana, - class],
    fact(_,name,[TestaX, Idx],1,Te,Lo),
    State=resume
    ;
    TabX = [+ ref, def0, nil, nil, - pro, - ana, - class]
   ),
   (
   secondario(ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CcY,FY/RY)),
   controlla_cat1(CcY,CcX),
   retract(secondario(_)),
   assert(secondario(ref_ex(SnP,TestaP,_,Pers,Gen,Num,Cc,_/_))),
   retract(principale(_)),
   (nonvar(State);var(State), State=shifting),
    assert(stato(N,State)),
   assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
   retract(proposto(_)),
   assert(proposto(nil))
   ;
   principale(P), P\=nil,
   retract(secondario(_)),
   assert(secondario(ref_ex(SnP,TestaP,_,Pers,Gen,Num,Cc,F/R))),               
   retract(principale(_)),
   assert(principale(P)),
   (nonvar(State);var(State), State=retaining),
    assert(stato(N,State)),
   retract(proposto(_)),
   assert(proposto(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)))
   ;
   retract(secondario(_)),
   assert(secondario(ref_ex(SnP,TestaP,_,Pers,Gen,Num,Cc,F/R))),               
   retract(principale(_)),
   assert(principale(nil)),   
   (nonvar(State);var(State), State=retaining),
   assert(stato(N,State)),
   retract(proposto(_)),
   assert(proposto(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)))
   ),
   asserisci_altri(Altri,N),
   !.


discorso(N,[Ref1/_|Altri]) :- 
   create_disc_grid3(N,Ref1, 
       Altri, r_prin, r_altri, a_prin, a_sec, continua),
   !.

discorso(N,[Ref1/_|Altri]) :- 
   create_disc_grid3(N,Ref1, 
       Altri, r_prin, r_altri, a_prin, a_sec, cambia),
   !.

discorso(N,[Ref1/_|Altri]) :- 
   create_disc_grid3(N,Ref1, 
       Altri, r_prop, r_altri, a_prop, _, retaining),
   !.

discorso(N,Args) :-
    Args\=[],
   elimina(
      ref_ex(SnX,Testa,_,Pers,Gen,Num,Cat,F/R)/_, Args, La),
   (F=sogg;F=ogg;F=ogg2;F=obl;F=obl1;F=obl2),
   deafult_hierarchy(N,F,Testa,Stato),
   asseriscigerachia(N, ref_ex(SnX,Testa,_,Pers,Gen,Num,Cat,F/R), La, Stato),!.

discorso(N,Args) :-
    asserta(altri(Args, N)),
    assert(principale(nil)),
    assert(secondario(nil)),
    assert(proposto(nil)),
    assert(stato(N,cambia)),
    !.

deafult_hierarchy(N,F,Testa,Stato):-
   principale(P), P\=nil,
   P=.. [ref_ex,Ind,Test|_],
   (Test=Testa, Stato=continua;
    Stato=cambia),
   !.
deafult_hierarchy(N,F,Testa,Stato):-
   proposto(P), P\=nil,
   P=.. [ref_ex,Ind,Test|_],
   (Test=Testa, Stato=cambia;
    Stato=retaining),
   !.
deafult_hierarchy(N,F,Testa,Stato):-
   secondario(P), P\=nil,
   P=.. [ref_ex,Ind,Test|_],
   (Test=Testa, Stato=resume;
    Stato=continua),
   !.
deafult_hierarchy(N,F,Testa,Stato):-
   N1 is N - 1,
   altri(Ref,N1),
   Ref=ref_ex(_,TestaA,TabA,PersA,GenA,NumA,_,_),
   (TestA=Testa, Stato=shifting;
    Stato=retaining),
   !.

deafult_hierarchy(N,F,Testa,retaining):-!.

asseriscigerachia(N, R, La, Stato):-
   (retract(proposto(_));true),
   assert(proposto(R)),
   (retract(principale(_));true),
   assert(principale(nil)),
   (recover_sec(nil, La, N)
    ;
    recover_sec_fail(nil, La, N)),  
    assert(stato(N,Stato)),
   !.

recover_sec_fail(nil, Altri, N) :-     
    Altri=[ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CcY,FY/RY)/Py|LA],
    assert(secondario(ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CcY,FY/RY))),
    asserisci_altri(LA,N),
    !.
recover_sec_fail(nil, [], N) :-     
     asserta(altri([],N)),
     assert(secondario(nil)),
    !.

scarica_secondario(_) :- retract(secondario(nil)).

scarica_secondario(N) :- retract(secondario(X)),
                        ( arg(2, X, Head),
                          Head=indefinite
                         ;
                          asserta(altri(X,N))
                         ).

% scarica_proposto(_) :- retract(proposto(nil)).
scarica_proposto(N) :- retract(proposto(X)),
                         asserta(altri(X,N)).

asserisci_altri([],_) :- !.
asserisci_altri([Primo/_|Coda],Frase) :-
                     asserisci_altri(Coda,Frase),
                     asserta(altri(Primo,Frase)).

lista_altri(N) :-
   altri(X,N),
   write(X),
   nl,fail.
lista_altri(_).

lista_altri(N, Altri) :-
   findall(X, altri(X,N), Altri),!.

writeiffalt([], Type):-!.

writeiffalt(X, Type):-
   X\=nil,
   write(Type),
   writeseq(X),
   nl,!.

writeiff(nil, Type):-!.

writeiff(X, Type):-
   X\=nil,
   write(Type),
   write(X),
   nl,!.

stampa_stato(Win, N) :-
   active_output_win(Win),
   tell(Win),
   wfront(Win),
   proposto(X),
   writeiff(X, 'EXPECTED TOPIC : '),
   principale(Y),
   writeiff(Y, 'MAIN TOPIC : '),
   secondario(Z),
   writeiff(Z, 'SECONDARY TOPIC : '),
   lista_altri(N, Altri),
   writeiffalt(Altri, 'POTENTIAL TOPICS : '),
   stato(N,Stato),
   write(stato(N,Stato)),nl,
   ! .
stampa_stato(_, _).

/*
create_disc_grid = con dieci argomenti
    create_disc_grid(N, N1, SnY-TestaY-sc, SnX-TestaX-sc, LA, r_prin, r_sec, a_prin, a_sec, continua)
create_disc_grid2 = con nove argomenti
    create_disc_grid2(N, SnY-TestaY-sc, TestaX, LA, r_prin, r_prop, a_prin, a_sec, continua)
    ;
    create_disc_grid2(N, TestaY-sc, TestaX, LA, r_prin, r_prop, a_prin, a_sec, continua)
    ;
    create_disc_grid2(N, pron, TestaX, Altri, r_prin, r_prop, a_prin, a_sec, continua)
create_disc_grid3 = con otto argomenti
    create_disc_grid3(N, TestaX, Altri, r_prin, r_altri, a_prin, a_sec, continua)
create_disc_grid4 = con cinque argomenti
   create_disc_grid4(N, Ref1, Altri, sociale, continua),
*/

create_disc_grid3(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri, 
       r_prin, r_prop, a_prin, a_sec, continua):-
       principale(ref_ex(_,TestaX,TabA,PersA,GenA,NumA,_,_)),
       (TestaX\=indefinite,
       create_disc_gridp(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), Altri)
        ;
        TestaX=indefinite,
       create_disc_gridp_ind(N, ref_ex(SnX,indefinite,TabX,PersX,GenX,NumX,CcX,FX/RX), Altri)),
       !.

create_disc_grid3(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), Altri, 
       r_prop, r_altri, a_prin, a_sec, St):-
       proposto(ref_ex(_,TestaP,TabP,PersP,GenP,NumP,Cat,F/R)),
       create_disc_gridal(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
            ref_ex(_,TestaP,_,PersP,GenP,NumP,Cat,F/R), Altri, Cat, St),
       !.
       
/* r_prop, r_altri, a_prop, a_sec, State=retaining
9  esiste un proposto e una lista altri: il primo best candidate non mAtcha e viene messo nel proposto, mentre il secondo best candidate matcha con il proposto o il primo degli altri e viene messo nel secondario ed e' indefinito */

create_disc_grid3(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
                     Altri,r_prop, r_altri, a_prop, a_sec, St):-
       proposto(ref_ex(SnA,TestaA,TabA,PersA,GenA,NumA,CatA,_)),
       Altri\=[],
       Altri=[ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CcY,FY/RY)/Py|LA],
       N1 is N - 1,
       create_disc_gridalt(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
           ref_ex(SnA,TestaA,TabA,PersA,GenA,NumA,CatA,_), 
           ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CcY,FY/RY), LA, TestaA, TestaY, N1, St),
       !.       

/* r_prop, r_altri, a_prin, a_sec, State=continua
13  esiste un proposto che matcha con il best candidate e viene messo nel principale e un secondario che viene riasserito */
create_disc_grid3(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       Altri, r_prop, r_sec, a_prin, a_sec, continua) 
       :- 
       proposto(ref_ex(_,TestaX,TabP,PersP,GenP,NumP,_,_)),
       secondario(ref_ex(SnS,TestaS,TabS,PersS,GenS,NumS,CatS,_)),
       retract(proposto(_)),
       retract(principale(_)),
       assert(proposto(nil)),
       (on(+pro, TabX),State=continua;
        noton(+pro, TabX), State=cambia),
       assert(stato(N,State)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(altri, ref_ex(_,TestaS,_,PersS,GenS,NumS,CatS,_), Altri, N),!.     


/*  r_altri, r_prop, a_prop, a_sec, State=retaining
16  esiste un proposto e il primo della lista altri che matcha con il best candidate e viene messo nel proposto; poi anche il principale esiste nella lista Altri */
create_disc_grid3(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       Altri, r_altri, r_prop, a_prop, a_sec, St) 
       :- 
       N1 is N - 1,
       once(altri(ref_ex(_,TestaA,TabA,PersA,GenA,NumA,_,_),N1)),
       principale(Prin),
       Prin\=nil,
       principale(ref_ex(_,Testa1,_,Pers1,Gen1,Num1,Cat1,_/_)),
       create_disc_gridaltp(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       Altri, Prin, Testa1, TestaA, St),
       !.

 /*  r_prin, r_altri, a_prin, a_sec, State=cont_analyze
21  esiste un principale che matcha con il best candidate
il principale matcha il best candidate che e' un nom_subst */

create_disc_grid3(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       Altri, r_prin, r_altri, a_prin, a_sec, St) 
       :- 
       principale(Prin),
       Prin\=nil,
       principale(ref_ex(_,Testa1,TabP,PersP,GenP,NumP,_,_)),
       (on(Testa1, TestaX); Testa1=TestaX),
       create_disc_gridaltpa(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       Altri, Prin, Testa1, St),
       !.

/*  r_sec, r_prin, a_prop, a_sec, State=continua
24  il best candidate matcha con il secondario che viene messo nel proposto, 
il principale viene mantenuto nel principale */
create_disc_grid3(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       Altri, r_sec, r_prin, a_prop, a_sec, continua) 
       :-
       secondario(ref_ex(_,TestaX,TabP,PersP,GenP,NumP,_,_)),
       principale(ref_ex(SnA,TestaA,TabA,PersA,GenA,NumA,CatA,_)),
       (TabX = [+ ref, Def, Par, Car, - pro, - ana, - class];
       TabX = [+ ref, Def, Par, Car, - pro, - ana, + class]),
       retract(proposto(_)),
       retract(principale(_)),
       assert(stato(N,retaining)),
       assert(proposto(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       assert(principale(ref_ex(SnA,TestaA,_,PersA,GenA,NumA,CatA,_))),
       recover_sec(altri, Altri, N),!.     

/* r_sec, r_prin, a_prop, a_sec, State=continua
25  non esiste principale */
create_disc_grid3(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       Altri, r_sec, r_prin, a_prop, a_sec, continua) 
       :-
       secondario(ref_ex(_,TestaX,TabP,PersP,GenP,NumP,_,_)),
       principale(nil),
       retract(principale(_)),
       recover_sec(prop, Altri, N),
       assert(stato(N,retaining)),
       assert(proposto(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       assert(principale(nil)),
       !.     

/*  r_prop, r_prin, a_prin, a_sec, State=retaining
4  esiste un proposto e un principale: il proposto matcha con il best candidate e viene messo nel principale,mentre il principale viene messo nel secondario 
*/

create_disc_grid3(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Altri, 
       r_prop, r_prin, a_prin, a_sec, St):-
       proposto(ref_ex(SnA,TestaX,TabA,PersA,GenA,NumA,CatA,_)),
       create_disc_gridpr(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
                ref_ex(SnA,TestaX,TabA,PersA,GenA,NumA,CatA,_), Altri, St),
       !.       

/* r_prin, r_prop, a_prin, a_sec, continua
1  esiste un principale e un proposto: il principale matcha con il best candidate e viene messo nel principale, mentre il proposto viene messo nel secondario 
*/
create_disc_gridp(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), Altri) 
       :-
       proposto(ref_ex(SnP,TestaP,TabP,PersP,GenP,NumP,CatP,_)),
       retract(proposto(_)),
       retract(principale(_)),
       assert(proposto(nil)),
       assert(stato(N,continua)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(altri, ref_ex(_,TestaP,_,PersP,GenP,NumP,CatP,_),Altri, N),!.     


create_disc_gridp_ind(N, ref_ex(SnX,indefinite,TabX,PersX,GenX,NumX,CcX,FX/RX), Altri)
       :-
       principale(Prin),
       proposto(Pro),
       Prin\=nil, Pro\=nil,
       retract(proposto(Pro)),
       retract(principale(Prin)),
       assert(stato(N,retaining)),
       assert(proposto(Pro)),
       assert(principale(Prin)),
       recover_sec(altri, ref_ex(SnX,indefinite,_,PersX,GenX,NumX,CcX,FX/RX), Altri, N),!.     

/* si filtra il caso di un best candidate definito e sociale */
create_disc_gridpr(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), Pro, Altri, St) 
       :-
       TabX=[+ref,Def,nil,nil,-pro,-ana,+class], Def= +def,
       (nogen_member(sociale, CcX);
       nogen_member(social, CcX)),
       principale(Prin),
       Prin\=nil,
       retract(proposto(_)),
       retract(principale(_)),
       assert(proposto(nil)),
       retract(secondario(Sec)),
       assert(secondario(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       assert(stato(N,continua)),
       assert(principale(Prin)),
       asserisci_altri(Altri,N),!.     

create_disc_gridpr(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), Pro, Altri, retaining) 
       :-
       principale(ref_ex(SnA,TestaA,TabA,PersA,GenA,NumA,CatA,_)),
       retract(proposto(_)),
       retract(principale(_)),
       assert(proposto(nil)),
       (on(+pro, TabX),State=continua;
        noton(+pro, TabX), State=cambia),
       assert(stato(N,State)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(altri, ref_ex(_,TestaA,_,PersA,GenA,NumA,CatA,_),Altri, N),!.     

create_disc_gridpr(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), Pro, Altri, continua) 
       :-
       principale(ref_ex(SnA,TestaA,TabA,PersA,GenA,NumA,CatA,_)),
       retract(proposto(_)),
       retract(principale(_)),
       assert(proposto(nil)),
       (on(+pro, TabX),State=continua;
        noton(+pro, TabX), State=cambia),
       assert(stato(N,State)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(altri, ref_ex(_,TestaA,_,PersA,GenA,NumA,CatA,_),Altri, N),!.     

/* r_prop, r_prin, a_prin, a_sec, State=cont_analyze
7  esiste un proposto: il proposto matcha con il best candidate che e' un nom_subst e viene messo nel principale: il principale viene messo nel secondario */
create_disc_gridpr(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), Pro, Altri, cont_analyze) 
       :-
       TabX = [+ref,Def,Part,nil,+pro,-ana,+class],
       Part\=nil,nonvar(Def),
       principale(Prin), Prin\=nil,
       retract(proposto(_)),
       retract(principale(ref_ex(SnY,Testa2,_,PersS,GenS,NumS,CatS,_/_))),
       assert(proposto(nil)),
       assert(stato(N,cont_analyze)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(altri, ref_ex(_,Testa2,_,PersS,GenS,NumS,CatS,_/_), Altri, N),!.     

/* r_prop, r_prin, a_prin, a_sec, State=cont_analyze
 8  non esiste principale */
create_disc_gridpr(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),  
       ref_ex(_,TestaX,TabP,PersP,GenP,NumP,_,_), Altri, cont_analyze) 
       :-
       TabX = [+ref,Def,Part,nil,+pro,-ana,+class],
       Part\=nil,nonvar(Def),
       retract(principale(nil)),
       retract(proposto(_)),
       assert(proposto(nil)),
       assert(stato(N,cont_analyze)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(nil, Altri, N),!.     

create_disc_gridal(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       ref_ex(_,TestaX,TabP,PersP,GenP,NumP,_,_), Altri, continua)
       :- 
       principale(Prin),
       Prin\=nil,
       retract(principale(ref_ex(SnS,TestaS,TabS,PersS,GenS,NumS,CatS,_))),
       retract(proposto(_)),
       assert(proposto(nil)),
       (on(+pro, TabX),State=continua;
        noton(+pro, TabX), State=cambia),
       assert(stato(N,State)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(altri, ref_ex(_,TestaS,_,PersS,GenS,NumS,CatS,_),Altri, N),!.     

/*  r_prop, r_altri, a_prop, State=retaining
8 escape condition, no coherence, new individual introduced */
create_disc_gridal(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), Pro, Altri, Cat, continua)
       :-
       TabX = [+ref,Def,nil,nil,-pro,-ana,+class],
       Def= -def,
       on(umano, Cat),
       retract(principale(_)),
       assert(principale(Pro)),
       recover_sec(prop, Altri, N),
       (on(umano,CcX),
       assert(stato(N,cambia)),
       assert(proposto(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)))
        ;
       assert(proposto(nil)),
       assert(stato(N,continua)),
       asserisci_altri([ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)/_],N)),
       !.     

/* r_prop, r_altri, a_prin, a_sec, State=retaining/continua
10  non e' indefinito - il proposto  nella lista altri */
create_disc_gridal(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), Pro, Altri, Cat, Continua)
       :- 
       TabX=[+ref, def0, nil, nil, -pro, -ana, -class],
       Altri\=[],
       (nogen_member(sociale, Cat);
        nogen_member(social, Cat);
        nogen_member(luogo,Cat)),
       retract(principale(_)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       retract(proposto(ref_ex(_,TestaP,TabP,PersP,GenP,NumP,CatP,_))),
       assert(stato(N,retaining)),
       assert(proposto(nil)),
       recover_sec(altri, ref_ex(_,TestaP,TabP,PersP,GenP,NumP,CatP,_),Altri, N),!.     


create_disc_gridal(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), Pro, Altri, Cat,
       continua)
       :- 
       Altri\=[],
       Altri=[ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CcY,FY/RY)/Py|LA],
       nonvar(Pro),
       Pro=.. [ref_ex,Id,TestaP|_],
       TestaP = TestaY,
       retract(principale(nil)),
       assert(principale(Pro)),
       retract(proposto(_)),
       (on(+pro, TabP),State=continua;
        noton(+pro, TabP), State=cambia),
       assert(stato(N,State)),
       assert(proposto(nil)),
       recover_sec(altri, ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX),LA, N),!.     

/* r_prop, r_altri, a_prin, a_sec, State=continua
14  non c'e' un secondario */
create_disc_gridal(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       Pro, Altri, Cat, continua)
       :- 
       principale(Prin),
       Prin\=nil,
       nonvar(Pro),
       Pro=.. [ref_ex,Id,TestaP|_],
       TestaP = TestaX,
       retract(principale(ref_ex(SnS,TestaS,TabS,PersS,GenS,NumS,CatS,_))),
       retract(proposto(_)),
       assert(proposto(nil)),
       (on(+pro, TabX),State=continua;
        noton(+pro, TabX), State=cambia),
       assert(stato(N,State)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(altri, ref_ex(_,TestaS,_,PersS,GenS,NumS,CatS,_),Altri, N),!.     

create_disc_gridal(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       Pro, Altri, Cat, continua)
       :- 
       principale(nil),
       nonvar(Pro),
       Pro=.. [ref_ex,Id,TestaP|_],
       TestaP = TestaX,
       retract(principale(_)),
       retract(proposto(_)),
       assert(proposto(nil)),
       (on(+pro, TabX),State=continua;
        noton(+pro, TabX), State=cambia),
       assert(stato(N,State)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(altri, Altri, N),!.     

create_disc_gridalt(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), Pro,
                     Altri, LA, TestaP, TestaY, N1, retaining) 
       :- 
       TabX\=[], is_list(TabX),
       nogen_member( '-def', TabX),
       TestaX\=TestaP,
       once(altri(ref_ex(_,TestaA,TabA,PersA,GenA,NumA,_,_),N1)),
       (TestaP = TestaY; TestaA = TestaY) ,
       retract(principale(nil)),
       assert(principale(nil)),
       assert(stato(N,retaining)),
       retract(proposto(_)),
       assert(proposto(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(altri, Altri,LA, N),!.     

/* r_prop, r_altri, a_prop, a_sec, State=retaining
10  non e' indefinito - il proposto  nella lista altri */
create_disc_gridalt(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), Pro,
                     Altri, LA, TestaP, TestaP, N1, retaining) 
       :- 
       retract(principale(nil)),
       assert(principale(nil)),
       retract(proposto(_)),
       assert(stato(N,retaining)),
       assert(proposto(Altri)),
       recover_sec(altri, ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX),LA, N),!.     

/* r_prop, r_altri, a_prop, a_sec, State=continua
11 il best candidate  ricavato dal sc e non matcha nessuno dei precedenti 
topics */
create_disc_gridalt(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Pro,
                     Altri, LA, TestaP, TestaP, N1, continua) 
       :- 
       once(altri(ref_ex(SnA,TestaA,TabA,PersA,GenA,NumA,CatA,_),N1)),
       (TestaP \= TestaX, TestaA \= TestaX),       
       retract(proposto(_)),
       retract(principale(_)),
       assert(proposto(Pro)),
       assert(stato(N,retaining)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(altri, ref_ex(_,TestaA,TabA,PersA,GenA,NumA,CatA,_),LA, N),!.     

/*  r_prop, r_altri, a_prin, a_sec, State=Retaining
12 il proposto matcha con il best candidate, poi esiste un secondario e il principale e' uguale a nil; il secondo candidate esiste nel primo degli altri e viene messo in proposto, il proposto precedente viene messo in principale e il secondario resta li'*/

create_disc_gridalt(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),Pro,
                     Altri, LA, TestaX, TestaY, N1, Retaining)
       :-
       TabX\=[], is_list(TabX),
       nogen_member(+def,TabX),
       secondario(ref_ex(SnS,TestaS,TabS,PersS,GenS,NumS,CatS,_)),
       principale(nil),
       once(altri(ref_ex(_,TestaA,TabA,PersA,GenA,NumA,CatA,_),N1)),
       TestaA=TestaY,
       retract(proposto(_)),
       retract(principale(_)),
       assert(proposto(Altri)),
       assert(stato(N,retaining)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(altri, ref_ex(_,TestaS,_,PersS,GenS,NumS,CatS,_), LA, N),!.     

/* ???   r_prop, r_altri, a_prop, State=retaining
15 escape condition, no coherence, new individual introduced */
create_disc_gridalt(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), Pro,
                     Altri, LA, TestaX, TestaY, N1, retaining)
       :-
       TabX\=[], is_list(TabX),
       nogen_member( '-def',TabX),
       once(altri(ref_ex(_,TestaA,TabA,PersA,GenA,NumA,_,_),N1)),
       retract(principale(_)),
       assert(principale(nil)),
       assert(stato(N,retaining)),
       recover_sec(prop, Altri, N),
       assert(proposto(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       !.     

create_disc_gridaltp(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       Altri, Prin, Testa1, TestaA, retaining)
       :- 
       Altri\=[], 
       Testa1\=TestaX,
       Altri=[ref_ex(SnY,Testa1,TabY,PersY,GenY,NumY,CcY,FY/RY)/Py|LA],
       retract(principale(_)),
       assert(principale(ref_ex(SnY,Testa1,_,PersY,GenY,NumY,CcY,FY/RY))),
       assert(stato(N,retaining)),
       retract(proposto(_)),
       assert(proposto(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(nil, LA, N),!.     

/* r_altri, r_prop, a_prop, a_sec, State=retaining
17  esiste nella lista altri il match con il best candidate e viene messo nel proposto il proposto viene messo nei potential- nemmeno il secondario matcha con il best candidate*/
create_disc_gridaltp(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       Altri, Prin, Testa1, TestaA, retaining)
       :- 
       TestaX\=Testa1,
       secondario(ref_ex(_,TestaP,_,Pers,Gen,Num,Cat,_/_)),
       TestaP\=TestaX,
       assert(stato(N,retaining)),
       retract(principale(_)),
       assert(principale(nil)),
       recover_sec(prop, Altri, N),
       assert(proposto(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       !.     

/* r_altri, r_prop, a_prop, a_sec, State=retaining
18  il best candidate non matcha con il principale e viene messo nel proposto mentre il principale attuale e' membro della lista degli altri */
create_disc_gridaltp(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       Altri, Prin, Testa1, TestaA, continua)
       :- 
       Altri\=[],
       on(Ref/_, Altri),
       Testa1\=TestaX,
       Ref=ref_ex(_,Testa,_,Pers,Gen,Num,Cat,_/_), 
       Testa\=Testa1,
       \+ nogen_member(oggetto,CcX),
       retract(principale(_)),
       assert(principale(nil)),
       retract(proposto(_)),
       assert(stato(N,retaining)),
       assert(proposto(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(altri, Prin, Altri, N),
       !.     

/* r_altri, r_prop, a_prop, a_sec, State=continua
20 il best candidate  indefinite, e il principale  nella lista altri; il best candidate diventa il primo dei potential, il principale viene riasserito e il secondo della lista altri diventa il proposto */
create_disc_gridaltp(N, ref_ex(SnX,indefinite,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       Altri, Prin, Testa1, TestaA, continua)
       :-
      Altri\=[],
      Altri=[ref_ex(SnY,Testa1,TabY,PersY,GenY,NumY,CcY,_/_)/Py|LA],
      retract(principale(_)),
      assert(principale(Prin)),               
      retract(proposto(_)),
      assert(stato(N,continua)),
      assert(proposto(nil)),
      recover_sec(altri, LA, N),!.     

create_disc_gridaltpa(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),  
              Altri, Prin, Testa1, cont_analyze) 
       :-
       TabX=[+ref,Def,Part,nil,+pro,-ana,+class],
       Part\=nil,nonvar(Def),
       retract(proposto(_)),
       retract(principale(_)),
       assert(proposto(nil)),
       assert(stato(N,cont_analyze)),
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(nil, Altri, N),!.     

create_disc_gridaltpa(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX),  
              Altri, Prin, Testa1, continua) 
       :-
       TabX=[+ref,Def,Part,nil,+pro,+ana,+me],
       nonvar(Def),
       retract(proposto(_)),
       retract(principale(_)),
       Prin=ref_ex(_,Testa1,TabP,PersP,GenP,NumP,_,_),
       assert(proposto(nil)),
       assert(stato(N,continua)),
       (on(Testa1, TestaX),
        assert(principale(Prin))
       ; 
       Testa1=TestaX,
       assert(principale(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)))
       ),
       recover_sec(nil, Altri, N),!.     

/* r_prin, r_altri, a_prin, a_sec, State=cambia
23  il principale viene messo nel secondario e il best candidate nel proposto 
*/
create_disc_gridaltpa(N, ref_ex(SnX,TestaX,TabX,PersX,GenX,NumX,CcX,FX/RX), 
       Altri, Prin, Testa1, cambia) 
       :- 
       TestaX\=_-sc,
       Testa1\=TestaX,
       secondario(ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,_,_)),
       TestaY\=TestaX,       
       retract(proposto(_)),
       retract(principale(_)),
       assert(principale(nil)),
       assert(stato(N,cambia)),
       assert(proposto(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
       recover_sec(altri, Prin, Altri, N),
       !.     

verif_cats(Cats, N, T):-
        nonvar(Cats),
        nogen_member(role,Cats),
        !.
verif_cats(Cats, N, T):-
        notmembro(role,Cats),
        asserta(po_view(N,T)),
        !.

verify_prin_prop(Cats,N,Prop,Testa1):-
        principale(Prin),               
        (Prin\=nil,
         arg(2, Prin, Testa),
         verif_cats(Cats, N, Testa),
         retract(principale(_)),
         assert(principale(Prin)),
         retract(secondario(_)),
         assert(secondario(Prop))
        ;
         verif_cats(Cats, N, Testa1),
         retract(principale(_)),
         assert(principale(Prop))),
         retract(secondario(_)),
         assert(secondario(nil)),
         !.

/*   sociale
26 membership determines the discourse choice */
create_disc_grid4(N, ref_ex(SnX,TestaX,[+ref,Def,Part,Card,-pro,-ana,+class],PersX,GenX,NumX,CcX,FX/RX), Altri, Feat, continua) 
        :-
       (Feat=sociale;Feat=social),
        Def= +def,
        proposto(Prop),
        arg(2, Prop, Testa1),
        TestaX\=Testa1,
        current_main_loc(N1, luogo, LocInfo),
        arg(2, LocInfo, Pred),
        included(TestaX,Pred),   
        assert(stato(N,continua)),
        retract(proposto(_)),
        assert(proposto(nil)),
        verify_prin_prop(CcX,N,Prop,Testa1), 
        asserisci_altri([ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)/_],N),
        !.

/* features
27 si controllano le features del nome comune con la feature passata in alto 
*/
create_disc_grid4(N, ref_ex(SnX,TestaX,[+ref,Def,Part,Card,-pro,-ana,+class],PersX,GenX,NumX,CcX,FX/RX), Altri,Feat, continua) 
       :-
       (Feat=sostanza;Feat=substance),
       (Def= +def; Def=def0),
       proposto(Prop), Prop\=nil,
       secondario(ref_ex(_,TestaS,TabP,PersP,GenP,NumP,_,_)),
       principale(nil),
       retract(proposto(ref_ex(SnA,TestaA,TabA,PersA,GenA,NumA,CatA,_))),
       (nogen_member(sociale,CatA);
       nogen_member(social,CatA)),
       asserta(po_view(N,TestaS)),
       assert(stato(N,continua)),
       retract(principale(nil)),
       retract(secondario(_)),
       assert(secondario(nil)),
       assert(proposto(nil)),
       assert(principale(ref_ex(_,TestaS,_,PersP,GenP,NumP,_,_))),
       asserisci_altri([ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)/_],N),
       !.

create_disc_grid4(N, ref_ex(SnX,TestaX,[+ref,Def,Part,Card,-pro,-ana,+class],PersX,GenX,NumX,CcX,FX/RX), Altri,Feat, continua) 
       :-
       (Feat=sostanza;Feat=substance),
       (Def= +def; Def=def0),
       proposto(Prop),
       principale(Prin),
       Prop\=nil,
       Prin\=nil,
       retract(proposto(Prop)),
       retract(principale(ref_ex(SnA,TestaA,TabA,PersA,GenA,NumA,CatA,_))),
       assert(stato(N,continua)),
       asserta(po_view(N,TestaA)),
       assert(proposto(nil)),
       assert(principale(ref_ex(SnA,TestaA,_,PersA,GenA,NumA,CatA,_))),
       asserisci_altri([ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)/_],N),
       recover_sec(altri, Prop, Altri, N),!.

/* features
29 si controllano le features del nome comune con la feature passata in alto 
*/
create_disc_grid4(N, ref_ex(SnX,TestaX,[+ref,Def,Part,Card,-pro,-ana,+class],PersX,GenX,NumX,CcX,FX/RX), Altri,Feature, continua) 
       :-
       (Def= +def; Def=def0),
       principale(ref_ex(SnA,TestaA,TabA,PersA,GenA,NumA,CatA,_)),
       nogen_member(Feature,CcX),
       (
       ((Feat=sostanza;Feat=substance),
         nogen_member(Feat,CcX),
        verif_cats(CcX, N, TestaA),
        asserta(altri(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX), N)),
        recover_sec(nil, Altri, N),
        retract(proposto(Prop)),
        retract(principale(_)),
        assert(stato(N,continua)),
        assert(proposto(nil)),
        assert(principale(ref_ex(SnA,TestaA,_,PersA,GenA,NumA,CatA,_)))
        ;
        (Feat=sostanza;Feat=substance),
         nogen_member(Feat,CcX),
        secondario(ref_ex(_,TestaS,TabP,PersP,GenP,NumP,_,_)),
        TestaS=TestaA,
        asserta(altri(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX), N)),
        recover_sec(nil, Altri, N),
        retract(proposto(Prop)),
        retract(principale(_)),
        assert(stato(N,continua)),
        assert(proposto(nil)),
        assert(principale(ref_ex(SnA,TestaA,_,PersA,GenA,NumA,CatA,_)))
        ;
        proposto(Prop),
        arg(2, Prop, Testa),
        Testa=TestaX,
        verif_cats(CcX, N, TestaA),
        retract(secondario(_)),
        assert(secondario(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
        asserisci_altri(Altri,N),
        retract(proposto(Prop)),
        retract(principale(_)),
        assert(stato(N,continua)),
        assert(proposto(nil)),
        assert(principale(ref_ex(SnA,TestaA,_,PersA,GenA,NumA,CatA,_))))
         ;     
        verif_cats(CcX, N, TestaA),
        retract(secondario(_)),
        retract(proposto(Prop)),
        retract(principale(_)),
        assert(proposto(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
        assert(stato(N,retaining)),
        assert(principale(nil)),
        assert(secondario(ref_ex(SnA,TestaA,_,PersA,GenA,NumA,CatA,_))),
        asserisci_altri(Altri,N)
       ),
       !.     
     
create_disc_grid4(N, ref_ex(SnX,TestaX,[+ref,Def,Part,Card,-pro,-ana,+class],PersX,GenX,plur,CcX,FX/RX), Altri,Feature, continua) 
       :-
       (Def= +def; Def=def0),
       proposto(ref_ex(SnA,TestaA,TabA,PersA,GenA,NumA,CatA,_)),
       nogen_member(Feature,CcX),
       retract(proposto(_)),
       retract(principale(_)),
       verif_cats(CcX, N, TestaA),
        assert(proposto(ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX))),
        assert(stato(N,retaining)),
       assert(principale(ref_ex(SnA,TestaA,_,PersA,GenA,NumA,CatA,_))),
       recover_sec(nil, Altri, N),!.

create_disc_grid4(N, ref_ex(SnX,TestaX,[+ref,Def,Part,Card,-pro,-ana,+class],PersX,GenX,NumX,CcX,FX/RX), Altri,Feature, continua) 
       :-
       (Def= +def; Def=def0),
       proposto(ref_ex(SnA,TestaA,TabA,PersA,GenA,NumA,CatA,_)),
       nogen_member(Feature,CcX),
       retract(proposto(_)),
       retract(principale(_)),
       assert(stato(N,continua)),
       verif_cats(CcX, N, TestaA),
       assert(proposto(nil)),
       asserisci_altri([ref_ex(SnX,TestaX,_,PersX,GenX,NumX,CcX,FX/RX)/_],N),
       assert(principale(ref_ex(SnA,TestaA,_,PersA,GenA,NumA,CatA,_))),
       recover_sec(nil, Altri, N),!.


checkindexpredsoc(Root,Role,Index,Pred):-
   nodo(Root)::sogg/Role::indice::Index,
   nodo(Root)::sogg/Role::pred::Pred,
   !.
checkindexpredsoc(Root,Role,Index,Pred):-
   nodo(R)::sogg/Role::indice::Index,
   nodo(N)::K::nodo(R),
   (N=Root;K=_/prop),
   nodo(R)::sogg/Role::pred::Pred,
   !.
checkrolesoc(Root,Role):-
   nodo(Root)::sogg/Role::indice::_,
   !.
checkrolesoc(Root,Role):-
   nodo(R)::sogg/Role::indice::_,
   nodo(N)::K::nodo(R),
   (N=Root;K=_/prop),
   !.

/**********
:-fs_to_ss(Inds, SS, Locs)
**********/
fs_to_ss(Inds, SS, NoFr, NoCl, NewNoCl, Loc, Temp, At) :-
   start_node(Node),
   sent_smap(Node, NoFr, [NoCl, NewNoCl, Loc, Temp, At], inds([], Out), Sem),
   toground(Sem-Out, SS-Inds).


start_node(Node) :-
   nodo(n1)::main/prop::nodo(Node).
start_node(n1).

sent_smap(Node, NoFr, Locs, Inds, Sem) :-
   funcs_smap(props, NoFr, Node, Locs, Inds, Pars, Facts),
   Facts=[Ind, Fact, Const],
   Sem=
      (desc:
         [obj:Ind,
          fact:Fact,
          constraints:Const]).
   


/*************** 
Proposition 
****************/
/*  interrogativa */
prop_smap(NoFr,
   propq-Node-pred(Pred),  Locs, inds(In, Out), 
   [ask:[ind:Ind, rest:Fact]])
   :-
   nodo(Node)::focus::nodo(FocusNode),
   nodo(FocusNode)::tipo_focus::interrogativo,
   nodo(FocusNode)::pred::FocusPred,
   !,
   index_smap(FocusNode, FocusPred, inds(In, Mid), Ind),
   prop_smap(NoFr, prop-Node-pred(Pred), Locs, inds(Mid, Out), [_:Fact]).


/* copulativa */
prop_smap(NoFr,
   Role-Node-pred(CopPred), Locs, inds(In, Out), 
   [Indet,Fact,Constr])
   :-
   Role \= propq,
   copulative(CopPred, Fun1/Role1, Fun2/Role2,  XcompPred, Rel, IntRole),
   !,
   nodo(Node)::Fun1/Role1::nodo(SubjNode),
   nodo(SubjNode)::pred::SubjPred,
   arg_smap(NoFr, Role1-SubjNode-SubjPred, Locs, inds(In, Mid1), [T:Arg]),
   nodo(Node)::Fun2/Role2::pred::XcompPred,
   second_argument(Fun2/Role2, Node, inds(Mid1, Mid2), Arg2),     
   pol_smap(Node, Pol),
   index_smap(Node, event(Rel), inds(Mid2, Mid3), EventInd),
   event_adjs(NoFr, Locs, Node, EventInd, inds(Mid3, Mid4), Rests, Atts),
   choose_context(NoFr, Node, Locs, inds(Mid4, Out), CRests, Context),
   append(Rests, CRests, Allrests),
   append([T:Arg], Arg2, Args),
   Indet=[ind:Sit,
              val:EventInd,
              type:sit],
   Fact=[rel:Rel, 
         args:Args, 
         Pol],
   Constr=[rests:Allrests,
          atts:Atts,
          context:Context].

/* generica */
prop_smap(NoFr, Role-Node-pred(Pred), Locs, inds(In, Out), 
   [Indet,Fact,Constr]) 
   :-
   Role \= propq,
   funcs_smap(funcs, NoFr, Node, Locs, inds(In, Mid1), _, Args),
   pol_smap(Node, Pol),
   index_smap(Node, event(Pred), inds(Mid1, Mid2), EventInd),
   event_adjs(NoFr, Locs, Node, EventInd, inds(Mid2, Mid3), Rests, Atts),
   choose_context(NoFr, Node, Locs, inds(Mid3, Out), CRests, Context),
   append(Rests, CRests, Allrests),
   Indet=[ind:Sit,
              val:EventInd,
              type:sit],
   Fact=[rel:Pred, 
         args:Args, 
         Pol],
   Constr=[rests:Allrests,
          atts:Atts,
          context:Context].

second_argument(_/prop, _, inds(In, In), []) .
second_argument(Fun2/stato, Node, Inds, Arg)  :-
   nodo(Node)::Fun2/stato::_/Role::nodo(ToNode),
   nodo(ToNode)::pred::Pred,
   arg_smap(NoFr, Role-ToNode-pred(Pred), _, Inds, Arg).
 
/* vcomp-propositions */
vprop_smap(NoFr, Role-Node-pred(Pred), Locs, inds(In, Out), 
   [Indet,Fact,Constr])
   :-
   funcs_smap(funcs, NoFr, Node, Locs, inds(In, Mid1), _, Args),
   pol_smap(Node, Pol),
   index_smap(Node, event(Pred), inds(Mid1, Mid2), EventInd),
   event_adjs(NoFr, Locs, Node, EventInd, inds(Mid2, Mid3), Rests, Atts),
   predicat_smap(Node, Type, Locs, inds(Mid3, Out), CRests, Context),
   append(Rests, CRests, Allrests),
   Indet=[ind:Sit,
              val:EventInd,
              type:Type],
   Fact=[rel:Pred, 
         args:Args, 
         Pol],
   Constr=[rests:Allrests,
          atts:Atts,
          context:Context].

event_adjs(NoFr, [_, _, Spaceloc, Temp, _], 
            Node, EventInd, inds(In, Out), AllRests, Atts) :-
   tense_smap(
      Node, EventInd, inds(Mid, Out), Tloc, Tense),
   funcs_smap(verb_adjs, NoFr, Node, Locs,  
      inds(In, Mid), pars([EventInd, Tloc]), 
      Adjs),
   separate_rests_atts(Adjs, Rests, Atts),
   append(Tense, Rests, TRests),
   spac(EventInd, Spaceloc, Space),
   append(Space, TRests, AllRests).

/* Spatial location */
spac(EventInd, Scontr, [Spaces]):-
  Space =..[space_location, EventInd, Scontr],
  Spaces = rest:['<Space>'].

/* Verbal Pred */
vpred_smap(Node, rel:Rel, Rel) :-
   syntactic_verbal_pred(Node, Rel).

/* Generic functions set */
funcs_smap(Set, NoFr, Node, Locs, Inds, Pars, Funcs) :-
   function_nodes(Set, Node, FuncsNodes),
   funcs_list_smap(NoFr, Set, FuncsNodes, Locs, Inds, Pars, Funcs).

funcs_adjs_smap(Set, NoFr, Node, Locs, Inds, Pars, Funcs) :-
   funcs_smap(FSet, NoFr, Node, Locs, Inds, Pars, Funcs),
   adjs_smap(ASet, NoFr, Node, Locs, Inds, Pars, Adjs),
   append(Funcs, Adjs, FuncsAdjs),
   function_nodes(Set, Node, FuncsNodes),
   funcs_list_smap(NoFr, Set, FuncsNodes, Locs, Inds, Pars, FuncsAdjs).


adjs_smap(Set, NoFr, Node, Locs, Inds, Pars, Funcs) :-
   function_nodes(Set, Node, FuncsNodes),
   funcs_list_smap(NoFr, Set, FuncsNodes, Locs, Inds, Pars, Funcs).

funcs_list_smap(NoFr, Set, [], Locs, inds(In, In), _, []).
funcs_list_smap(NoFr,
   Set, [Func| Funcs], Locs,
   inds(In, Out), Pars,  
   Args) 
   :-
   function_smap(NoFr,
      Set, Func, Locs, inds(In, Mid), Pars, Args1),
   funcs_list_smap(NoFr,
      Set, Funcs, Locs, inds(Mid, Out), Pars,  Args2),
   append(Args1, Args2, Args).

function_smap(NoFr, props, Func, Locs, Inds, _, Arg) :-
   prop_smap(NoFr, Func, Locs, Inds, Arg).
   
function_smap(NoFr, funcs, Func, Locs, Inds, _, Arg) :-
   arg_smap(NoFr, Func, Locs, Inds, Arg).
   
function_smap(_, nom_adjs, Func, Locs, Inds, Pars, Arg) :-
   nadj_smap(Func, Inds, Pars, Arg).

function_smap(_, verb_adjs, Func, Locs, Inds, Pars, Arg) :-
   vadj_smap(Func, Locs, Inds, Pars, Arg).

function_smap(_, mods, Func, Locs, Inds, Pars, Arg) :-
   mod_smap(Func, Inds, Pars, Arg).
   


function_nodes(Set, Node, Roles) :-
   findall(Role, fun_node(Set, Node, Role), Roles),!.
%   writenl(user, Set-Roles).

adjs_nodes(Set, Node, Roles) :-
   findall(Role, adj_node(Set, Node, Role), Roles),!.
%   writenl(user, Set-Roles).

fun_node(Set, Node, Role-NodeTo-SemHead) :-
   isa_fun_node(Set, Node, Role, NodeTo, SemHead).
 
adj_node(Set, Node, Role-NodeTo-SemHead) :-
   isa_fun_node(Set, Node, Role, NodeTo, pred(SemHead)).

/***********
funzioni  proposizionali
************/
isa_fun_node(props, n1, prop, n1, pred(SemHead)) :-
   nodo(n1)::pred::SemHead.
isa_fun_node(props, Node, Role, Node, pred(SemHead)) :-
   Node \= n1,
   nodo(Node)::pred::SemHead,
   nodo(_)::_/Role::nodo(Node).
isa_fun_node(props, Node, Role, NodeTo, pred(SemHead)) :-
   Node \= n1,
   nodo(Node)::coord::nodo(NodeTo),
   nodo(NodeTo)::pred::SemHead,
   nodo(_)::_/Role::nodo(Node).


/************ 
funzioni argomentali 
***********/
isa_fun_node(funcs, Node, Fun/Role, NodeTo, SemHead) :-
   nodo(Node)::Fun/Role::nodo(NodeTo),
   sem_head(NodeTo, SemHead).    

/************ 
aggiunti verbali 
*************/
isa_fun_node(verb_adjs, Node, Role, NodeTo, pred(SemHead)) :-
   nodo(Node)::adjs::adj/Role::nodo(NodeTo),
   nodo(NodeTo)::pred::SemHead.

isa_fun_node(verb_adjs, Node, Role, NodeTo, sem_mark(SemHead)) :-
   nodo(Node)::adjs::adj/Role::nodo(NodeTo),
   nodo(NodeTo)::sem_mark::SemHead.

isa_fun_node(verb_adjs, Node, nil, NodeTo, pred_avv(SemHead)) :-
   nodo(Node)::adjs::avv::nodo(NodeTo),
   nodo(NodeTo)::pred_avv::SemHead.

/* aggiunti proposizionali */  
isa_fun_node(verb_adjs, Node, nil, NodeTo, sem_mark(SemHead)) :-
   nodo(Node)::adjs::adj::nodo(NodeTo),
   nodo(NodeTo)::sem_mark::SemHead.
   

/**********
aggiunti nominali 
**********/
isa_fun_node(nom_adjs, Node, Role, NodeTo, pred(SemHead)) :-
   nodo(Node)::adjs::adj/Role::nodo(NodeTo),
   nodo(NodeTo)::pred::SemHead.  
isa_fun_node(nom_adjs, Node, Role, NodeTo, SemHead) :-
   nodo(Node)::adjs::nadj/Role::nodo(NodeTo),
   sem_head(NodeTo, SemHead).    
isa_fun_node(nom_adjs, Node, Role, NodeTo, pred(SemHead)) :-
   nodo(Node)::adj/Role::nodo(NodeTo),
   nodo(NodeTo)::pred::SemHead.  
/*********** 
modificatori nominali 
***********/
isa_fun_node(mods, Node, Role, NodeTo, pred(SemHead)) :-
   nodo(Node)::mods::mod/Role::nodo(NodeTo),
   nodo(NodeTo)::pred::SemHead.  
isa_fun_node(mods, Node, FunRole, NodeTo, pred(SemHead)) :-
   nodo(Node)::mods::FunRole::coordina::coord::nodo(NodeTo),
   nodo(NodeTo)::pred::SemHead.  
isa_fun_node(mods, Node, FunRole, NodeTo, pred(SemHead)) :-
   nodo(Node)::mods::FunRole::nodo(NodeTo),
   atomic(FunRole),
   nodo(NodeTo)::pred::SemHead.  


sem_head(Nodo, pred(Pred)) :-
   nodo(Nodo)::pred::Pred.
sem_head(Nodo, coordina(CoordNode)) :-
   nodo(Nodo)::coordina::nodo(CoordNode).
/* ma andrebbe normalizzato */
sem_head(Nodo, coord_prop) :-
   once(nodo(Nodo)::coord::nodo(_)). 

/**************** 
Arguments
**************/
/* form */
arg_smap(_, _/form-Node-_, _, inds(In, In), []) :-
   !.

/* oggetti coordinati */
arg_smap(_, Func/Role-_-coordina(Node), _, Inds, [Role:Arg]) :-
   findall(
      Func-CoordNode-pred(Pred), 
      (
      nodo(Node)::_/Role::nodo(CoordNode),
      nodo(CoordNode)::pred::Pred
      ),
      CoordNodes),
   CoordNodes\=[],
   Role\=prop,
   funcs_list_smap(NoFr, funcs, CoordNodes, Locs, Inds, _, CoordArgs),
   Arg= (set:[ind:_, cond:CoordArgs]).

arg_smap(_, Func/Role-_-coordina(Node), _, Inds, [Role:Arg]) :-
   !,
   findall(
      Func-CoordNode-pred(Pred), 
      (
      nodo(Node)::coord::nodo(CoordNode),
      nodo(CoordNode)::pred::Pred
      ),
      CoordNodes),
   CoordNodes\=[],
   Role=prop,   
   funcs_list_smap(NoFr, props, CoordNodes, Locs, Inds, _, CoordArgs),
   Arg= (set:[ind:_, cond:CoordArgs]).
   
/* evento singolo 
arg_smap(_, Role-Node-_, Locs, Inds, [Role:[ask:[ind:Ind, rest:Fact]]]) :-
   propq_role(Role),
   !,
   nodo(Node)::focus::nodo(FocusNode),
   nodo(FocusNode)::tipo_focus::interrogativo,
   nodo(FocusNode)::pred::Pred,
   index_smap(Node, Pred, Inds, Ind),
   sent_smap(Node, NoFr, Locs, Inds, Fact).
*/
/* eventi */
arg_smap(NoFr, vcomp/Role-Node-Pred, Locs, Inds, [arg2:[Role:Fact]]) :-
   !,
   vprop_smap(NoFr, Role-Node-Pred, Locs, Inds, Fact).

arg_smap(NoFr, acomp/Role-Node-Pred, Locs, Inds, [arg2:[Role:Fact]]) :-
   !,
   vprop_smap(NoFr, Role-Node-Pred, Locs, Inds, Fact).

arg_smap(NoFr, ncomp/Role-Node-Pred, Locs, Inds, [arg2:[Role:Fact]]) :-
   !,
   vprop_smap(NoFr, Role-Node-Pred, Locs, Inds, Fact).

arg_smap(NoFr, pcomp/Role-Node-Pred, Locs, Inds, [arg2:[Role:Fact]]) :-
   !,
   vprop_smap(NoFr, Role-Node-Pred, Locs, Inds, Fact).

arg_smap(NoFr, fcomp/Role-Node-Pred, Locs, Inds, [arg2:[Role:Fact]]) :-
   !,
   prop_smap(NoFr, Role-Node-Pred, Locs, Inds, Fact).

arg_smap(NoFr, Func/Role-Node-_, Locs, Inds, [arg2:[Role:Fact]]) :-
   prop_role(Role),
   !,
   sent_smap(Node, NoFr, Locs, Inds, Fact).

/* individui controllati */
arg_smap(NoFr, Role-Node-_, _, Inds, [ArgN:Arg]) :-
   nodo(Node)::tab_ref::TabRef,
   pro_tab_ref(TabRef),
   !,   
   (ArgN=arg1, Func=sogg; ArgN=args2),
   nodo(Node)::indice::Index,
   segui_catena_di_controllo(Index, Controller),
   controlled_ind(Controller, Inds, Arg).

/* funzioni inespresse riempite con exist */
arg_smap(NoFr, Funs, _, inds(In, Out), [ArgN:Arg]) :-
   Indd=..[inds,In,Mid],
   index_smap(Node, Pred, Indd, Ind),
   nodo(Node)::tab_ref::TabRef,
   nodo(Node)::cat::Class,
   ((Role=locat; Role=locative), Type=loc
    ; Type=entity),
   (ArgN=arg1, Func=sogg; ArgN=args2),
   tab_refq(TabRef),
   !,
   card_smap(Node, Ind, Card),
   def_smap(Node, Def),
   mods_and_adjs_smap(
      Node, inds(Mid, Out), pars([Ind]), 
      Rests, Atts),
   Arg=
      (set:
         [ind:Set,
             [val:Ind, 
										    cond:
               [card:Card, 
                class: ('<isa(Ind, Class)>'), 
                ident: ('<quant(Ind, Pred)>'), 
                type:Type,
                role:Role],
               Rests,
               Atts]]),
   Funs=..[Func/Role-Node-pred,Pred].

/* individuo singolo */
arg_smap(NoFr, Funs, _, inds(In, Out), [ArgN:Arg]) :-
   Indd=..[inds,In,Mid],
   index_smap(Node, Pred, Indd, Ind),
   nodo(Node)::tab_ref::TabRef,
   ((Role=locat; Role=locative), Type=loc
    ; Type=entity),
   (ArgN=arg1, Func=sogg; ArgN=args2),
   tab_refi(TabRef),
   !,
   card_smap(Node, Ind, Card),
   def_smap(Node, Def),
   mods_and_adjs_smap(
      Node, inds(Mid, Out), pars([Ind]), 
      Rests, Atts),
   Arg=
      (set:
         [ind:Set,
             [val:Ind, 
										    cond:
               [card:Card, 
                class: ('<isa(Ind, Pred)>'), 
                ident: ('<def(Ind, Def)>'), 
                type:Type,
                role:Role],
               Rests,
               Atts]]),
   Funs=..[Func/Role-Node-pred,Pred].

/* nome proprio */
arg_smap(NoFr, Funs, _, inds(In, Out), [ArgN:Arg]) :-
   Indd=..[inds,In,Mid],
   index_smap(Node, Pred, Indd, Ind),
   nodo(Node)::tab_ref::TabRef,
   ((Role=locat; Role=locative), Type=loc
    ; Type=entity),
   (ArgN=arg1, Func=sogg; ArgN=args2),
   tab_refn(TabRef),
   !,
   card_smap(Node, Ind, Card),
   gen_smap(Node, Gen),
   mods_and_adjs_smap(
      Node, inds(Mid, Out), pars([Ind]), 
      Rests, Atts),
   Arg=
      (ind:
          [val:Ind,
										 cond:
               [card:Card, 
                class: ('<isa(Ind, Gen)>'),
                ident: ('<name(Ind, Pred)>'), 
                type:Type,
                role:Role],
               Rests,
               Atts]),
   Funs=..[Func/Role-Node-pred,Pred].


/* Sintagmatic index to Individual */
index_smap(
   Node, Pred, 
   inds(In, In), Ind)
   :-
   nodo(Node)::indice::Index,
   on(ind(Index, Ind, Pred), In),
   !.
index_smap(
   Node, Pred, 
   inds(In, [ind(Index, Ind, Pred) | In]), Ind)
   :-
   nodo(Node)::indice::Index.

controlled_ind(Controller, inds(In, In), Arg) :-
   on(ind(Controller, Arg,  _), In),
   !.

controlled_ind(Controller, inds(In, Out), Arg) :-
   Out = [ind(Controller, Arg,  _) | In].


/* Create an individual */
add_ind(Type, inds(In, Out), Ind) :-
   Out = [ind(Ind, Type) | In].


/***********
Modifiers and Nominal Adjuncts
************/
mods_and_adjs_smap(
   Node, inds(In, Out), Pars, 
   rests:Rests, atts:Atts) 
   :-
   funcs_smap(mods, NoFr, Node, Locs, inds(In, Mid),  Pars, Mods),
   funcs_smap(nom_adjs, NoFr, Node, Locs, inds(Mid, Out), Pars, Adjs),
   separate_rests_atts(Mods, Rests1, Atts1),
   separate_rests_atts(Adjs, Rests2, Atts2),
   append(Rests1, Rests2, Rests),
   append(Atts1, Atts2, Atts).


separate_rests_atts(RestsAndAtts, Rests, Atts) :-   
   selectall_att(rest, RestsAndAtts, Rests),
   selectall_att(att, RestsAndAtts, Atts).
 
/***********
Modifiers 
************/
mod_smap(
   nome_mod-Node-pred(Pred), inds(In, In), pars([Ind]), 
   [rest:Rest]) 
   :-
   Rest= ('<isa(Ind, Pred)>'),
   !.

mod_smap(
   mod_a-Node-pred(Pred), inds(In, In), pars([Ind]),
   [att:Rest])
   :-
   Rest= ('<fact(Pred, [arg:Ind], 1)>'),
   !.

mod_smap(
   predic-Node-_, Inds, pars([Ind]),
   [rest:Rest])
   :-
   sent_smap(Node, NoFr, Locs, Inds, Rest),
   !.
mod_smap(
   ModType-Node-pred(Pred), inds(In, In), pars([Ind]),
   [rest:Rest])
   :-
   on(ModType, [mod_d, mod_r]),
   Rest= ('<fact(Pred, [arg:Ind], 1)>'),
   !.

mod_smap(_, inds(In, In), _, []).

/***********
Nominal Adjuncts 
************/
nadj_smap(
   predic-Node-_, Inds, _,
   [att:Rest])
   :-
   sent_smap(Node, NoFr, Locs, Inds, Rest),
   !.
   
nadj_smap(theme-Node-Pred, Inds, pars([Ind]), 
   [att:Att]) 
   :-
   arg_smap(NoFr, theme-Node-Pred, _, Inds, [theme:Arg]),
   !,
   Att=
      [rel:eq_set, 
      arg1:Ind, 
      arg2:Arg].

nadj_smap(_, inds(In, In), _, []) .
   
/***********
Verbal Adjuncts 
************/
vadj_smap(
   AdjRole-Node-_, Locs, Inds, pars([EvId, _]), [att:Att])
   :-
   AdjRole==gerund,
   !,
   sent_smap(Node, NoFr, Locs, Inds, Gerund),
   Att = 
      [rel:circumstance,
      args:[arg1:EvId, arg2:Gerund],
      pol:1].

vadj_smap(
   AdjRole-Node-Pred, Locs, inds(In, Out), Pars, Sem)
   :-
   funcs_smap(funcs, NoFr, Node, Locs, inds(In, Mid), Pars, Args),
   vadj_with_args_smap(AdjRole-Node-Pred, args:Args,  inds(Mid, Out), Pars, Sem).

vadj_smap(AdjRole-Node-Pred, Locs, Inds, Pars, Sem)
   :-
   notnod(Node, _/_),
   transfrastic_vadj_smap(
      AdjRole-Node-Pred, ArgNode, Inds,  Pars, Sem).


vadj_smap(_,  Locs, inds(In, In), _, []).

/* ex: vivevano felici */
vadj_with_args_smap(
   emotivo-Node-pred(Pred), 
   args:[ArgRole:Arg], 
   Inds, 
   pars([EvId, _]), 
   [rest:Rest])
   :-
   ArgRole \= prop, 
   index_smap(Node, event(Pred), Inds, AdjEvId),
   pol_smap(Node, Pol), 
   !,
   AdjFact=[rel:Pred, args:[arg:Arg], Pol],
   Rest = 
      [rel:while,
      args:[arg1:EvId, arg2:AdjFact],
      pol:1].

/* ex: una volta */
vadj_with_args_smap(
   deittico-_-sem_mark(nil), 
   args:[non_punct:Arg2], 
   inds(In, In), 
   pars([_, Tloc]),
   [rest:Rest])
   :-
   !,
   Rest = 
      [rel:in,
      args:[arg1:Tloc, arg2:Arg2],
      pol:1].

/* ex: con mattoni e cemento */
vadj_with_args_smap(
   AdjRole-Node-sem_mark(_), 
   args:[nil:Arg2, AdjRole:Arg3], 
   inds(In, In), 
   pars([EvId, _]),
   [rest:Rest])
   :-
   !,
   Rest = 
      [rel:AdjRole,
      args:[event:EvId, object:Arg2, AdjRole:Arg3],
      pol:1].

/* ex: per proteggersi */
vadj_with_args_smap(
   _-_-sem_mark(SemMark), 
   args:[prop:Arg2], 
   inds(In, In),
   pars([EvId, _]), 
   [rest:Rest])
   :-
   !,
   Rest = 
      [rel:SemMark,
      args:[arg1:EvId, arg2:Arg2],
      pol:1].

/* ex: pero_ */
transfrastic_vadj_smap(
   AdjType-_-pred(Pred), ArgNode, Indd,  pars([EvId, _]), 
   [att:Att]) 
   :-
   Indd=..[inds,In, In],
   on(AdjType, [avvers, modal]),
   Att= ('<fact(Pred, [arg:EvId], 1)>').
   
/* ex: intanto */
transfrastic_vadj_smap(
   nil-Node-pred_avv(Pred), ArgNode, Indd,  pars([EvId, _]), 
   [att:Att]) 
   :-
   Indd=..[inds,In, In],
   Att= ('<fact(Pred, [arg:EvId], 1)>').
   

/* Cardinality */
card_smap(Node, Ind, ['<card(Ind, Card1)>']) :-
   nodo(Node)::spec::card::Card,
   conv_card(Card, Card1), 
   !.
card_smap(Node,  Ind, ['<card(Ind, 1)>']) :-
   nodo(Node)::num::sing,
   !.
card_smap(Node,  Ind, ['<card(Ind, Card)>', '<greater(Card, 1)>']) :-
   nodo(Node)::pred::exist,
   !.
card_smap(Node,  Ind, ['<card(Ind, Card)>', '<greater(Card, 1)>']) :-
   nodo(Node)::num::plur,
   !.
card_smap(Node, _, unknown).
   
/* Definiteness */
def_smap(Node, Def1) :-
   nodo(Node)::spec::def::Def,
   conv_defn(Def, Def1),
   !.
def_smap(Node, unknown).


/* Gender Default Class */
gen_smap(Node, Kind) :-
   nodo(Node)::gen::Gen,
   nodo(Node)::cat::Cat,
   (on(umano, Cat),
   conv_genc(Gen, Kind)
   ;
   conv_genl(Gen, Kind)),
   !.

gen_smap(Node, unknown).

/* Tense */
tense_smap(
   Node, EventId, Indd, 
   TLoc, [rest:Loc1, rest:Loc2])
   :-
   Indd=..[inds,In, Out],
   nodo(Node)::tempo::Tense,
   !,
   add_ind(tloc, Indd, TLoc),
   Loc1=['< time_location(EventId, TLoc)>'],
   Loc2=['< in(TLoc, Tense)>'].

tense_smap(
   Node, EventId, inds(In, Out), 
   Tloc, [rest:Loc1])
   :-
   Indd=..[inds,In, Out],
   add_ind(tloc, Indd, TLoc),
   Loc1=['< time_location(EventId, TLoc)>'].

/* Context */
choose_context(1, Node, [NoCl, NNC, Loc, Temp, At], inds(In, Out), NewRes, [disc:rel:DiscRel, states:[move:DiscMove, state:State], ref:[Topics]])
   :-
   predicat_smap(Node, Type, [NoCl, NNC, Loc, Temp, At], 
           inds(In, Out), NewRes, 
           [disc:rel:DiscRel, states:[move:Rel, state:Change], ref:[Topics]]),
    !.
choose_context(NoFr, Node, [NoCl, NNC, Loc, Temp, At], inds(In, Out), NewRes, [disc:rel:DiscRel, states:[move:DiscMove, state:State], ref:[Topics]])
   :-
  (nonvar(In),
   nonvar(Loc),
   nonvar(Temp),
   !,
   old_context_smap(NoFr, Node, [NoCl, NNC, Loc, Temp, At], inds(In, Out), NewRes, [disc:rel:DiscRel, states:[move:DiscMove, state:State], ref:[Topics]])
   ;
   context_smap(NoFr, Node, [NoCl, NNC, Loc, Temp, At], inds(In, Out), NewRes, [disc:rel:DiscRel, states:[move:DiscMove, state:State], ref:[Topics]])
   ),!.

old_context_smap(NoFr, Node, [NoCl, NNC, Loc, Temp, At], inds(In, Out), NewRes, [disc:rel:DiscRel, states:[move:DiscMove, state:State], ref:[Topics]]):-
  rete(Rete),
  assign_index(NoFr, Loc, Temp, In, Out),
  collect_tops(NoFr, Topics),
  info(NoFr, _, FunRole, View, Intens, Change, Rel, 
     VerbCat, Verb, TempRel, DiscRel, DiscDom, SubjConsc),
  d_structure(
   NoFr, Node, NoCl, _, DiscRel, TempRel,
   MainRel, State, DiscMove, DiscLev),
   NewRes=[rest:TempRel,
                rel:MainR],
     (
      loc(Infon, Id, [arg:main_tloc, arg:Ref]), 
      MainR=loc(Id,[arg:main_tloc, arg:Ref])
       ;
      includes(tes(TimeId), NewLoc),
      MainR=includes(tes(TimeId), NewLoc)).

predicat_smap(Node, Type, [NoCl, NNC, Loc, Temp, At], inds(In, Out), NewRes, [disc:rel:DiscRel, states:[move:Rel, state:Change], ref:[Topics]]):-
  rete(Rete),
  assign_index(NoFr, Loc, Temp, In, Out),
  collect_tops(NoFr, Topics),
  info(NoFr, _, FunRole, View, Intens, Change, Rel, 
     VerbCat, Verb, TempRel, DiscRel, DiscDom, SubjConsc),
   (Type=fact, Intens=factive; Type=sit),
   NewRes=[rest:TempRel,
                rel:MainR],
     (
      loc(Infon, Id, [arg:main_tloc, arg:Ref]), 
      MainR=loc(Id,[arg:main_tloc, arg:Ref])
       ;
      includes(tes(TimeId), NewLoc),
      MainR=includes(tes(TimeId), NewLoc)).

context_smap(NoFr, Node, [NoCl, NNC, Loc, Temp, At], inds(In, Out), NewRes, [disc:rel:DiscRel, states:[move:DiscMove, state:State], ref:[Topics]]):-
  rete(Rete),
  in_context(Rete, NoFr, NoCl, NNC, Loc, Temp, At),
  assign_index(NoFr, Loc, Temp, In, Out),
  collect_tops(NoFr, Topics),
  d_structure(
   NoFr, Node, NoCl, _, DiscRel, TempRel,
   MainRel, State, DiscMove, DiscLev),
   NewRes=[rest:TempRel,
                rel:MainR],
     (
      loc(Infon, Id, [arg:main_tloc, arg:Ref]), 
      MainR=loc(Id,[arg:main_tloc, arg:Ref])
       ;
      includes(tes(TimeId), NewLoc),
      MainR=includes(tes(TimeId), NewLoc)).

collect_tops(NoFr,topics:NTops):-
  findall(Type-Ind, confer_topic(NoFr, Type, Ind, SnX, _), Topics),
  sort(Topics, NTops).

assign_index(_,_,_, [], []):- !.

assign_index(NoFr, Loc, Temp, [ind(Sind, Rest)|Inds], [ind(Sind, Rest)|Out]):-
    (Rest=tloc, nonvar(Temp), Sind=Temp
     ; 
     Rest=sloc, nonvar(Loc), Sind=Loc
    ;
    var(Sind),
    conv_sn_index(NoFr, SnX, Sind)
    ;
    nonvar(Sind)),
   assign_index(NoFr, Loc, Temp, Inds, Out).

assign_index(_, _, _, [ind(SnX, Sind, Rest)|Inds], [ind(SnX, Sind, Rest)|Out]):-
   (asserted_ind(SnX, Sind)
    ;
   conv_sn_index(NoFr, SnX, Sind)),
   assign_index(_, _, _, Inds, Out).

/*
conv_sn_index(_, SnX, Ind) :-
   asserted_ind(SnX, Ind),
   nonvar(Ind),
   !.

conv_sn_index(NoFr, SnX, Ind) :-
   gen_sym(id, Ind),
   assert(confer_ind(NoFr, SnX, Ind)),
   assert(new_ind(Ind)).

asserted_ind(SnX, Ind) :-
  frase_corrente(NoFr, _),
  confer_topic(NoFr, _, Ind, SnX, _),
  !.
   
asserted_ind(SnX, Ind) :-
  frase_corrente(NoFr, _),
  confer_ind(NoFr, SnX, Ind).
*/
/* Polarity */
pol_smap(Node, pol:Pol1) :-
   polarity(Node, Pol),
   conv_polarity(Pol, Pol1).

tab_refq([+ ref, - pro, - ana, + me]).
tab_refn([+ ref, - pro, - ana, - class]).
tab_refi([+ ref, - pro, - ana, + class]).
pro_tab_ref([+ ref, - pro, - ana, - me]).
pro_tab_ref([+ ref, + pro, + ana, - me]).
pro_tab_ref([+ ref, + pro, + ana, + me]).
pro_tab_ref([+ ref, + pro, - ana, - me]).
pro_tab_ref([+ ref, + pro, - ana, + me]).
pro_tab_ref([- ref, - pro, + ana, + me, - subj]).
            
conv_polarity(no, 0).
conv_polarity(yes, 1).

conv_defn('0', indef) :- !.
conv_defn(0, indef) :- !.
conv_defn(+, def) :- !.
conv_defn(-, indef) :- !.
conv_defn(Def, Def).

conv_card(due, 2) :- !.
conv_card(tre, 3) :- !.
conv_card(Card, Card).

conv_genc(mas, man) :- !.
conv_genc(fem, woman) :- !.
conv_genl(fem, loc) :- !.
conv_genl(mas, loc) :- !.


prop_role(prop).
prop_role(modal).
prop_role(propq).

/********
copulative(+verb, +fun1/+role1, +fun2/+role2, +xcompPred, -relation, -intRole).
********/
copulative(
   essere, sogg/Role, acomp/prop, AcompPred, 
   AcompPred, arg):-Role=tema_bound;Role=theme_bound.
copulative(
   avere, sogg/Role, ncomp/stato, NcompPred, 
   avere+NcompPred, Role):-Role=esperiente;Role=experiencer.

copulative(
   be, sogg/Role, acomp/prop, AcompPred, 
   AcompPred, arg):-Role=tema_bound;Role=theme_bound.
copulative(
   have, sogg/Role, ncomp/stato, NcompPred, 
   have+NcompPred, Role):-Role=esperiente;Role=experiencer.

copulative(essere).
copulative(be).

selectall_att(_, [], []) :-
   !.
selectall_att(Att, [Att:Val | Feats], [Att:Val | OtherFeats]) :-
   !,
   selectall_att(Att, Feats, OtherFeats).
selectall_att(Att, [_ | Feats], OtherFeats) :-
   selectall_att(Att, Feats, OtherFeats).

new_nwrite_sentence_infons(NRefs, RelIds, NoFr, Win) :-
     write_all_confer_topics(Win, NRefs, All, NoFr, Tops),
     write_all_predicat_arguments(Win, NRefs, RelIds, All, NoFr, Rels),
     write_all_dependencies(NoFr, Win, RelIds, Tops, Rels),
     !.

write_all_dependencies(NoFr, Win, RelIds, [Tops,Refs], Rels):-
     write_detmods(Tops, Refs, Heads),
     write_auxs(RelIds, Rels, Preds),
     write_args(RelIds, Rels, Heads),
     !.

write_sentence_number:-
     frase_corrente(NoFr, Code),
     write(NoFr), 
     write('-'), write('('),
     !.

create_dep_file(Win,FileName):-
  fname(Win, Vol, A, _),
  concat(A, '_', FileN),
  concat(FileN, dep, FileNam),
  concat(Vol, FileNam, FileName),
  open(FileName,write),
  tell(FileName),
  !.

write_property(Func, Rel, Head):-
     write_sentence_number,
     write(Func),
     write( '  - '),
     write(Rel),
     write('  '),
     write(Head),
     write('  '),
     write('_'),
     writenl(')'),
     !.

proprieta_sempll(Id,Prop) :-
     fact(_,inst_of,[_:Id, class:Propp],1,_,_),
     (fact(_,name,[Prop,Id],1,_,_)
      ;
      fact(_,isa,[_:Id, class:Prop],1,_,_)).

write_adjuncts(Id,Testa):-
      fact(_,Rel,[arg:Id, Role:Idx],1,_,_),
      proprieta_sempll(Idx,Prop),
   write_property(Role, Testa, Prop),
   !.
write_adjuncts(Id,Testa).
write_reladjuncts(Cl,Id,Testa):-
      fact(_,Rel,[arg:Idx, Role:Id],1,_,_),
      proprieta_sempll(Idx,Prop),
   write_property(Rel, Testa, Prop),
   !.
write_reladjuncts(Cl,Id,Testa).

write_subordin_mods(Cl,Testa):-
     refsems(Sems),
     Sems\=[],
     on(_-Cl-Sem, Sems),
     Sem=(fs-Rels),
     on(Rel-_-_, Rels),
   write_property(adj, Rel, Testa),
   !.
write_subordin_mods(Cl,Testa).

recover_property_head(N, Rel, [], Props):-!.
recover_property_head(0, Rel, [_:Id], Props):-
   nonvar(Id),
   (proprieta_sempll(Id,Testa)
   ;
    proprieta_compl(Id,Testa)),
   write_adjuncts(Id,Testa),
   write_property(subj, Rel, Testa),
   !.
recover_property_head(0, Rel, [_:Id|Args], Props):-
   nonvar(Id),
   (proprieta_sempl(Id,Testa)
   ;
    proprieta_compl(Id,Testa)),
   write_adjuncts(Id,Testa),
   write_property(subj, Rel, Testa),
   recover_property_head(1, Rel, Args, Props),   
   !.
recover_property_head(1, Rel, [_:Id], Props):-
   nonvar(Id),
   (proprieta_sempl(Id,Testa)
   ;
    proprieta_compl(Id,Testa)),
   write_adjuncts(Id,Testa),
   write_property(obj, Rel, Testa),
   !.
recover_property_head(1, Rel, [_:Id|Args], Props):-
   nonvar(Id),
   (proprieta_sempl(Id,Testa)
   ;
    proprieta_compl(Id,Testa)),
   write_adjuncts(Id,Testa),
   write_property(obj, Rel, Testa),
   recover_property_head(2, Rel, Args, Props),   
   !.
recover_property_head(2, Rel, [_:Id|Args], Props):-
   nonvar(Id),
   (proprieta_sempl(Id,Testa)
   ;
    proprieta_compl(Id,Testa)),
   write_adjuncts(Id,Testa),
   write_property(obl, Rel, Testa),
   recover_property_head(2, Rel, Args, Props),   
   !.
recover_property_head(N, Rel, [_:Id|Args], Props):-
   var(Id),
   recover_property_head(N, Rel, Args, Props),   
   !.

recover_property_head(N, Rel, [Role:Id|Args], Props):-
   Role=prop,
   recover_property_head(N, Rel, Args, Props),   
   !.
    
write_args([Cl-Id|RelIds], Rels, Heads):-
   fact(Id, Rel, Args, Pol, T, P),
   length(Args,L),
   0 < L, 
   recover_property_head(0, Rel, Args, Props),   
   write_reladjuncts(Cl,Id,Rel),
   write_subordin_mods(Cl,Rel),
   write_args(RelIds, Rels, Heads),
   !.

write_args(Preds, Rels, Heads):-!.

write_all_predicat_arguments(Win, NRefs, [], All, NoFr, []):-!.

write_all_predicat_arguments(Win, NRefs, RelIds, All, NoFr, Rels):-
   appiattisci(NRefs, Refs),
   write_allrelsfacts(NoFr, Win, RelIds, All, Refs, Rels),
   !.
write_allrelsfacts(NoFr, Win, [], All, Refs, []):-!.
write_allrelsfacts(NoFr, Win, [Cl-Id|RelIds], All, NRefs, [Facts|Rels]):-
   fact(Id, Rel, Args, Pol, T, P),
   length(Args,L),
   0 < L, 
   get_relargs(NoFr, Rel, All, L, Cl, Pol, Args, Facts),
   writeallPAs(Win, Facts), 
   write_allrelsfacts(NoFr, Win, RelIds, All, Refs, Rels),
   !.

write_allrelsfacts(NoFr, Win, [Cl-Id|RelIds], All, NRefs, Rels):-
   write_allrelsfacts(NoFr, Win, RelIds, All, Refs, Rels),
   !.

get_ref_relfunc(NoFr, Rel, Sn, Id, NFact):-
   ref_funcs(Func, Sn, Testa, First),
   convert(First,Second),
%   confer_topic(NoFr, Type, Id, Sn, _),
   gensym(r,R),
   multiplyR(R, R1),
   NFac=[R1, NoFr, Id, Func, Rel, Second],
   NFact=..[refs|NFac],
   !.

get_ibar_rel(IBars):-
    findall(K-First-Head, funcs(ibar, K, Head, ibar-First),
       IBars),!.

get_ibar_controlled(IBars):-
    findall(K-First, funcs(vcomp, K, Head, First),
       IBars),!.

get_ref_relfuncc(NoFr, Rel, Id, NFact):-
   get_ibar_controlled(IBars),
   IBars=[N-[Func-First]],
   convert(First,Second),
%   confer_topic(NoFr, Type, Id, Sn, _),
   gensym(r,R),
   multiplyR(R, R1),
   NFac=[R1, NoFr, Id, Func, Rel, Second],
   NFact=..[refs|NFac],
   !.

get_ref_rel(Cl, Head, NFact):-
   get_ibar_rel(IBars),
   on(Cl-Rel-Head, IBars),
   convert(Rel,NFact),
   !.

recover_func_control(All, Id, Func):-
   on(Type-Id-Sn, All),
   ref_funcs(Func, Sn, Testa, First),
   !.

recover_control(ArgsC,All,Role,[Role:Id]):-
   on(R:Id, ArgsC),
   recover_func_control(All, Id, Func),
   Func=obl,
   !.
recover_control(ArgsC,All,Role,[Role:Id]):-
   on(R:Id, ArgsC),
   recover_func_control(All, Id, Func),
   Func=obj,
   !.
recover_control(ArgsC,All,Role,[Role:Id]):-
   on(R:Id, ArgsC),
   recover_func_control(All, Id, Func),
   Func=subj,
   !.

get_relargsprop(Id, Rel, All, ArgsC):-
   fact(Id, Rel, Args, Pol, T, P),
   remove(Role:arb, Args, Args1),
   recover_control(ArgsC,All,Role,CArg),
   append(CArg, Args1, ArgsProp),
   length(Args,L),
   0 < L, 
   get_relargs(NoFr, Rel, All, L, 1, Pol, ArgsProp, Facts),
   writeallPAs(Win, Facts), 
   !.

get_relargs(NoFr, Rel, All, 0, Cl, Pol, Args, []):-!.
get_relargs(NoFr, Rel, All, L, Cl, Pol, Args, NFacts):-
   1 =< L,
   remove(prop:Id, Args, Args1),
   get_relargsprop(Id, ContrRel, All, Args1),
   L1 is L - 1,
   get_relargs(NoFr, Rel, All, L1, 1, Pol, Args1, Facts),
   Fact=[NoFr, Type, Id],
   get_ref_rel(Cl, ContrRel, NRel),
   get_ref_relfuncc(NoFr-Cl, NRel, Id, NFact),
   append(Facts, [NFact], NFacts),
   !.

get_relargs(NoFr, Rel, All, L, Cl, Pol, Args, [NFact|Facts]):-
   1 =< L,
   remove(Arg:Id, Args, Args1),
   on(Type-Id-Sn, All),
   Fact=[NoFr, Type, Id, Sn],
   get_ref_rel(Cl, Rel, NRel),
   get_ref_relfunc(NoFr-Cl, NRel, Sn, Id, NFact),
   L1 is L - 1,
   get_relargs(NoFr, Rel, All, L1, Cl, Pol, Args1, Facts),
   !.

get_relargs(NoFr, Rel, All, L, Cl, Pol, Args, Facts):-
   remove(Arg:Id, Args, Args1),
   L1 is L - 1,
   get_relargs(NoFr, Rel, All, L1, Cl, Pol, Args1, Facts),
   !.

writeallPAs(Win, []):-!.
writeallPAs(Win, [Fact|Facts]):-
   writenl(Win, Fact),
   writeallPAs(Win, Facts),
   !.

get_ref_fact(Fact,Sn,NRefs,NFact,Refs):-
    remove(Ref_ex/_, NRefs, Refs),
    Ref_ex=..[ref_ex,Sn|Rest],
    append(Fact,Rest,NFac),
    NFact=..[top|NFac],
    !.

/*
get_ref_fact(Fact,Sn,NRefs,NFact):-
    NFact=..[top|Fact],
    !.
*/

convert([],[]):-!.
convert([A-B-C|First],[A|Second]):-
   convert(First,Second),
   !.
convert([A|First],[Pref-Second]):-
   A\=_-B-C,
   A=Pref-Rest, list(Rest), Pref\=f2,
   convert(Rest,Second),
   !.
convert([A|First],[Pref-Second]):-
   A\=_-B-C,
   A=Pref-Rest, list(Rest), Pref=f2,
   convertf2(Rest,Second),
   !.
convert([A|First],[A|Second]):-
   A\=_-B-C,
   convert(First,Second),
   !.

convertf2([],[]):-!.
convertf2([A-B-C|First],[A|Second]):-
   convertf2(First,Second),
   !.
convertf2([A|First],[Pref-Third]):-
   A\=_-B-C,
   A=Pref-Rest, 
   list(Rest), 
   Pref\=f2,
   convertf2(Rest,Second),
   (First=[], Third=Second
    ;
     First\=[],
     convertf2(First,Sec),
     append(Second, Sec, Third)
     ),
   !.
convertf2([A|First],[A|Second]):-
   A\=_-B-C,
   convertf2(First,Second),
   !.
get_ref_func(NoFr, Sn, Id, NFact):-
   ref_funcs(Func, Sn, Testa, First),
   convert(First,Second),
%   confer_topic(NoFr, Type, Id, Sn, _),
   gensym(r,R),
   multiplyR(R, R1),
   NFac=[R1, Id, Func, Testa, Second],
   NFact=..[refs|NFac],
   !.

get_ref_func(NoFr, Sn, Id, []):-!.

multiplyR(R, R1):-
   stringof(Number, R),
   reverse(Number, RevN),
   transform(RevN, R1),
   !.
transform([A,B,C,D,E], Number):-
   reverse([A,B,C,D,E], R1),
   stringof(R1,Number),
   !.
transform([A,B,C,D], Number):-
   reverse([A,B,C,'0',D], R1),
   stringof(R1,Number),
   !.
transform([A,B,C], Number):-
   reverse([A,B,'0','0',C], R1),
   stringof(R1,Number),
   !.
transform([A,B], Number):-
   reverse([A,'0','0','0',B], R1),
   stringof(R1,Number),
   !.

check_topic_infon(NoFr, Type, Id, Sn, Allfs):-
   findall(Type-Id-Sn, (confer_topic(NoFr, Type, Id, Sn, _),
   confer_infon(IdInfon, NoFr, Sn, _, _)),All),
   sort(All, Allfs),!.

check_reftopic_infon(NoFr, Id, Sn, Allfs):-
   findall(Sn,
     (confer_infon(IdInfon, NoFr, Sn, _, _), nonvar(Sn)),All),
   sort(All, Allfs),!.
   
write_all_ref_functs(Win, NoFr):-
   check_reftopic_infon(NoFr, Id, Sn, All),
   write_allreffuncts(NoFr, Win, All),
   !.

write_allreffuncts(NoFr, Win,[]):-!.
write_allreffuncts(NoFr, Win,[Sn|All]):-
   get_ref_func(NoFr, Sn, NFact),
   (NFact=[]
    ;
    NFact\=[],
   writenl(Win, NFact)), 
   write_allreffuncts(NoFr, Win,All),
   !.

write_all_confer_topics(Win, NRefs, All, NoFr, [Tops, RefFuncs]) :-
   check_topic_infon(NoFr, Type, Id, Sn, All),
   appiattisci(NRefs, Refs),
   write_allreffacts(NoFr, Win, All, Refs, Tops, RefFuncs),
   !.

write_allreffacts(NoFr, Win, [], [], [], []):-!.
write_allreffacts(NoFr, Win,[Type-Id-Sn|All], NRefs, [NFact|Tops], [RefFact|RefFuncs]):-
   Fact=[NoFr, Type, Id, Sn],
   get_ref_fact(Fact, Sn, NRefs, NFact, Refs),
   (NFact=[]
    ;
    NFact\=[],
   writenl(Win, NFact)), 
   get_ref_func(NoFr, Sn, Id, RefFact),
   (RefFact=[]
    ;
    RefFact\=[],
   writenl(Win, RefFact)), 
   write_allreffacts(NoFr, Win, All, Refs, Tops, RefFuncs),
   !.
write_allreffacts(NoFr, Win,[Type-Id-Sn|All], Refs, Tops, [RefFact|RefFuncs]):-
   get_ref_func(NoFr, Sn, Id, RefFact),
   (RefFact=[]
    ;
    RefFact\=[],
   writenl(Win, RefFact)), 
   write_allreffacts(NoFr, Win, All, Refs, Tops, RefFuncs),
   !.

write_allreffacts(NoFr, Win,[Type-Id-Sn|All], NRefs, Tops, RefFuncs):-
   write_allreffacts(NoFr, Win, All, NRefs, Tops, RefFuncs),
   !.

write_allreffacts(NoFr, Win, All, [Ref|NRefs], Tops, RefFuncs):-
   write_allreffacts(NoFr, Win, All, NRefs, Tops, RefFuncs),
   !.

find_det(Det,be):-
   auxsbe(Det).
find_det(Det,have):-
   auxshave(Det).
find_det(Det,Head):-
   contr(Det, Cat, _, Base),
   contractions(Cat, Base, Head).
find_det(Det,Base):-
   check_basem(Det, Base).

write_auxs([], [], []):-!.
write_auxs([], Rels, []):-!.
write_auxs([Cl-Id|RelIds], [VRels|Rels], [Pred|Preds]):-
     fact(Id, Pred, Args, Pol, T, P),
     on(VRel, VRels),
     VRel=refs(_, ClId, SId, Funct, Words, Cost),
     write_aux(Pred,Words),
     write_auxs(RelIds, Rels, Preds),
     !.
write_auxs([Cl-Id|RelIds], Rels, Preds):-
     write_auxs(RelIds, Rels, Preds),
     !.

write_detmods([], [], []):-!.
write_detmods([], [Ref|Refs], []):-!.
write_detmods([Top|Tops], [Ref|Refs], [SId-Head|Heads]):-
     Top=top(_, TopT, SId, SnX, Head, Tab, P, G, N, Cat, Func/Rol),
     Ref=refs(_, SId, Funct, Word, Cost),
     write_dets(Head, Cost),
     write_detmods(Tops, Refs, Heads),
     !. 
write_detmods([Top|Tops], Refs, [SId-Head|Heads]):-
     Top=top(_, TopT, SId, SnX, Head, Tab, P, G, N, Cat, Func/Rol),
     remove(refs(_, SId, Funct, Word, Cost),Refs,Refs1),
     write_dets(Head, Cost),
     write_detmods(Tops, Refs1, Heads),
     !. 
write_detmods([Top|Tops], [Ref|Refs], [SId-Head|Heads]):-
     write_detmods(Tops, Refs, Heads),
     !. 
write_aux(Head, Cost):-
     Cost\=[A],
     write_sentence_number,
     remove(Det,Cost,Cost1),
     write('aux'),
     write( '  - '),
     write(Head),
     write('  '),
     find_det(Det,Aux),
     write(Aux),
     writenl(')'),
     write_aux(Head, Cost1),
     !.
write_aux(Head, Cost).
write_dets(Head, Cost):-
     Cost\=[A],
     remove(Det,Cost,Cost1),
     writedets(Head, Det),
     write_dets(Head, Cost1),
     !.
write_dets(Head, Cost).

writedets(Head, Det):-
     Head\=Det,
     write_sentence_number,     
     write('detmod'),
     write( '  - '),
     write(Head),
     write('  '),
     write(Det),
     writenl(')'),
     !.
writedets(Head, Head).

info_evaluation(NoFr) :-
   prop_roots(Nodes),
   nl,
   props_info_eval(Nodes, NoFr, _) .

info_evaluation(NoFr) :-!.

props_info_eval([], _, _) :-
   !.
props_info_eval([Node-FunRole | Nodes], NoFr, OldClause) :-
   info_eval(infon(OldClause, NewClause),
      NoFr, Node, FunRole, 
      View, Intens, Change, Rel, 
      VerbCat, Verb, 
       TempRel, DiscRel, DiscDom, SubjConsc),
   asserta(
      info(
         NoFr, Node, FunRole, 
         View, Intens, Change, Rel, 
         VerbCat, Verb,
         TempRel, DiscRel, DiscDom, SubjConsc)),
   write_info_eval(NoFr, Node),
   nl,
   nl,
   props_info_eval(Nodes, NoFr, OldClause).

props_info_eval([Node-ip_ell/prop], NoFr, OldClause) :-
   PrecNoFr is NoFr - 1,
   info(PrecNoFr, N, FunRole, View, Intens,
     Change, Rel, _, _, TempRel, DiscRel, DiscDom, SC),
   asserta(
      info(
         NoFr, Node, FunRole, 
         View, Intens, Change, Rel, 
         VerbCat, Verb,
         TempRel, DiscRel, DiscDom, SubjConsc)),
   write_info_eval(NoFr, Node),
   !.

props_info_eval([Nodo-Fun/prop | Nodes], NoFr, OldClause) :-
   nodo(Nodo)::_::nodo(N1),
   props_info_eval([N1-Fun/prop | Nodes], NoFr, OldClause).

props_info_eval([Node-FunRole | Nodes], NoFr, OldClause) :-
   props_info_eval(Nodes, NoFr, OldClause).

write_info_eval(NoFr, Node) :-
   info(NoFr, Node, FunRole, View, Intens,
     Change, Rel, _, _, TempRel, DiscRel, DiscDom, SC),
   write('CLAUSE IDENTIFIER:               '),
   writenl(NoFr-Node),
   write('CLAUSE TYPE:                     '),
   writenl(FunRole),
/*   write('POINT OF VIEW:                   '),
   writenl(View),
*/
   write('FACTUALITY:                      '),
   writenl(Intens),
   write('CHANGE IN THE WORLD:             '),
   writenl(Change),
   write('RELEVANCE:                       '),
   writenl(Rel),
   write('TEMPORAL RELATION:               '),
   writenl(TempRel),
   write('DISCOURSE FOCUS:                 '),
   find_time_focus(DiscFoc),
   writenl(DiscFoc),
   write('DISCOURSE RELATION:              '),
   writenl(DiscRel),
   write('DISCOURSE DOMAIN:                '),
   writenl(DiscDom),
   write_subject_of_consciousness(SC),
   !.
write_info_eval(_, _).

write_subject_of_consciousness(sc(NoFr, Index, Pred)) :-
   !,
   write('SUBJECT OF CONSCIOUSNESS:        '),
   writeseqnl(_,[Pred/Index, from, NoFr]), nl.

write_subject_of_consciousness(nil) :-
   !,
   write('SUBJECT OF CONSCIOUSNESS:        '),
   writenl(none), nl.

find_time_focus(tes(TimeInd)) :-
time_focus(StackNo, tes(TimeInd)).

/*************
relations(-RelForm)
== Calcola la forma logica del grafo corrente e la converte in forma relazionale
*************/
relations(LogicForm, RelForm) :-
   xlate(n1,LogicForm),
   convert_lf(LogicForm, RelForm),
   nl,nl,
   writenl(user,'######################  LOGICAL FORM ###############'),
   ppin(LogicForm),
   nl,nl,
   !.
  
relations(LogicForm, RelForm) :-
   prop_roots(Inds),
   Inds\=[],
   on(N-_,Inds),
   xlate(N,LogicForm),
   convert_lf(LogicForm, RelForm).

/******************
switch_polarity(+Polarity, -SwitchedPolarity)
******************/
switch_polarity(0, 1).
switch_polarity(1, 0).

/*************
convert_lf(+LogicForm, -RelForm)
:- spy convert_lf
*************/

convert_lf([], []) :-
   !.

/* situation con polarit negativa */

convert_lf(wff(situation, [wff(not,Wff)]), NotSit) :-
   convert_lf(wff(situation, Wff), Sit),
   Sit=..[Func, Quant, EvId, essere, Args, Restr, Pol],
   Args=[ind(A1,B1,C1,D1),infon(A,B,C,D,E,Pol)],
   switch_polarity(Pol, NotPol),
   NotArgs=[ind(A1,B1,C1,D1),infon(A,B,C,D,E,NotPol)],
   NotSit=..[Func, Quant, EvId, essere, NotArgs, Restr, NotPol],
   !.

convert_lf(wff(situation, [wff(not,Wff)]), NotSit) :-
   convert_lf(wff(situation, Wff), Sit),
   Sit=..[Func, Quant, EvId, Rel, Args, Restr, Pol],
   switch_polarity(Pol, NotPol),
   NotSit=..[Func, Quant, EvId, Rel, Args, Restr, NotPol],
   !.

/* situation con distribuzione della relazione su una congiunzione di argomenti proposizionali*/

convert_lf(wff(situation, [wff(Rel, Args)]), and([Sit1, Sit2])) :-
   on(wff(and, [Arg1, Arg2]), Args),
   functor(Arg1, wff, 2),
   functor(Arg2, wff, 2),
   !,
   replace_any(wff(and, [Arg1, Arg2]), Arg1, Args, Args1),
   convert_lf(wff(situation, [wff(Rel, Args1)]), Sit1),
   replace_any(wff(and, [Arg1, Arg2]), Arg2, Args, Args2),
   convert_lf(wff(situation, [wff(Rel, Args2)]), Sit2).


/* situation  */

convert_lf(wff(situation, [wff(Rel, Args)]), Sit) :-
   convert_args(Args, Rel, Args2, NewRel, PredNode, Event),
   conv_event(Event, sit, NewRel, PredNode, Args2, 1, Sit), 
   !.

/* l'informazione di isola viene eliminata */

convert_lf(wff(isola, [Wff]), ConvWff) :-
   convert_lf(Wff, ConvWff),
   !.

/* wff che non ha un corrispondente diretto nella F-Struttura */
convert_lf(wff(isa, [Ind, Class | Rest]), Infon ) :-
   convert_args(
      [Ind | Rest], isa,  [ConvInd| ConvRest], 
      NewRel, PredNode, Event),
   conv_event(
      Event, infon, NewRel, PredNode, 
      [ConvInd, Class | ConvRest], 1, Infon),
   !.


/* and */
convert_lf(wff(and, Args),  and(ConvArgs) ) :-
   convert_lf(Args, ConvArgs),
   !.

/* wff che non  una situation e ha polarit negativa */
convert_lf(wff(not, Arg), Infon0 ) :-
   convert_lf(Arg, Infon),
   Infon=..[Func, Rel, Args, _],
   Infon0=..[Func, Rel, Args, 0],
   !.

/* wff che non  una situation */
convert_lf(wff(antecedente, Args), Infon ) :-
   on(Arg, Args),
   convert_args(Arg, antecedente, ConvArgs, NewRel, PredNode, Event),
   conv_event(Event, infon, NewRel, PredNode, ConvArgs, 1, Infon),
   !.

convert_lf(wff(Rel, Args), Infon ) :-
   convert_args(Args, Rel, ConvArgs, NewRel, PredNode, Event),
   conv_event(Event, infon, NewRel, PredNode, ConvArgs, 1, Infon),
   !.

convert_lf([], []) :-
   !.

/* congiunzione di situazioni ; argomenti proposizionali */
convert_lf([A | B], [ConvA | ConvB]) :-
   convert_lf(A, ConvA),
   convert_lf(B, ConvB),
   !.

/* Individui */
convert_lf(SnX, Ind) :-
   atomic(SnX),
   frase_corrente(NoFr, _),
   conv_sn_index(NoFr, SnX, Ind),
   !.

convert_lf(Lf, Lf) :-
   nl,
   writeseq(user, ['Non  stato possibile convertire:', Lf]),
   nl.


/****************
convert_args(+lfTerms, +rel, -relInds, -newRel, -event)
== Conversione di una lista di argomenti. Viene estratto il termine che rappresenta l'evento
*************/

/* Se NewRel non  stata gi istanziata viene presa la vecchia */
convert_args([], Rel, [], Rel, _, []) :-
   !.

convert_args([], _, [], _, _, []) :-
   !.

/* L'informazione di focus viene "abbassata" */
convert_args(
   [wff(focus, [term(Q, SnX, Wff)]) | Terms],
   Rel, 
   Inds,
   NewRel,
   PredNode,
   SitVar) 
   :-
   !,
   convert_args(
      [term(Q, SnX, wff(and,[wff(focus, [SnX]), Wff])) 
      | Terms],
      Rel,  Inds, NewRel, PredNode, SitVar).

/* Gli argomenti form vengono eliminati 
convert_args(
   [term(_, Var, _) | Terms], Rel,
   ConvTerms, NewRel, PredNode,
   SitVar) 
   :-
   rel_role(Var, Rel, form, NewRel, PredNode),
   !,
   convert_args(Terms, Rel, ConvTerms, NewRel, PredNode, SitVar).
*/

/* Termine set: viene aggiunta l'informazione sul Ruolo  */
convert_args(
   [term(set, Var, Inds) | Terms], Rel, 
   [ind(set, ConvVar, ConvInds, Role) | ConvTerms], NewRel, PredNode,
   SitVar) 
   :-
   convert_args(Inds, Rel, ConvInds, NewRel, PredNode, _),
   rel_role(Var, Rel, Role, NewRel, PredNode),
   convert_lf(Var, ConvVar), 
   convert_args(Terms, Rel, ConvTerms, NewRel, PredNode, SitVar),
   !.


/* Argomento con quantificatore in [event, state];  un argomento aggiunto che va trattato come modificatore dell'evento */
convert_args(
   [term(Quant, FrX, Restr) | Terms], Rel, 
   Inds, NewRel, PredNode,
   [Quant, IdEv, ConvRestr]) 
   :-
   on(Quant, [event, state, process]),
   !,
   frase_corrente(NoFr, _),
   conv_sn_index(NoFr, FrX, IdEv),
   land_to_list(Restr, Restr1),
   convert_lf(Restr1, ConvRestr),
   convert_args(Terms, Rel, Inds, NewRel, PredNode, []),
   !.


/* Termine individuo: viene aggiunta l'informazione sul Ruolo  */
convert_args(
   [term(Quant, Var, Restr) | Terms], Rel, 
   [ind(Quant, ConvVar, Restr3, Role) | ConvTerms], NewRel, PredNode,
   SitVar) 
   :-
   land_to_list(Restr, Restr1),
   conv_control(Var, Restr1, CtrVar, Restr2),
   convert_lf(Restr2, Restr3),
   rel_role(Var, Rel, Role, NewRel, PredNode),
   convert_lf(CtrVar, ConvVar), 
   convert_args(Terms, Rel, ConvTerms, NewRel, PredNode, SitVar),
   !.

/* Termine non individuale oppure atomico (non riceve il ruolo) */
convert_args(
   [Wff | Terms], Rel, 
   [ConvWff| ConvTerms], NewRel, PredNode,
   SitVar) 
   :-
   convert_lf(Wff, ConvWff),
   convert_args(Terms, Rel, ConvTerms, NewRel, PredNode, SitVar),
   !.


/****************
conv_event(
   +Restrictions, +Type, +Rel, +predNode, +Args, +Pol, 
   -EventDescription)
****************/

conv_event([], Func, Rel, PredNode, Args, Pol, Role:Infon) :-
   adj_role(Rel, PredNode, Role),
   !,
   gen_sym(infon, EvId),
   Infon=..[Func, att, EvId, Rel, Args, [], Pol].

conv_event([], Func, Rel, PredNode, Args, Pol, Infon) :-
   !,
   gen_sym(infon, EvId),
   Infon=..[Func, att, EvId, Rel, Args, [], Pol].

conv_event(
   [Quant, EvId, Restr], Func, Rel, PredNode, [Ogg], Pol, 
   Role:Infon) 
   :-
   asserted_ind(SnX, Ogg),
   adj_role(SnX, PredNode, Role),
   !,
   Infon=..[Func, Quant, EvId, Rel, [Ogg], Restr, Pol].

conv_event(
   [Quant, EvId, Restr], Func, Rel, PredNode, Args, Pol, 
   Infon) 
   :-
   !,
   Infon=..[Func, Quant, EvId, Rel, Args, Restr, Pol].



/***************
conv_control(+SnIn, +RestrIn,  -SnOut, -RestrOut)
== Tratta i sintagmi con antecedente o controllore (l'informazione relativa  contenuta tra le restrizioni)
***************/

/* 
Una restrizione singola viene normalizzata a and() 
*/
conv_control(Var, wff(Head, Restr),  ConVar, Out) :-
   Head \= and,
   !,
   conv_control(
      Var, wff(and,[wff(Head, Restr)]),  ConVar, Out).

/* 
L'antecedente esterno viene eliminato dalle restrizioni 
*/
conv_control(Var, wff(and, Restr),  Var, wff(and, Out)) :-
   remove(wff(antecedente, [SnX, esterno]), Restr, Out),
   !.
   
/* 
Se il sintagma ha un antecedente interno, risale la catena di controllo e rimuove la restrizione su pro
*/
conv_control(_, wff(and, Restr),  [SnZ,SnW], wff(and, Restr2)) :-
   remove(wff(antecedente, [Anaf, [SnY, SnX]]), Restr, Restr1),
   Anaf \= SnY,
   segui_catena_di_controllo1(SnY, SnZ),
   Anaf \= SnX,
   segui_catena_di_controllo1(SnX, SnW),
   remove_pro(Restr1, Restr2),
   !.
   
conv_control(_, wff(and, Restr),  SnZ, wff(and, Restr2)) :-
   remove(wff(antecedente, [Anaf, SnY]), Restr, Restr1),
   Anaf \= SnY,
   segui_catena_di_controllo1(SnY, SnZ),
   remove_pro(Restr1, Restr2),
   !.

/*
Se il sintagma ha un un controllore risale la catena di controllo e rimuove la restrizione su pro 
*/
conv_control(_, wff(and, Restr),  SnZ, wff(and, Restr2)) :-
   remove(wff(controllore, [Anaf, SnY]), Restr, Restr1),
   Anaf \= SnY,
   segui_catena_di_controllo1(SnY, SnZ),
   remove_pro(Restr1, Restr2),
   !.
   
conv_control(Var, InOut, Var, InOut) . 



remove_pro([Restr | OtherRestrs], OtherRestrs). 


/***************
conv_quant(+Args, -ConvArgs)
== Tratta ciascuno
***************/
conv_quant(Args, ConvArgs) :-
   on(Quant, [ciascuno,ciascuna,all,ognuno,each,tutti]),
   remove(wff(Quant, [_, Term]), Args, Args1),
   Term=term(_, _, wff(isa, [_, Quant, Term1])),
   Term1=term(_, _, wff(and, Restr)),
   on(wff(controllore, [_, Ante]), Restr),
   raise_quant(Args1, Quant, Ante, ConvArgs),
   !.
conv_quant(Args, Args) .


raise_quant(
   [term(_, Ante, Restr) | Terms], 
   Quant, Ante, 
   [term(Quant, Ante, Restr) | Terms]) 
   :-
   !.

raise_quant(
   [Term | Terms], 
   Quant, Ante, 
   [Term | ConvTerms]) 
   :-
   raise_quant(Terms, Quant, Ante, ConvTerms),
   !.

raise_quant([], _, _, []) .
  

/*****************
conv_sn_index(+NoFrase, +SnIndex, -IndIndex)
== Conversione da Sintagma a Individuo. Se al sintagma non  gi stato associato un individuo ne viene creato uno. Il nuovo individuo vien asserito nella partizione new_ind/1
*****************/
conv_sn_index(_, SnX, Ind) :-
   asserted_ind(SnX, Ind),
   nonvar(Ind),
   !.

conv_sn_index(NoFr, SnX, Ind) :-
   gen_sym(id, Ind),
   assert(confer_ind(NoFr, SnX, Ind)),
   assert(new_ind(Ind)).


 
/***************
asserted_ind(+SnIndex, -IndIndex)
== Controlla se a un certo sintagma  gi stato associato un individuo. Viene consultata dapprima la partizione confer_topic creata dinamicamente durante l'analisi del discorso e contenente la lista dei topic; se il sintagma non  tra i topic viene consultata la partizione confer_ind che invece viene creata durante la conversione dalla forma logica alla forma relazionale
****************/

asserted_ind(SnX, Ind) :-
  frase_corrente(NoFr, _),
  confer_topic(NoFr, _, Ind, SnX, _),
  !.
   
asserted_ind(SnX, Ind) :-
  frase_corrente(NoFr, _),
  confer_ind(NoFr, SnX, Ind).
   

/*******
rel_role(+snIndex, +pred, -newRole, -newPred)
Accessi al grafo
rel_role(SnX, Pred, form, _, _) :-
   nodo(Node)::_/form::indice::SnX,
   !.
*******/

rel_role(SnX, Pred, NewRole, NewPred, Node) :-
   nodo(Node)::_/Role::indice::SnX,
   !,
   role_map(Node, Pred, Role, NewPred, NewRole).

/* coordinazione di vcomp */
rel_role(SnX, Pred, NewRole, NewPred, Node) :-
   nodo(Node)::coordina::_/Role::indice::SnX,
   !,
   role_map(Node, Pred, Role, NewPred, NewRole).


/* coordinazione di sn o sp */
rel_role(SnX, Pred, NewRole, NewPred, Node) :-
   nodo(Node)::_/Role::coordina::_/Role::indice::SnX,
   !,
   role_map(Node, Pred, Role, NewPred, NewRole).


rel_role(SnX, Pred, NewRole, NewPred, Node) :-
   nodo(Node)::focus::indice::SnX,
   nodo(Node)::_/Role::controllore::SnX,
   !,
   role_map(Node, Pred, Role, NewPred, NewRole).

rel_role(SnX, Pred, NewRole, NewPred, Node) :-
   nodo(Node)::focus::sn_int::indice::SnX,
   nodo(Node)::_/Role::controllore::SnX,
   !,
   role_map(Node, Pred, Role, NewPred, NewRole).

rel_role(SnX, be, Role, be, Node):-Role=tema_bound;Role=theme_bound.

rel_role(SnX, time, arg, time, Node).

rel_role(SnX, Pred, _, Pred, _).

/*
rel_role(SnX, Pred, Role, Pred, Node) :-
   nodo(_)::_/Role::indice::SnX.
*/
adj_role(Rel, PredNode, Role) :-
   nodo(PredNode)::adjs::adj/Role::sem_mark::Rel.

adj_role(Rel, PredNode, Role) :-
   nodo(PredNode)::adj/Role::sem_mark::Rel.

/*
adj_role(Rel, PredNode, Role) :-
   nodo(PredNode)::adjs::avv::adj/Role::pred::Rel.
*/

supporter_cat(Rel, Cat) :-
   nodo(Nodo)::vcomp/Prop::pred::Rel,
   nodo(Nodo)::cat::Cat.

/********
idomatic_roles(
   +pred, -interpreted_pred, 
   -reinterpretedRoles, -properRoles, -forms, -functionForms).
idomatic_roles(
   essere, esserci,
   [Role=Role], [], [ci], []):-Role=tema_bound;Role=theme_bound.

idomatic_roles(
   leccare, leccarsi_i_baffi,
   [agente=esperiente], [], [], [ogg, ogg2]).

idomatic_roles(
   have, have_regard,
   [esperiente=subj_disc], [], [], [ogg]).

idomatic_roles(
   avere, avere_alle_calcagna,
   [], [], [], [ogg]).
*********/
  
/********
 role_map(+node, +oldRole, -newPred, -newRole).
 Un ruolo viene mappato in un altro sulla base dell'informazione contenuta nella partizione idomatic_roles/6. Per identificare la relazione viene fatto solo un controllo di coerenza, non di completezza (i.e. non si controlla che ci siano altri ruoli oltre a quelli previsti). 
role_map(Node, Pred, OldRole, NewPred, NewRole) :-
   nodo(Node)::pred::Pred,
   idomatic_roles(
      Pred, NewPred, IntRoles, ProperRoles, Forms, FuncsForm),
   remove(OldRole=NewRole, IntRoles, IntRoles1),
   forall(
      nogen_member(Role=_, IntRoles1),
      nodo(Node)::_/Role::nodo(_)),
   forall(
      nogen_member(Role, ProperRoles),
      nodo(Node)::_/Role::nodo(_)),
   forall(
      nogen_member(Form, Forms),
      (
      nodo(Node)::form::Form
      ;
      nodo(Node)::idiom/form::Form
      )   ),
   forall(
      nogen_member(FuncForm, FuncsForm),
      nodo(Node)::FuncForm/form::nodo(_)),
   assert(new_pred(NewPred)),
   !.
*********/

role_map(Node, Pred,  Role, Pred, Role) :-
   nodo(Node)::pred::Pred,
   !.
role_map(_, Pred,  Role, Pred, Role).



/******************
main_location(+NFrase, +CatSem, +Role, +RefList, -LocInd)
== Side Effect: viene asserita la current_main_loc
main_location(NoFr, CatSem, Role, RefList, univ) :-
   genre(legal),
   !.
******************/

main_location(NoFr, CatSem, Role, RefList, Id) :-
   nonvar(Id),
   !.

main_location(NoFr, CatSem, Role, RefList, Id) :-
   main_loc_dei(RefList, CatSem, Role, Ref),
   !,
   confirm_location(NoFr, CatSem, Id).

main_location(NoFr, luogo, Role, RefList, Id) :-
   (F=adj;F=obl),(R=locativo;R=locat),
   nodo(N)::F/R::sem_mark::Sem,
   nodo(N)::F/R::pred::Pred1,
   trova_controllore_antecedente(Pred1,N1,Pred),
   nodo(N)::F/R::cat::Cat,
   (on(luogo,Cat);
   on(place,Cat)),
   \+ infer_locspace(NoFr, luogo, Pred, NewRef, _),
   !,
   gen_sym(infon, Infon),
   gen_sym(id, Id),
   Fact= loc(Infon, Id, [arg:main_sloc, arg:Pred]),
   assert(Fact),
   assert(confer_infon(Infon, NoFr, nil, nil, location)),
   NewRef=..[ref_ex, Id , Pred],
   retractall(current_main_loc(_, luogo, _)),
   assert(current_main_loc(NoFr, luogo, NewRef)).

main_location(NoFr, tempo, Role, RefList, Id) :-
   (F=adj;F=obl),(R=temporale;R=temp),
   nodo(N)::F/R::sem_mark::Sem,
   nodo(N)::F/R::pred::Pred1,
   trova_controllore_antecedente(Pred1,N1,Pred),
   nodo(N)::F/R::cat::Cat,
   \+ infer_locspace(NoFr, luogo, Pred, NewRef, _),
   !,
   gen_sym(infon, Infon),
   gen_sym(id, Id),
   Fact= loc(Infon, Id, [arg:main_tloc, arg:Pred]),
   assert(Fact),
   assert(confer_infon(Infon, NoFr, nil, nil, location)),
   NewRef=..[ref_ex, Id , Pred],
   retractall(current_main_loc(_, tempo, _)),
   assert(current_main_loc(NoFr, tempo, NewRef)),
   !.

main_location(NoFr, luogo, Role, RefList, Id) :-
   (F=adj;F=obl),(R=locativo;R=locat),
   nodo(N)::F/R::sem_mark::Sem,
   nodo(N)::F/R::nodo(N1),
   nodo(N1)::ogg/_::pred::Pred1,
   trova_controllore_antecedente(Pred1,N1,Pred),
   nodo(N1)::ogg/_::cat::Cat,
   (on(luogo,Cat);
   on(place,Cat)),
   \+ infer_locspace(NoFr, luogo, Pred1, NewRef, _),
   !,
   gen_sym(infon, Infon),
   gen_sym(id, Id),
   Fact= loc(Infon, Id, [arg:main_sloc, arg:Pred]),
   assert(Fact),
   assert(confer_infon(Infon, NoFr, nil, nil, location)),
   NewRef=..[ref_ex, Id , Pred],
   retractall(current_main_loc(_, luogo, _)),
   assert(current_main_loc(NoFr, luogo, NewRef)),
   !.

main_location(NoFr, luogo, Role, RefList, Id) :-
   (F=adj;F=obl),(R=locativo;R=locat),
   nodo(N)::F/R::nodo(N1),
   nodo(N1)::pred::Pred,
   \+ infer_locspace(NoFr, luogo, Pred, NewRef, _),
   !,
   gen_sym(infon, Infon),
   gen_sym(id, Id),
   Fact= loc(Infon, Id, [arg:main_sloc, arg:Pred]),
   assert(Fact),
   assert(confer_infon(Infon, NoFr, nil, nil, location)),
   NewRef=..[ref_ex, Id , Pred],
   retractall(current_main_loc(_, luogo, _)),
   assert(current_main_loc(NoFr, luogo, NewRef)),
   !.

main_location(NoFr, tempo, Role, RefList, Id) :-
   (F=adj;F=obl;F=pcomp),(R=temporale;R=temp),
   nodo(N)::F/R::sem_mark::Sem,
   nodo(N)::F/R::nodo(N1),
   (nodo(N1)::ogg/_::pred::Pred3,
   nodo(N1)::ogg/_::cat::Cat
   ;
   nodo(N1)::ogg/_::indice::I,
   nodo(N4)::coordina::testa::coordinante,
   nodo(N2)::ogg/_::pred::Pred1, N2\=N1,
   nodo(N2)::ogg/_::pred::Pred2, Pred2\=Pred1,
   mcon(Pred1,'_',M1),
   mcon(M1,Pred2,Pred3)
   ),   
   trova_controllore_antecedente(Pred3,N1,Pred),
   \+ infer_locspace(NoFr, luogo, Pred, NewRef, _),
   !,
   gen_sym(infon, Infon),
   gen_sym(id, Id),
   Fact= loc(Infon, Id, [arg:main_tloc, arg:Pred]),
   assert(Fact),
   assert(confer_infon(Infon, NoFr, nil, nil, location)),
   NewRef=..[ref_ex, Id , Pred],
   retractall(current_main_loc(_, tempo, _)),
   assert(current_main_loc(NoFr, tempo, NewRef)),
   !.

main_location(NoFr, luogo, locativo, RefList, Id) :-
   main_loc_infer(NoFr, RefList, luogo, locativo, Pred, NewRef),
   infer_loc_space(NoFr, luogo, Pred, NewRef, Id),
   !.

main_location(NoFr, tempo, temporale, RefList, Id) :-
   main_loc_infer_temp(NoFr, RefList, tempo, temporale, Pred, Ref),
   infer_loc_temp(NoFr, tempo, Ref, Id),
   !.

main_location(NoFr, tempo, _, _, Id) :-
   main_loc_avv(Ref),
   !,
   gen_sym(infon, Infon),
   gen_sym(id, Id),
   Fact= loc(Infon, Id, [arg:main_tloc, arg:Ref]),
   assert(Fact),
   assert(confer_infon(Infon, NoFr, nil, nil, location)),
   NewRef=..[ref_ex, Id , Ref],
   retractall(current_main_loc(_, tempo, _)),
   assert(current_main_loc(NoFr, tempo, NewRef)),
   !.

main_location(NoFr, CatSem, Role, RefList, Id) :-
   main_loc(RefList, CatSem, Role, Ref),
%   !,
   (
   (NoFr=1;NoFr=2)
   ->     
   generate_location(NoFr, CatSem, Ref, Id)
   ;
   CatSem=tempo
   ->
   generate_location(NoFr, CatSem, Ref, Id)
   ;
   CatSem=luogo,
   match_locations(NoFr, CatSem, Ref, Id)
   ),
   !.

main_location(NoFr, tempo, _, _, Id) :-
   main_loc_int(NoFr,Ref),
   !,
   gen_sym(infon, Infon),
   gen_sym(id, Id),
   Fact= loc(Infon, Id, [arg:main_tloc, arg:Ref]),
   assert(Fact),
   assert(confer_infon(Infon, NoFr, nil, nil, location)),
   NewRef=..[ref_ex, Id , Ref],
   retractall(current_main_loc(_, tempo, _)),
   assert(current_main_loc(NoFr, tempo, NewRef)),
   !.

main_location(NoFr, CatSem, _, _, Id) :-
   confirm_location(NoFr, CatSem, Id),
   !.


trova_controllore_antecedente(Pred,N1,Pred):-Pred\=vbl,!.
trova_controllore_antecedente(vbl,N1,Pred):-
   nodo(N1)::controllore::Ind,
   nodo(N)::indice::Ind,
   nodo(N)::pred::Pred,
   !.
trova_controllore_antecedente(vbl,N1,Pred):-
   nodo(N2)::controllore::Ind,
   nodo(N)::indice::Ind,
   nodo(N)::pred::Pred,
   !.

generate_location(NoFr, CatSem, Ref, Id):-
   cat_sem_to_class(CatSem, Class),
   Ref=..[ref_ex, SnX | RestRef],
   conv_sn_index(NoFr, SnX, Id),
   arg(2, Ref, Pred),
   Fact=loc(Id, [arg:Class, arg:Pred]),
   asserisci(NoFr, SnX, Fact),
   NewRef=..[ref_ex, Id | RestRef],
%   retractall(current_main_loc(_, CatSem, _)),
   assert(current_main_loc(NoFr, CatSem, NewRef)).

match_locations(NoFr, CatSem, Ref, Id):-
    PrecNoFr is NoFr - 1,
    current_main_loc(PrecNoFr, CatSem, PrecLoc),
    arg(1, Ref, Id1),   
    arg(2, Ref, Pred),   
    (
     PrecLoc=ref_ex(univ), Pred2=univ
     ;
     arg(2, PrecLoc, Pred2)),
    (Pred\=Pred2,
     generate_location(NoFr, CatSem, Ref, Id)
    ;
     confirm_location(NoFr, CatSem, Id)
    ).

cat_sem_to_class(tempo, main_tloc). 
cat_sem_to_class(luogo, main_sloc). 
   
infer_locspace(NoFr, CatSem, Pred, NewRef, Id1) :-
   PrecNoFr is NoFr - 1,
   current_main_loc(PrecNoFr, CatSem, PrecLoc),
   arg(1, PrecLoc, Id),   
   arg(2, PrecLoc, Pred2),
   (
      (
      check_topics(NoFr, Pred, Pred, Id1)
      ;
      compare_loc(Pred, Pred2, Id, Id1)
      ),
     (
     var(Id1),
     NewLoc=PrecLoc   
     ;
     nonvar(Id1), 
     NewRef=ref_ex(I,Loc,Tab,Pers,Gen,Num,Cat,F/R),
     NewLoc=ref_ex(Id1,Loc,Tab,Pers,Gen,Num,Cat,F/R)   
     )
   ;
    included(Pred,Pred2), 
    Id1=Id, 
    NewLoc=PrecLoc   
   ;
    infer_generic_location(Pred, Pred2),
    Id1=Id,
    NewLoc=PrecLoc   
   ;
    check_locations(PrecNoFr, Pred, Id1), 
    NewRef=ref_ex(I,Loc,Tab,Pers,Gen,Num,Cat,F/R),
    NewLoc=ref_ex(Id1,Loc,Tab,Pers,Gen,Num,Cat,F/R)   
   ).


confirm_location(NoFr, luogo, Id) :-
   PrecNoFr is NoFr - 1,
   current_main_loc(PrecNoFr, luogo, PrecLoc),
   (compare_topics(PrecNoFr, PrecLoc, Id, OldLoc)
    ;
    compare_loc_inf(PrecLoc, Id, OldLoc)),
   assert(current_main_loc(NoFr, luogo, OldLoc)).


confirm_location(NoFr, CatSem, Id) :-
   PrecNoFr is NoFr - 1,
   current_main_loc(PrecNoFr, CatSem, PrecLoc),
   arg(1, PrecLoc, Id),   
   assert(current_main_loc(NoFr, CatSem, PrecLoc)).

confirm_location(NoFr, tempo, Id) :-
   main_loc_int(No,Ref),
   !,
   gen_sym(infon, Infon),
   gen_sym(id, Id),
   Fact= loc(Infon, Id, [arg:main_tloc, arg:Ref]),
   assert(Fact),
   assert(confer_infon(Infon, NoFr, nil, nil, location)),
   NewRef=..[ref_ex, Id , Ref],
   retractall(current_main_loc(_, tempo, _)),
   assert(current_main_loc(NoFr, tempo, NewRef)).

confirm_location(NoFr, tempo, Id) :-
   nodo(_)::ref_int::[Ref],
   !,
   gen_sym(infon, Infon),
   gen_sym(id, Id),
   Fact= loc(Infon, Id, [arg:main_tloc, arg:Ref]),
   assert(Fact),
   assert(confer_infon(Infon, NoFr, nil, nil, location)),
   NewRef=..[ref_ex, Id , Ref],
   retractall(current_main_loc(_, tempo, _)),
   assert(current_main_loc(NoFr, tempo, NewRef)).

confirm_location(NoFr, TempoLuogo, nil) :-!.

infer_loc_space(NoFr, CatSem, Pred, NewRef, Id1) :-
   PrecNoFr is NoFr - 1,
   current_main_loc(PrecNoFr, CatSem, PrecLoc),
   arg(1, PrecLoc, Id),   
   arg(2, PrecLoc, Pred2),
   (
      (
      check_topics(NoFr, Pred, Pred, Id1)
      ;
      compare_loc(Pred, Pred2, Id, Id1)
      ),
     (
     var(Id1),
     NewLoc=PrecLoc   
     ;
     nonvar(Id1), 
     NewRef=ref_ex(I,Loc,Tab,Pers,Gen,Num,Cat,F/R),
     NewLoc=ref_ex(Id1,Loc,Tab,Pers,Gen,Num,Cat,F/R)   
     )
   ;
    included(Pred,Pred2), 
    Id1=Id, 
    NewLoc=PrecLoc   
   ;
    infer_generic_location(Pred, Pred2),
    Id1=Id,
    NewLoc=PrecLoc   
   ;
    check_locations(PrecNoFr, Pred, Id1), 
    NewRef=ref_ex(I,Loc,Tab,Pers,Gen,Num,Cat,F/R),
    NewLoc=ref_ex(Id1,Loc,Tab,Pers,Gen,Num,Cat,F/R)   
   ),
   assert(current_main_loc(NoFr, CatSem, NewLoc)).

infer_generic_location(Pred, Pred2):-
    fact(_, name, [Pred2, Ids], 1, _, _),
    fact(_, isa, [arg:Idss, arg:Pred], 1, _, _),
    fact(_, di, [arg:Idss, specif:Ids], 1, _, _).

/* Pred2  la preceding loc */
compare_loc(Pred, Pred2, Id, Id1):-
  check_topics(_, Pred, Pred2, Id1).   

check_locations(NoFr, Pred, Id):-
   (proposto(ref_ex(_,Tes,_,P,G,N,C,F1/R1))
    ;
    principale(ref_ex(_,Tes,_,P,G,N,C,F1/R1))),
    !,
   (fact(_, poss, [Tes, Id1, Id], 1, Sl, Tl),
    search_dmod(Pred, Id)
    ;   
    recover_location(Id1, Pred, Id),
    search_dmod(Tes, Id1)
    ).

/* Id1  l'id del main topic della frase in cui si ha una stessa locazione, il cui id  Id */
recover_location(Id1, Pred, Id):-
  frase_corrente(NoFr,_),
  PrecNoFr is NoFr - 1,
  more_recent_location(PrecNoFr, Pred, Id1, Id).

more_recent_location(PrecNoFr, Pred, Id, Id2):-
   recency(PrecNoFr, Id, Pred, Id2).

recency(N, Id, Pred, Id1) :-
  1<N,
  topic(N,main,Id),
  current_main_loc(N, CatSem, PrecLoc),
  arg(2, PrecLoc, Pred),
  arg(1, PrecLoc, Id1)
  ;
  1<N,
  N1 is N - 1,
  recency(N1, Id, Pred, Id1).

/* Pred  il locativo */
check_topics(_, Pred, Pred2, _):-
   fact(In, name, [Pred2, _], 1, _, _),
   Pred=Pred2.

/* il proposto o il principale possiedono il Pred */
check_topics(NoFr, Pred, Pred2, Id1):-
   (proposto(ref_ex(_,Tes,_,P,G,N,C,F1/R1))
    ;
    principale(ref_ex(_,Tes,_,P,G,N,C,F1/R1))),
    !,
   fact(In, isa, [_:Idc, _:Pred2], 1, _, _),
   fact(Inf, poss, [Tes, Idp, Idc], 1, _, _),
   (recover_location(Idp, Pred, Id1)
     ;
    var(Id1),
     Id1=Idc
    ).

compare_topics(NoFr, PrecLoc, Id, OldLoc):-
   arg(1, PrecLoc, Ido),   
   arg(2, PrecLoc, Pred2),   
   (proposto(ref_ex(_,Tes,_,P,G,N,C,F1/R1))
    ;
    principale(ref_ex(_,Tes,_,P,G,N,C,F1/R1))),
    !,
   1<NoFr,
   topic(NoFr,Type,Id1),
   (Type=main;Type=expected),
   (fact(In, isa, [_:Id1, _:Tes], 1, _, _)
    ;
    in(_,Id1,Ids),
    fact(In, isa, [_:Ids, _:Tes], 1, _, _)
    ;
   fact(In, name, [Tes, Id1], 1, _, _)
   ),
   (infer_enter_relation(Tes,Id1, Ide),
    nonvar(Ide),
    fact(Inf, isa, [_:Ide, _:Loc], 1, _, _),
    PrecLoc=ref_ex(I,_,_,_,_,_,Cat,F/R),
    GenLoc=ref_ex(Ide,Loc,_,_,_,_,Cat,F/R),   
    OldLoc=GenLoc, Id=Ide
    ;
    var(Ide), Id=Ido,
    OldLoc=PrecLoc).

infer_enter_relation(Tes, Id1, Id):-
   nodo(N)::pred::Pred,
   Pred=fare,
   nodo(N)::vcomp/_::coord::pred::Pred2,
   Pred2=entrare,
   !,
   fact(_, Rel, [agente:Id1, loc_direct:Id], 1, _, _).

/* cerco una location che sia adeguata al mio topic proposto o principale tra quelle precedenti */
compare_loc_inf(PrecLoc, Id1, OldLoc):-
   arg(1, PrecLoc, Id),   
   arg(2, PrecLoc, Pred2),   
   (proposto(ref_ex(_,Tes,_,P,G,N,C,F1/R1))
    ;
    principale(ref_ex(_,Tes,_,P,G,N,C,F1/R1))),
    !,
   infer_from_generic_rel(Tes, Idl),
   (Id\=Idl, Id1=Idl,
   current_main_loc(_, luogo, OldLoc),
   arg(1, OldLoc, Idl)
    ;
   Id1=Id, OldLoc=PrecLoc).

infer_from_generic_rel(Tes, Id):-
   (fact(In, isa, [_:Id1, _:Tes], 1, _, Id)
    ;
    in(_,Id1,Ids),
    fact(In, isa, [_:Ids, _:Tes], 1, _, Id)
    ;
   fact(In, name, [Tes, Id1], 1, _, _),
   fact(In, isa, [_:Id1, _:_], 1, _, Id)
   ),
   !.

infer_loc_temp(NoFr, CatSem, Trs, Id) :-
   Trs=..[Tr,Pred],
   PrecNoFr is NoFr - 1,
   current_main_loc(PrecNoFr, CatSem, PrecLoc),
   arg(1, PrecLoc, Id), 
   arg(2, PrecLoc, Tess),
   Tess=..[Tes,Pred2],
   Pred=Pred2,
   Ref=..[Tr,Pred],
   loc(Infon, Id, [arg:main_tloc, arg:Pred]),
   Fact=..[loc,Infon, Id, [arg:main_tloc, arg:Ref]],
   assert(Fact),
   NewRef=..[ref_ex, Id , Ref],
   retractall(current_main_loc(_, CatSem, _)),
   assert(current_main_loc(NoFr, CatSem, NewRef)).

infer_loc_temp(NoFr, CatSem, Pred, Id1) :-
   PrecNoFr is NoFr - 1,
   current_main_loc(PrecNoFr, CatSem, PrecLoc),
   arg(1, PrecLoc, Id),   
   arg(2, PrecLoc, Pred2),
   infer_temp_loc(NoFr, Pred, MainLoc),
   gen_sym(infon, Infon),
   gen_sym(id, Id1),
   Fact= loc(Infon, Id1, [arg:main_tloc, arg:MainLoc]),
   assert(Fact),
   assert(confer_infon(Infon, NoFr, nil, nil, location)),
   NewRef=..[ref_ex, Id1 , MainLoc],
   retractall(current_main_loc(_, CatSem, _)),
   assert(current_main_loc(NoFr, CatSem, NewRef)).

/* Adverbial location */
main_loc_avv(Ref):-
   nodo(n1)::adjs::avv::pred_avv::Ref,
   nodo(n1)::adjs::avv::tipo::Tipo,
   on(Tipo, [deictic, deittico, clock_cal, temp]).

main_loc_avv(Ref):-
   nodo(n1)::adjs::adv::avv::pred_avv::Ref,
   nodo(n1)::adjs::adv::avv::tipo::Tipo,
   on(Tipo, [deictic, deittico, clock_cal, temp]).

main_loc_avv(Ref):-
   nodo(n1)::adjs::adv::avv::pred_avv::Ref1,
   nodo(n1)::adjs::adv::avv::tipo::Tipo,
   on(Tipo, [temp]),
   nodo(n1)::adjs::adv::intens::int::Int,
   concat(Int, Ref1, Ref).

main_loc_avv(Ref):-
   nodo(n1)::relavv::[TR=Ref].

main_loc_avv(Ref):-
   nodo(n1)::adjs::avv::adj/Tipo::nodo(J),
   nodo(J)::duraz::punt,
   nodo(J)::pred::Ref,
   on(Tipo, [deictic, deittico, clock_cal, temp]).

main_loc_avv(Ref):-
   nodo(n1)::adjs::avv::adj/Tipo::pred::Ref,
   nodo(n1)::adjs::avv::adj/Tipo::Duraz::Dur,
   nodo(n1)::adjs::avv::mod::date::Date,
   on(Tipo, [deictic, deittico, clock_cal, temp]).

main_loc_avv(Ref):-
   nodo(n1)::adjs::avv::adj/Tipo::pred::Ref,
   nodo(n1)::adjs::avv::adj/Tipo::Duraz::Dur,
   on(Tipo, [deictic, deittico, clock_cal, temp]).

main_loc_avv(Ref):-
   nodo(n2)::adjs::avv::pred_avv::Ref,
   nodo(n2)::adjs::avv::tipo::Tipo,
   on(Tipo, [deictic, deittico, clock_cal, temp]).

main_loc_avv(Ref):-
   nodo(n2)::adjs::adv::avv::pred_avv::Ref,
   nodo(n2)::adjs::adv::avv::tipo::Tipo,
   on(Tipo, [deictic, deittico, clock_cal, temp]).

main_loc_avv(Ref):-
   nodo(n2)::adjs::adv::avv::pred_avv::Ref1,
   nodo(n2)::adjs::adv::avv::tipo::Tipo,
   on(Tipo, [temp]),
   nodo(n2)::adjs::adv::intens::int::Int,
   concat(Int, Ref1, Ref).

main_loc_avv(Ref):-
   nodo(n2)::relavv::[TR=Ref].

main_loc_avv(Ref):-
   nodo(n2)::adjs::avv::adj/Tipo::nodo(J),
   nodo(J)::duraz::punt,
   nodo(J)::pred::Ref,
   nodo(n2)::adjs::avv::mod::date::Date,
   on(Tipo, [deictic, deittico, clock_cal, temp]).

main_loc_avv(Ref):-
   nodo(n2)::adjs::avv::adj/Tipo::pred::Ref,
   nodo(n2)::adjs::avv::adj/Tipo::duraz::Dur,
   nodo(n2)::adjs::avv::mod::date::Date,
   on(Tipo, [deictic, deittico, clock_cal, temp]).

main_loc_avv(Ref):-
   nodo(n2)::adjs::avv::adj/Tipo::pred::Ref,
   nodo(n2)::adjs::avv::adj/Tipo::Duraz::Dur,
   on(Tipo, [deictic, deittico, clock_cal, temp]).
/*************
main_loc_dei(+ReferentsList, +SemCat, +Role, -Ref, -Ind)
== Deictic location
*************/
main_loc_dei(RefList, Cat, Role, Ref):-
   on(Ref/_, RefList),
   arg(1, Ref, Ind),
   arg(7, Ref, CatSem),
   nogen_member(Cat, CatSem),
   arg(8, Ref, _/RoleR),
   !,
   Role=RoleR,
   nodo(N)::indice::Ind,
   nodo(N)::mods::mod_d::nodo(N1),
   !.
/*************
main_loc_infer(+ReferentsList, +SemCat, +Role, -Ref, -Ind)
== Inferred location = a corner is included in a restaurant
*************/
main_loc_infer(_, RefList, _, locativo, Pred, Ref):-
   on(Ref/_, RefList),
   arg(1, Ref, Ind),
   arg(2, Ref, Pred),
   arg(7, Ref, CatSem),
   nonvar(CatSem),
   notmembro(body_part, CatSem),
   notmembro(umano, CatSem),
   (arg(8, Ref, _/locativo);
   arg(8, Ref, _/locat)),
   Pred\=dentro.

main_loc_infer(_, RefList, luogo, _, Pred, Ref):-
   on(Ref/_, RefList),
   arg(1, Ref, Ind),
   arg(2, Ref, Pred),
   arg(7, Ref, CatSem),
   nonvar(CatSem),
   notmembro(body_part, CatSem),
   notmembro(umano, CatSem),
   membro(luogo, CatSem),
   arg(8, Ref, ogg/goal),
   Pred\=dentro.

main_loc_infer(_, RefList, luogo, _, Pred, Ref):-
   on(Ref/_, RefList),
   arg(1, Ref, Ind),
   arg(2, Ref, Pred),
   (arg(8, Ref, _/locativo);
   arg(8, Ref, _/locat);
   arg(8, Ref, ogg/nil)),
   Pred\=dentro.

main_loc_infer(_, RefList, tempo, _, Pred, Ref):-
   on(Ref/_, RefList),
   arg(1, Ref, Ind),
   arg(2, Ref, Pred),
   (arg(8, Ref, _/temporale);
   arg(8, Ref, _/temp);
   arg(8, Ref, ogg/nil)).

/*************
main_loc_infer_temp(+ReferentsList, +SemCat, +Role, -Ref, -Ind)
== Inferred temporal location = limitato a locazioni temporali avverbiali e TR
*************/
main_loc_infer_temp(NoFr, RefList, CatSem, Role, Pred, Ref)
   :-
   (
    main_loc_avv(Ref)
    ;
    main_loc_int(NoFr,Ref)
   ),!.

/*************
main_loc(+ReferentsList, +SemCat, +Role, -Ref)
*************/
/*  Role and CatSem based and must be goal object */
main_loc(RefList, luogo, _, Ref):-
   on(Ref/_, RefList),
   arg(7, Ref, CatSem),
   nonvar(CatSem),
   notmembro(body_part, CatSem),
   membro(luogo, CatSem),
   (arg(8, Ref, ogg/goal)
    ;
   arg(8, Ref, obl/goal)).

/*  CatSem and Role based */
main_loc(RefList, Cat, Role, Ref):-
   on(Ref/_, RefList),
   arg(7, Ref, CatSem),
   nonvar(CatSem),
   notmembro(body_part, CatSem),
   membro(Cat, CatSem),
   arg(8, Ref, _/Role).

/* Role based */
main_loc(RefList, _, locativo, Ref):-
   on(Ref/_, RefList),
   arg(7, Ref, CatSem),
   nonvar(CatSem),
   notmembro(body_part, CatSem),
   notmembro(istituzione, CatSem),
   notmembro(umano, CatSem),
   (arg(8, Ref, _/locativo);
   arg(8, Ref, _/locat)).

/*  CatSem based and must be adjunct object */
main_loc(RefList, luogo, _, Ref):-
   on(Ref/_, RefList),
   arg(7, Ref, CatSem),
   nonvar(CatSem),
   notmembro(body_part, CatSem),
   membro(luogo, CatSem),
   arg(8, Ref, ogg/nil).

/*  CatSem based and must be adjunct object */
main_loc(RefList, luogo, _, Ref):-
   on(Ref/_, RefList),
   arg(7, Ref, CatSem),
   nonvar(CatSem),
   notmembro(sostanza, CatSem),
   notmembro(substance, CatSem),
   notmembro(body_part, CatSem),
   membro(luogo, CatSem),
   arg(8, Ref, adj/specif).

/*  Only for temporal locations. Function is ogg_avv */
main_loc(RefList, tempo, _, Ref):-
   on(Ref/_, RefList),
   arg(7, Ref, CatSem),
   membro(deittico,CatSem),
   arg(8, Ref, Fun/Role),
   legal_temp_fun_role(Fun, Role).

main_loc(RefList, tempo, _, Ref):-
   on(Ref/_, RefList),
   arg(7, Ref, CatSem),
   arg(8, Ref, Fun/Role),
   legal_temp_funrole(Fun, Role).

/*  CatSem based and must be adjunct object */
main_loc(RefList, tempo, _, Ref):-
   on(Ref/_, RefList),
   arg(7, Ref, CatSem),
   nonvar(CatSem),
   notmembro(body_part, CatSem),
   (membro(tempo, CatSem)
    ;
    membro(date, CatSem)
    ;
    membro(temp, CatSem)),
   arg(8, Ref, ogg/nil).

main_loc_int(1,Ref):-
   nodo(n1)::ref_int::[Ref].

main_loc_int(NoFr,TR2):-
   nodo(_)::ref_int::[Ref],
   time_focus(StackNo, TR2),
   TR2=tes(Ref1),
   Ref=tr(Ref2),
   Ref2 \= Ref1.

%legal_temp_fun_role(ogg_avv, _).
legal_temp_fun_role(ogg,Role):-
   Role\=tema_bound,Role\=theme_bound.
% legal_temp_funrole(ogg,punct).
legal_temp_funrole(ogg,non_punct).



write_main_loc(NFrase) :-
   current_main_loc(NFrase, luogo, Ref),
   Ref=..[ref_ex, _ | Args],
   Ref1=..[ref_ex, NFrase | Args],
   writenl('MAIN SPATIAL LOCATION: '),
   write(Ref1).

write_main_temp(NFrase) :-
   current_main_loc(NFrase, tempo, Ref),
   Ref=..[ref_ex, _ | Args],
   !,
   Ref1=..[ref_ex, NFrase | Args],
   writenl('MAIN TEMPORAL LOCATION: '),
   write(Ref1).

write_main_temp(NFrase) :-
   current_main_loc(NFrase, tempo, MainTemp),
   writenl('MAIN TEMPORAL LOCATION: '),
   write(MainTemp).


/*
infer_temp_loc(NoFr, MainLoc, MainLoc):-
   current_main_loc(_, tempo, MainTemp),
   MainTemp = ref_ex(Id, Loc),
   Loc = tr(TR),
   !.
*/
infer_temp_loc(NoFr, CurrLoc, NewLoc):-
   current_main_loc(_, tempo, MainTemp),
   MainTemp = ref_ex(Id, OldLoc),
   specific_time(CurrLoc, OldLoc, NewLoc).

infer_temp_loc(NoFr, MainLoc, MainLoc):-
   current_main_loc(_, tempo, MainTemp),
   MainTemp \= ref_ex(univ),
   !.

specific_time(CurrLoc, OldLoc, NewLoc):-
   check_loc(CurrLoc, Type1),
   check_loc(OldLoc, Type2),
   infer_include(Type1, Type2, Type),
   (
    Type=Type1, NewLoc=CurrLoc
   ;
    Type=Type2, NewLoc=OldLoc
   ).   

specific_time(CurrLoc, OldLoc, NewLoc):-
   infer_temp(CurrLoc, OldLoc, NewLoc).   

check_loc(ieri, day).
check_loc('Thursday', week_day).
check_loc(1950, date).
check_loc(tes(TR), ref_time).

infer_temp(tr(TR1), tr(TR2), TR2):-
rel_temp(Inf, tes(TR1), tr(TR2), [bf]).

infer_temp(tr(TR1), _, TR2):-
   time_focus(StackNo, TR2).


infer_include(day, week_day, week_day).
infer_include(day, ref_time, day).
infer_include(date, ref_time, date).

/*
connect_main_temp_loc(NoFr, _) :-
   genre(legal),
   !.
*/
connect_main_temp_loc(NoFr, NewLoc) :-
   main_sentence_index(FrX),
   rete(Rete),
   concatena(FrX, Rete, TimeId),
   (
/*    current_main_loc(_, tempo, MainTemp),
    MainTemp = ref_ex(Id, tr(TR)),
    connect_time(TimeId, NewLoc)
   ;
*/    assert(includes(tes(TimeId), NewLoc)),
    connect_time(TimeId, NewLoc),
    write_inclusion(includes, tr(TimeId), NewLoc)
   ;
    assert(includes(tes(TimeId), NewLoc)),
    write_inclusion(includes, tr(TimeId), NewLoc)
   ).

connect_time(TimeId, NewLoc)
  :- 
info(NoFr, Node, FunRole, View, Intens, Change, Rel, 
       VerbCat, Verb,TempRel, DiscRel, DiscDom, SubjConsc),
   TempRel=..[Relt,Tr1, Tr2],
   assert(TempRel),
   write_inclusion(Relt, Tr1, Tr2).

write_inclusion(Relt, TimeId, MainLoc) :-
%   active_output_win('Model'),
   !,
   nl, 
   Rels=..[Relt,TimeId, MainLoc],
   write(Rels).
write_inclusion(_, _, _).


/* converte un grafo nell'input per la forma logica */

/* tologf(InFile) - predicato principale - legge la rete da un .net */

tologf(FL) :-
   read_rete(NetId),
   xlate(n1,FL), 
   !,
   nl,write_frase(NetId),
   nl,nl,write(FL),nl,
   scope(FL).

tologf(InFile) :-
    xlate(n1,FL),
    !,
    write(FL),nl,scope(FL).


xlate1(N, FL1) :-  
   nodo(_)::Funz/Role::nodo(N),
   (member(Funz, [acomp,ncomp]),
     (nodo(N)::indice::Ind,
      nodo(N)::pred::Pred,  
      (
      nodo(N)::vcomp/prop::nodo(Sogg),
      xlate_sn(N, FL2),
      FL1 = wff(Pred,[FL2])
       ;
      nodo(N)::sogg/nil::nodo(Sogg),  
      nodo(N1)::controllore::Contr,  
      xlate(Sogg,XSogg),
      xlate_sn(N, FL2),
      FL1 = wff(Pred,[XSogg, FL2])
       ;
      nodo(N)::sogg/nil::nodo(Sogg),  
      nodo(n1)::vcomp/prop::nodo(NN),
      xlate(Sogg,XSogg),
      xlate_sn(NN, FL2),
      xlate_sn(N, FL3),
      write_preds_rols(Pred,[Sogg,N,NN]),
      FL1 = wff(Pred,[XSogg, FL2, FL3]))
     ;
     nodo(N)::coordina::coord::nodo(N1),  
     nodo(N)::coordina::coord::nodo(N2), 
     N1 \= N2,  
     nodo(N1)::indice::Ind2,
     nodo(N1)::pred::Pred2,  
     nodo(N2)::indice::Ind1,
     nodo(N2)::pred::Pred1,  
      nodo(N1)::sogg/nil::nodo(N11),  
      nodo(N11)::controllore::Contr,  
        Predcoord=[Pred1,Pred2],
        FL1=wff(Predcoord,[Contr]))
    ;
    Funz=vcomp,
    nodo(N)::adj::nodo(N1),
    nodo(N1)::sem_mark::Pred,
    nodo(N1)::adj::sub/prop::nodo(N2), /* sfuggire */
    xlate(N2, XSub),
    nodo(N1)::adjs::adj::nodo(N3),
    nodo(N3)::sem_mark::Pred1,
    xlate(N3, XMain),
    FL1 = wff(and,[XMain, XSub])),
/*    FL1 = wff(and,[XMain, FLsub])),
    FL1 = wff(Pred,[wff(adj,[XMain]), wff(adj,[XSub])])),
   FL1 = wff(Pred,[wff(main,[XMain])])), */
    !.

xlate1(N,FL) :-  
   nodo(_)::pcomp/_::nodo(N),
   nodo(N)::sogg/_::nodo(Sogg),
   nodo(N)::ogg/_::pred::Pred,
   nodo(N)::ogg/_::antecedente::esterno,
   nodo(N)::ogg/_::nodo(Ogg),
      xlate(Sogg,XSogg),
   xlate(Ogg,XOgg),
   FL = wff(in,[XSogg,XOgg]), 
   !.

xlate1(N,FL) :-  
   nodo(_)::pcomp/_::nodo(N),
   nodo(N)::sogg/_::nodo(Sogg),
   nodo(N)::ogg/_::pred::Pred,
   nodo(N)::ogg/_::controllore::Contr,
   nodo(N)::ogg/_::nodo(Ogg),
      xlate(Sogg,XSogg),
   xlate(Ogg,XOgg),
   FL = wff(in,[XSogg,XOgg]), 
   !.

xlate1(N,FL) :-  
   nodo(_)::pcomp/_::nodo(N),
   nodo(N)::sogg/_::nodo(Sogg),
   nodo(N)::sogg/_::controllore::Contr,
   nodo(N)::ogg/_::pred::Pred,
   nodo(N)::ogg/_::nodo(Ogg),
      xlate(Sogg,XSogg),
   xlate(Ogg,XOgg),
   FL = wff(in,[XSogg,XOgg]), 
   !.


/* e' la frase principale */
xlate1(Nodo,FL) :-
   ( 
   nodo(Nodo)::modo::Modo 
   ;
   nodo(Nodo)::sogg/prop::_
   ),
   nodo(Nodo)::pred::Pred,
   nodo(Nodo)::indice::Ind,
   nodo(Nodo)::cat::CatV,
   nodo(Nodo)::modo::Modo,                 
   nodo(Nodo)::tempo::Tempo,
   findall(
      N,
      (
        (  nodo(Nodo)::focus::sn_int::nodo(N),!,
     (nodo(Nodo)::F1/Ruolo::controllore::Contr
      ;
      nodo(Nod)::sogg/nil::controllore::Contr
      ;
      nodo(Nod)::F1/Ruolo::controllore::Contr
      ),
%         nodo(Nodo)::F1/Role::controllore::Contr,
                  (F1=sogg;F1=ogg;F1=ogg2;F1=obl)
         ;
         nodo(Nodo)::focus::nodo(N),
         notnodlg1(Nodo, sn_int, focus),
%         not nodo(Nodo)::focus::sn_int::nodo(N),
     (nodo(Nodo)::F1/Ruolo::controllore::Contr
      ;
      nodo(Nod)::sogg/nil::controllore::Contr
      ;
      nodo(Nod)::F1/Ruolo::controllore::Contr
      ),
         nodo(Nodo)::F1/Role::controllore::Contr,
                  (F1=sogg;F1=ogg;F1=ogg2;F1=obl))
      ),
      Laa),
   findall(
      N,
        (member(
         F,
         [sogg,sogg_posposto,subj_top,sogg_top,sogg_foc,topic,
         ogg,ogg2,obl2,obl1,obl,foc,fuoco,subj_foc,ogg_avv,adv,
         pcomp,acomp,ncomp,vpred,vcomp,fcomp]),
         nodo(Nodo)::F/Role::nodo(N),Role\=form
      ),
      Lab),
   append(Lab, Laa, La1),
   maplist(xlate,La1,Las),                 
   togli_doppi(Las, La2),
   write_preds_rols(Pred,La1),
   Adjs_q=[],        
   aggiunti_frasali(Nodo,Ind, Adjs),
   write_preds_adjs(Pred,Adjs),
   build_event_restrictions(Tempo, Ind, Adjs, EvStato, TQuant, EventRes),  
   ( 
   Adjs_q = [], 
   La3=La2                    
   ;                  
   append(La2,[Adjs_q],La3)
   ),   
   (
   on(CatV, [risultato,achiev_irr,achiev,achiev_tr,accomp,cambiamento])
   ->   
   EvStato=ev,
   TQuant=definito,
   append(La3,[term(event,Ind,EventRes)],Args)         
   ;
   CatV=attivita,             
   EvStato=pr,
   TQuant=indefinito,
   append(La3,[term(process,Ind,EventRes)],Args)
   ;            
   EvStato=st,
   TQuant=indefinito,
   append(La3,[term(state,Ind,EventRes)],Args)
   ),  
   (find_forms(Nodo,Pred,Pre),
   FL1 = wff(Pre,Args)               
   ;  
   FL1 = wff(Pred,Args)
   ),                 
   (
   nodo(Nodo)::adjs::neg::Neg,                  
   FL2 = wff(not,[FL1]), 
   !
   ;                  
   FL2 = FL1
   ),         
   (
   Modo=inf,
   FL=FL2,
   !
   ;
   nodo(Nodo)::focus::tipo_focus::interrogativo,
   FL=FL2,
   !                    
   ;                  
   FL= wff(situation,[FL2])
   ).

xlate1(N, FL) :-  
  nodo(N)::adjs::report/prop::nodo(N1),
  xlate(N1,XSub),
  FL = wff(main,[XSub]), 
  !. 

xlate1(N, FL) :-  
  nodo(N)::report/prop::nodo(N1),
  xlate(N1,XSub),
  FL = wff(main,[XSub]), 
  !. 


/* nodo di coordinazione tra frasi */
xlate(N, FL) :-  
   (nodo(N)::F/R::nodo(NN),
    F\=vcomp,F\=adv,  
   nodo(NN)::coord::nodo(N1),  
   nodo(NN)::coord::nodo(N2)
   ;
   nodo(N)::coord::nodo(N1),  
   nodo(N)::coord::nodo(N2) 
   ),  
   N1 \= N2,  
   xlate(N1,FL1),  
   xlate(N2,FL2),  
   FL=wff(and,[FL1,FL2]),
   !. 

xlate(N, FL) :-  
   (nodo(N)::F/R::nodo(NN),
    F\=vcomp,F\=adv,  
   nodo(NN)::main/prop::coord::nodo(N1),  
   nodo(NN)::main/prop::coord::nodo(N2)
   ;
   nodo(N)::main/prop::coord::nodo(N1),  
   nodo(N)::main/prop::coord::nodo(N2) 
   ),  
   N1 \= N2,  
   xlate(N1,FL1),  
   xlate(N2,FL2),  
   FL=wff(and,[FL1,FL2]),
   !. 


xlate(N, FLL) :-  
   nodo(N)::cp_comp::nodo(NN),  
   nodo(NN)::indice::Ind,
   nodo(NN)::_/prop::nodo(N1),  
   nodo(NN)::adj::_/prop::nodo(N2),
   nodo(NN)::adj::sem_mark::Pred1,
   nodo(NN)::adj::_/prop::nodo(N3),
   N2 \= N3,  
   nodo(NN)::adj::sem_mark::Pred2,
   Pred1\=Pred2,
   xlate(N1,FL),  
   xlate(N2,FL1),  
   xlate(N3,FL2),  
   Adj1=wff(Pred1,[Ind,FL1]),
   Adj2=wff(Pred2,[Ind,FL2]),
   FLL=wff(and,[FL,Adj1,Adj2]),
   !. 

xlate(N, FL) :-  
   nodo(N)::coords::nodo(NN),
   nodo(NN)::main/prop::nodo(N1),  
   nodo(NN)::main/prop::nodo(N2),
   N1 \= N2,  
   xlate(N1,FL1),  
   xlate(N2,FL2),  
   FL=wff(and,[FL1,FL2]),
   !. 

xlate(N, FL) :-  
   nodo(N)::coord_ip::nodo(NN),
   nodo(NN)::coord::nodo(N1),  
   nodo(NN)::coord::nodo(N2),
   N1 \= N2,  
   xlate(N1,FL1),  
   xlate(N2,FL2),  
   FL=wff(and,[FL1,FL2]),
   !. 

xlate(N, FL) :-  
   (nodo(N)::F/R::coords::nodo(NN),
   nodo(NN)::main/prop::nodo(N1),  
   nodo(NN)::main/prop::nodo(N2)
   ;
   nodo(N)::main/prop::nodo(N1),  
   nodo(N)::main/prop::nodo(N2) 
   ),  
   N1 \= N2,  
   xlate(N1,FL1),  
   xlate(N2,FL2),  
   FL=wff(and,[FL1,FL2]),
   !. 

/* nodo di ipotassi tra frasi */
xlate(N, FL) :-  
    F=dir_speech,  
   nodo(N)::F/R::nodo(N1),
   nodo(N)::F/R::nodo(N2),  
   N1 \= N2,  
   xlate(N1,FL1),  
   xlate(N2,FL2),  
   FL=wff(and,[FL1,FL2]),
   !. 

/* subordinazione alta */
xlate(N, FL) :-  
  (
  nodo(N)::adjs::adj::sub/prop::nodo(N1)
  ;
  nodo(N)::adj::sub/prop::cp_dir::nodo(N1)
  ;
  nodo(N)::adjs::sub/prop::nodo(N1)
  ;
  nodo(N)::adj::sub/prop::nodo(N1)
  ;
  nodo(N)::adj/Rol::nodo(N1)
  ),
  main_relation(N1, Role, Pred),
  nonvar(Pred),
  xlate(N1,XSub),
  (
  nodo(N)::main/prop::[],
  nodo(N)::adj::sub/prop::main/prop::nodo(N3),
  XSub=wff(Pred,[wff(adj,[wff(Pred1,
           [wff(main,[XMain]), wff(adj,[XSub1])])])]),
  FL = wff(Pred1,[wff(main,[XMain]), wff(adj,[XSub1])])
  ;
  nodo(N)::main/prop::[],
  notnodlg0(N, sub/prop, main/prop, adj),
  FL = wff(Pred,[wff(adj,[XSub])]) 
  ;
  nodo(N)::main/prop::nodo(N3),
  xlate(N3, XMain),
  FL = wff(Pred,[wff(main,[XMain]), wff(adj,[XSub])])
  ;
  nodo(N)::adv_main/prop::nodo(N3),
  xlate(N3, XMain),
  FL = wff(Pred,[wff(main,[XMain]), wff(adj,[XSub])])
  ;
  xlate1(N, XMain),
  FL = wff(Pred,[wff(main,[XMain]), wff(adj,[XSub])])
  ;
  FL = wff(Pred,[wff(adj,[XSub])])
  ), 
  !. 

xlate(N, FL) :-  
  nodo(N)::adjs::report/prop::nodo(N1),
  xlate(N1,XSub),
  FL = wff(main,[XSub]), 
  !. 

xlate(N, FL) :-  
  nodo(N)::report/prop::nodo(N1),
  xlate(N1,XSub),
  FL = wff(main,[XSub]), 
  !. 

xlate(N, FL1) :-  
   nodo(_)::Funz/Role::nodo(N),
   (member(Funz, [acomp,ncomp]),
     (nodo(N)::indice::Ind,
      nodo(N)::pred::Pred,  
      (
      nodo(N)::vcomp/prop::nodo(Sogg),
      xlate_sn(N, FL2),
      FL1 = wff(Pred,[FL2])
       ;
      nodo(N)::sogg/nil::nodo(Sogg),  
      nodo(N1)::controllore::Contr,  
      xlate(Sogg,XSogg),
      xlate_sn(N, FL2),
      FL1 = wff(Pred,[XSogg, FL2])
       ;
      nodo(N)::sogg/nil::nodo(Sogg),  
      nodo(n1)::vcomp/prop::nodo(NN),
      xlate(Sogg,XSogg),
      xlate_sn(NN, FL2),
      xlate_sn(N, FL3),
      write_preds_rols(Pred,[Sogg,N,NN]),
      FL1 = wff(Pred,[XSogg, FL2, FL3]))
     ;
     nodo(N)::coordina::coord::nodo(N1),  
     nodo(N)::coordina::coord::nodo(N2), 
     N1 \= N2,  
     nodo(N1)::indice::Ind2,
     nodo(N1)::pred::Pred2,  
     nodo(N2)::indice::Ind1,
     nodo(N2)::pred::Pred1,  
      nodo(N1)::sogg/nil::nodo(N11),  
      nodo(N11)::controllore::Contr,  
        Predcoord=[Pred1,Pred2],
        FL1=wff(Predcoord,[Contr]))
    ;
    Funz=vcomp,
    nodo(N)::adj::nodo(N1),
    nodo(N1)::sem_mark::Pred,
    nodo(N1)::adj::sub/prop::nodo(N2), /* sfuggire */
    xlate(N2, XSub),
    nodo(N1)::adjs::adj::nodo(N3),
    nodo(N3)::sem_mark::Pred1,
    xlate(N3, XMain),
    FL1 = wff(and,[XMain, XSub])),
/*    FL1 = wff(and,[XMain, FLsub])),
    FL1 = wff(Pred,[wff(adj,[XMain]), wff(adj,[XSub])])),
   FL1 = wff(Pred,[wff(main,[XMain])])), */
    !.
/*
xlate(N,FL) :-  
   nodo(_)::pcomp/_::nodo(N),
   nodo(N)::sogg/_::nodo(Sogg),
   nodo(N)::ogg/_::pred::Pred,
   nodo(N)::ogg/_::antecedente::esterno,
   nodo(N)::ogg/_::nodo(Ogg),
      xlate(Sogg,XSogg),
   xlate(Ogg,XOgg),
   FL = wff(in,[XSogg,XOgg]), 
   !.
*/

xlate(N,FL) :-  
   nodo(_)::pcomp/_::nodo(N),
   nodo(N)::sogg/_::nodo(Sogg),
   nodo(N)::ogg/_::indice::I,
   (nodo(N)::ogg/_::controllore::Contr;
   nodo(N)::ogg/_::antecedente::esterno),
   nodo(N)::ogg/_::nodo(Ogg),
      xlate(Sogg,XSogg),
   xlate(Ogg,XOgg),
   FL = wff(in,[XSogg,XOgg]), 
   !.

xlate(N,FL) :-  
   nodo(_)::pcomp/_::nodo(N),
   nodo(N)::sogg/_::nodo(Sogg),
   nodo(N)::sogg/_::controllore::Contr,
   nodo(N)::ogg/_::indice::I,
   nodo(N)::ogg/_::nodo(Ogg),
      xlate(Sogg,XSogg),
   xlate(Ogg,XOgg),
   FL = wff(in,[XSogg,XOgg]), 
   !.

/* e' la frase principale */
xlate(Nodo,FL) :-
   ( 
   nodo(Nodo)::modo::Modo 
   ;
   nodo(Nodo)::sogg/prop::_
   ),
   nodo(Nodo)::pred::Pred,
   nodo(Nodo)::indice::Ind,
   nodo(Nodo)::cat::CatV,
   nodo(Nodo)::modo::Modo,                 
   nodo(Nodo)::tempo::Tempo,
   findall(
      N,
      (
        (  nodo(Nodo)::focus::sn_int::nodo(N),!,
     (nodo(Nodo)::F1/Ruolo::controllore::Contr
      ;
      nodo(Nod)::sogg/nil::controllore::Contr
      ;
      nodo(Nod)::F1/Ruolo::controllore::Contr
      ),
                  (F1=sogg;F1=ogg;F1=ogg2;F1=obl)
         ;
         nodo(Nodo)::focus::nodo(N),
         notnodlg1(Nodo, sn_int, focus),
     (nodo(Nodo)::F1/Ruolo::controllore::Contr
      ;
      nodo(Nod)::sogg/nil::controllore::Contr
      ;
      nodo(Nod)::F1/Ruolo::controllore::Contr
      ),
         nodo(Nodo)::F1/Role::controllore::Contr,
                  (F1=sogg;F1=ogg;F1=ogg2;F1=obl))
      ),
      Laa),
   findall(
      N,
        (member(
         F,
         [sogg,sogg_posposto,subj_top,sogg_top,sogg_foc,topic,
         ogg,ogg2,obl2,obl1,obl,foc,fuoco,subj_foc,ogg_avv,adv,
         pcomp,acomp,ncomp,vpred,vcomp,fcomp]),
         nodo(Nodo)::F/Role::nodo(N),Role\=form
      ),
      Lab),
   append(Lab, Laa, La1),
   maplist(xlate,La1,Las),                 
   togli_doppi(Las, La2),
   write_preds_rols(Pred,La1),
   Adjs_q=[],        
   aggiunti_frasali(Nodo,Ind, Adjs),
   write_preds_adjs(Pred,Adjs),
   build_event_restrictions(Tempo, Ind, Adjs, EvStato, TQuant, EventRes),  
   ( 
   Adjs_q = [], 
   La3=La2                    
   ;                  
   append(La2,[Adjs_q],La3)
   ),   
   La3=La2,                  
   (
   on(CatV, [risultato,achiev_irr,achiev,achiev_tr,accomp,cambiamento])
   ->   
   EvStato=ev,
   TQuant=definito,
   append(La3,[term(event,Ind,EventRes)],Args)         
   ;
   CatV=attivita,             
   EvStato=pr,
   TQuant=indefinito,
   append(La3,[term(process,Ind,EventRes)],Args)
   ;            
   EvStato=st,
   TQuant=indefinito,
   append(La3,[term(state,Ind,EventRes)],Args)
   ),  
   (find_forms(Nodo,Pred,Pre),
   FL1 = wff(Pre,Args)               
   ;  
   FL1 = wff(Pred,Args)
   ),                 
   (
   nodo(Nodo)::adjs::neg::Neg,                  
   FL2 = wff(not,[FL1]), 
   !
   ;                  
   FL2 = FL1
   ),         
   (
   Modo=inf,
   FL=FL2,
   !
   ;
   nodo(Nodo)::focus::tipo_focus::interrogativo,
   FL=FL2,
   !                    
   ;                  
   FL= wff(situation,[FL2])
   ).

xlate(Nodo, FL) :-
   nodo(Nodo)::sub/prop::nodo(N1),
   nodo(Nodo)::sem_mark::Pred,
   nodo(Nodo)::sub/prop::nodo(N1),
   nodo(N)::adjs::adj::sub/prop::pred::P,
   nodo(N0)::vcomp/prop::adj::nodo(N),
   nodo(N)::pred::P,
   nodo(N)::modo::inf,
   xlate(N,FL), 
   !.

xlate(Nodo, FL1) :-
   nodo(Nodo)::ip::nodo(N1),
   nodo(N)::ip_ell/prop::nodo(N2),
   nodo(N1)::adjs::adj/Role::nodo(N3),
   xlate(N3,FL), 
   (
    nodo(N1)::adjs::neg::Neg,                  
    FL1 = wff(not,[FL])
    ;
    FL1=Fl),
   !.

xlate(Nodo, FL) :-
   nodo(Nodo)::ip_ell/prop::[],
   nodo(Nodo)::adjs::avv::adj/Role::nodo(N3),
   nodo(Nodo)::indice::Ind,
   aggiunti_ellittici(Nodo,Ind,Adjs),
   build_event_restrictions(pres, Ind, Adjs, st, indefinito, EventRes),  
   append(La3,[term(state,Ind,EventRes)],Args),
   FL1 = wff(be,Args),  
   (
   nodo(Nodo)::adjs::neg::Neg,                  
   FL2 = wff(not,[FL1]), 
   !
   ;                  
   FL2 = FL1
   ),         
   FL= wff(situation,[FL2]),
   !.

xlate(Nodo, FL) :-
   nodo(Nodo)::ip_ell/prop::nodo(N2),
   nodo(N2)::F/R::nodo(N3),
   nodo(Nodo)::indice::Ind,
   xlate(N3,La3), 
   aggiunti_ellittici(Nodo,Ind,Adjs),
   build_event_restrictions(pres, Ind, Adjs, st, indefinito, EventRes),  
   append([La3],[term(state,Ind,EventRes)],Args),
   FL1 = wff(be,Args),  
   (
   nodo(Nodo)::adjs::neg::Neg,                  
   FL2 = wff(not,[FL1]), 
   !
   ;                  
   FL2 = FL1
   ),         
   FL= wff(situation,[FL2]),
   !.

xlate(Nodo, FL) :-
   nodo(Nodo)::_/prop::nodo(N1),
   xlate(N1,FL), 
   !.

/* e' un sn */
xlate(Nodo, FL) :-
   nodo(Nodo)::coordina::nodo(N1),
   nodo(Nodo)::indice::Ind,
   nodo(N1)::F/R::nodo(N0),  
   nodo(N1)::F/R::nodo(N2), 
     N0 \= N2,  
   nodo(N1)::F/R::nodo(N3),
   N3\=N0,N3\=N2,
   nodo(N3)::indice::Ind3,
   nodo(N3)::pred::Pred3,
     nodo(N0)::indice::Ind2,
     nodo(N0)::pred::Pred2,  
     nodo(N2)::indice::Ind1,
     nodo(N2)::pred::Pred1,
    (nonvar(Pred3), Predcoord=[Pred1,Pred2,Pred3]
     ;  
     Predcoord=[Pred1,Pred2]),  
   FL=wff(Predcoord,[ Ind]),
   !.

xlate(Nodo, FL) :-
   nodo(Nodo)::coordina::nodo(N1),
   nodo(Nodo)::indice::Ind,
   findall(N, nodo(N1)::F/R::nodo(N), Nodes),
   xlate_sn(Nodes, FLCoord),
   FL=term(set, Ind, FLCoord),
   !.

xlate(Nodo, FL) :-
   nodo(Nodo)::coordina::nodo(N1),
   nodo(Nodo)::indice::Ind,
   nodo(N1)::F/R::nodo(N0),  
   nodo(N1)::F/R::nodo(N2), 
     N0 \= N2,  
     nodo(N0)::indice::Ind2,
     nodo(N0)::pred::Pred2,  
     nodo(N2)::indice::Ind1,
     nodo(N2)::pred::Pred1,
     Predcoord=[Pred1,Pred2],  
   FL=wff(Predcoord,[ Ind]),
   !.

/* e' un sn */
xlate(Nodo, FL) :-
   nodo(Nodo)::tab_ref::_,
   xlate_sn(Nodo,FL), 
   !.

/* e' un sn */
xlate(Nodo, FL) :-
   nodo(Nodo)::controllore::_,
   xlate_sn(Nodo, FL),
   !.

/* un Pro senza controllo e senza tab_ref  */
xlate(Nodo,CC) :- 
   nodo(Nodo)::pred::Pred, 
   nogen_member(Pred, [pPro, vbl]),                    
   nodo(Nodo)::indice::Ind,                     
   CC=term(definito,Ind,wff(pPro,[Ind])), 
   !. 

notnodlg(N, Path):-
   findall(Value, 
           nodo(N)::Path::nodo(Value), Ps),
   Ps=[],!.

notnodlg0(N, Attributo, Funzioni, Path):-
   findall(Value, 
           nodo(N)::Path::Attributo::Funzioni::nodo(Value), Ps),
   Ps=[],!.

notnodlg1(Nodo, Funzioni, Path):-
   findall(Value, 
           nodo(N)::Path::Funzioni::nodo(Value), Ps),
   Ps=[],!.

main_relation(N1, Role, Pred) :-
   nodo(N2)::sub/prop::nodo(N1),
   nodo(N2)::sem_mark::Pred,
   subord_role(Pred, Role),
   !.
main_relation(N1, Role, Pred) :-
   nodo(N2)::sub/prop::nodo(N),
   nodo(N2)::sem_mark::Pred,
   subord_role(Pred, Role),
   !.
main_relation(_, Role, sub).

xlate_mod_int(N, Ind, Ind1, XMod) :-     
   nodo(N)::adjs::int::Pred,     
   XMod = wff(Pred, [Ind1,Ind]).

xlate_mod_int(_, _,_, _).

aggiunti_ellittici(Nodo,Ind,XMods) :-
   bagof(
      N-adj/X,
      (
      nodo(Nodo)::adjs::avv::adj/X::nodo(N),
        nodo(Nodo)::adjs::avv::nodo(N0);
      nodo(Nodo)::adjs::X::nodo(N),
        nodo(Nodo)::adjs::nodo(N0);
      nodo(Nodo)::adj/X::nodo(N),
        nodo(Nodo)::adj::nodo(N0);
      nodo(Nodo)::adj::X::nodo(N),
        nodo(Nodo)::adj::nodo(N0)
      ), 
      ListaAdjs1),
   xlate_adjs_f(ListaAdjs1,Ind,Adjs),
   (nodo(N0)::mod::Tipo::Pred,
    XMods = wff(and, [wff(Pred, [Ind, Adjs])])
    ;
    XMods = Adjs),
   !.
aggiunti_ellittici(_,_,[]).

xlate_sn([Nodo | Nodi], [FL | Fls]) :-
   !,
   xlate_sn(Nodo, FL),
   xlate_sn(Nodi, Fls).

xlate_sn([], []) :-
   !.


xlate_sn(Nodo, FL) :-
   nodo(Nodo)::controllore::IndContr,
   nodo(NContr)::indice::IndContr,
   nodo(_X)::focus::nodo(NContr), 
   !,
   xlate(NContr,FL).

xlate_sn(Nodo, FL) :-
   nodo(Nodo)::controllore::IndContr,
   nodo(NContr)::indice::IndContr,
   nodo(X)::focus::sn_int::nodo(NContr), 
   !,
   xlate(NContr,FL).

xlate_sn(Nodo, FL) :-
   nodo(Nodo)::indice::Ind,
   nodo(X)::focus::nodo(Nodo), 
   notnodlg(Nodo, sn_int),
   !,
   nodo(Nodo)::pred::Pred,
   altre_restrizioni_sn(Nodo,Ind,AltreRes),                    
   trova_quantif(Nodo,Quant,Pred,IndCo,AltreRes),                    
   (
   AltreRes \= [],
   Restrict = wff(and,[wff(isa,[Ind, Pred]), AltreRes])
   ;
   AltreRes = [],
   XArgs = [], 
   Restrict = wff(isa,[Ind, Pred])
   ),
   Fl1=term(Quant, Ind, Restrict), 
   FL=wff(focus,[Fl1]).

xlate_sn(Nodo, FL) :-
   nodo(Nodo)::indice::Ind,
   nodo(N)::focus::nodo(Nod), 
   nodo(Nod)::sn_int::nodo(Nodo), 
   !,
   nodo(Nodo)::pred::Pred,
   altre_restrizioni_sn(Nodo,Ind,AltreRes),                    
   trova_quantif(Nodo,Quant,Pred,IndCo,AltreRes),                    
   (
   AltreRes \= [],
   Restrict = wff(and,[wff(isa,[Ind, Pred]), AltreRes])
   ;
   AltreRes = [],
   XArgs = [], 
   Restrict = wff(isa,[Ind, Pred])
   ),
   Fl1=term(Quant, Ind, Restrict), 
   FL=wff(focus,[Fl1]).


xlate_sn(Nodo,FL) :- 
   nodo(Nodo)::indice::Ind,
   nodo(Nodo)::pred::Pred,
   xlate_args_sn(Nodo, XArgs),
   altre_restrizioni_sn(Nodo,Ind,AltreRes),                    
   trova_quantif(Nodo,Quant,Pred,IndCo,AltreRes),                    
   (
   AltreRes \= [],
   Restrict = wff(and,[wff(isa,[Ind, Pred]), AltreRes])
   ;
   XArgs \= [],
   Main = wff(isa,[Ind, Pred]),
   Head = wff(and,[wff(has,XArgs), Main]),  
   Restrict = wff(and,[Head, AltreRes])
   ;
   AltreRes = [],
   XArgs = [], 
   Restrict = wff(isa,[Ind, Pred])
   ),
   FL=term(Quant, Ind, Restrict),
   write_preds_adjs(Pred,AltreRes),
   ! .

xlate_sn_coordinati(Nodo,FL) :- 
   nodo(Nodo)::indice::Ind,
   nodo(Nodo)::pred::Pred,
   Restrict = wff(isa,[Ind, Pred]),
   FL=term(Quant,Ind,Restrict), 
   ! .


build_event_restrictions(Tempo, Ind, Adjs, EvStato, TQuant, EventRes) :-
   EventRes = wff(and, [wff(isa,[Ind, EvStato]), EventRes1]),
   TimeRes = wff(and, [wff(isa,[TInd, tloc]), wff(Tempo, [TInd])]),
   Time = wff(time,[Ind, term(TQuant,TInd, TimeRes) ]),
   gen_sym(t, TInd),
   (
   Adjs = [] 
   -> 
   EventRes1 = Time               
   ;                  
   EventRes1 = wff(and,[Time, Adjs])                 
   ).


/*******
altre_restrizioni_sn(+nodo, +indiceSintagma, -listaRestrizioni)
******/
altre_restrizioni_sn(Nodo, Ind, AltreRes) :-
  bagof(
    N-Tipo,
    restrizione(Nodo, Ind, N, Tipo),
    ListaMods),
  xlate_mods(ListaMods,Ind,AltreRes),
  !.
altre_restrizioni_sn(_,_,[]).

/*******
restrizione(+superNodo, +indiceSintagma, -nodo, -tipo)
******/
restrizione(Nodo, _, N, aggettivo) :-
    nodo(Nodo)::mods::pred::N.

restrizione(Nodo, _, N, sogg/poss) :-
    nodo(Nodo)::sogg/poss::nodo(N).

restrizione(Nodo, _, N, relativa/aperto) :-
    nodo(Nodo)::mods::Tipo::nodo(N).

restrizione(Nodo, _, N, Tipo) :-
    nodo(Nodo)::mods::Tipo::nodo(N).

restrizione(Nodo, _, N, Tipo) :-
    nodo(Nodo)::adjs::_/_::mods::Tipo::nodo(N).

restrizione(Nodo, _, N, Tipo) :-
    nodo(Nodo)::adjs::Tipo::nodo(N).

restrizione(Nodo, Ind, N, aperto) :-
      nodo(Nodo)::sogg/_::controllore::Ind,
      nodo(_)::adjs::_::nodo(N).

restrizione(Nodo, _, N, controllore) :-
    nodo(Nodo)::controllore::N.

restrizione(Nodo, _, N, antecedente) :-
    nodo(Nodo)::antecedente::N.


/*
trasla modificatori e aggiunti di un sn un elemento della lista e': Nodo-Funz/Ruolo
*/
xlate_mods([],Ind,[]) :-!.
xlate_mods([M],Ind,XM) :- 
   xlate_mod(M,Ind,XM),
   !.
xlate_mods([M | AltriM], Ind, XMods) :-
   xlate_mod(M, Ind, XM),
   xlate_mods(AltriM, Ind, XAltriM),
   XMods = wff(and, [XM, XAltriM]).

xlate_mods([M | AltriM], Ind, XMods) :-
   xlate_mods(AltriM, Ind, XMods),
   !.

/* controllore */
xlate_mod(CC-X, Ind, wff(X,[Ind,CC1])) :-
   nogen_member(X, [controllore, antecedente]),     
   % si controlla se il controllore e' un topic       
   (
   nodo(N1)::indice::CC,        
   nodo(_N2)::topic::nodo(N1),        
   (nodo(N1)::antecedente::CC1;
    nodo(N1)::controllore::CC1) 
/*   ;       
   nodo(N)::sogg/nil::nodo(Sogg),  
   nodo(N1)::controllore::CC1  
*/   ;
   CC1=CC
   ),       
   !.

/* aggiunti aperti */
xlate_mod(Adj-aperto,Ind,XAdj):-
      nodo(Adj)::sem_mark::Pred,
      nodo(Adj)::sogg/_::nodo(Sogg),
      nodo(Adj)::ogg/_::nodo(Ogg),
      xlate(Sogg,XSogg),
      xlate(Ogg,XOgg),
      XAdj = wff(Pred,[Ind,XSogg,XOgg]), 
      !.

/* aggiunti aperti */
xlate_mod(Adj-aperto,Ind,XAdj):-
      nodo(Adj)::pred::Pred,
      nodo(Adj)::sogg/_::nodo(Sogg),
      nodo(Adj)::ogg/_::nodo(Ogg),
      xlate(Sogg,XSogg),
      xlate(Ogg,XOgg),
      XAdj = wff(Pred,[Ind,XSogg,XOgg]), 
      !.

/* aggiunti aperti  struttura sbagliata compare sn */
xlate_mod(Adj-aperto,Ind,XAdj):-
      nodo(Adj)::pred::Pred,
      nodo(Adj)::sogg/nil::nodo(Sogg),      
      xlate(Sogg,XSogg),      
      XAdj = wff(Pred,[XSogg]), 
      !.

/* frasi relative */
xlate_mod(Mod-_Funz/_Ruolo,Ind,XMod) :-
     nodo(Mod)::modo::Modo,
     xlate(Mod,XMod1),
     XMod = wff(isola,[XMod1]), 
     !.

/* sp aggiunti all'sn */
xlate_mod(Adj-adj/Funz,Ind,XAdj) :-
     member(Funz,[poss]),
     nodo(Adj)::pred::Pred,
     nodo(Adj)::ogg/_::nodo(Ogg),
     xlate(Ogg,XOgg),
     XAdj = wff(Pred,[Ind,XOgg]), 
     !. 

/* sp aggiunti all'sn */
xlate_mod(Adj-adj/Funz,Ind,XAdj) :-
     nodo(Adj)::pred::Pred,
     nodo(Adj)::ogg/_::nodo(Ogg),
     xlate(Ogg,XOgg),
     XAdj = wff(Pred,[Ind,XOgg]),
     !. 

xlate_mod(Adj-adj/Funz,Ind,XAdj) :-
     nodo(Adj)::sem_mark::Pred,
     xlate(Adj, XOgg),
     XAdj = wff(Pred,[Ind, XOgg]), 
     !. 

xlate_mod(Nodo-sogg/poss,Ind,XAdj) :-
     xlate(Nodo,Poss),     
     XAdj = wff(poss,[Ind,Poss]), 
     !.

/* aggiunti dell'sn */
xlate_mod(Adj-adj,Ind,XAdj) :-
     nodo(Adj)::sem_mark::Pred,
     nodo(Adj)::Funz/Rol::nodo(A),
     xlate(A, XOgg),
     XAdj = wff(Pred,[Ind, XOgg]), 
     !. 

/* nome-mod (fratelli porcellini) */

xlate_mod(N-nome_mod,Ind,XAdj) :-     
   nodo(N)::pred::Pred,     
   XAdj = wff(isa,[Ind, Pred]),
   !.

xlate_mod(N-nadj/Funz,Ind,XAdj) :-     
   nodo(N)::pred::Pred,     
   XAdj = wff(isa,[Ind, Pred]),
   !.

/* aggettivi - non hanno ruolo ? TUTTO DA RIVEDERE !!!!!! */
/* aggiunto da Emanuele */
xlate_mod(N-mod/Ruolo, Ind, XMod) :-     
   nodo(N)::pred::Pred,     
   XMod = wff(Pred, [Ind]).

xlate_mod(N-mod_a, Ind, XMod) :-     
   nodo(N)::pred::Pred,     
   XMod = wff(Pred, [Ind]).

% EP 13.01.13
xlate_mod(N-mod_r, Ind, XMod) :-     
   nodo(N)::pred::Pred,     
   XMod = wff(Pred, [Ind]).

xlate_mod(Pred-aggettivo,Ind,XMod) :-     
   XMod = wff(Pred,[Ind]).


/* aggiunti frasali */
aggiunti_quant(Nodo,Ind,Adjs) :-
   bagof(N-X, nodo(Nodo)::adjs::X::nodo(N) ,[ListaAdjs1]),  %?? 
   xlate_mod_quant(ListaAdjs1,Ind,Adjs),
   !.
aggiunti_quant(_,_,[]).

/* aggiunti aperti - PRONOMI QUANTIFICATI        
( QUANTIFICATORI FLUTTUANTI  !!!?>?>?? ) */
xlate_mod_quant(Adj-adj/quantitativo,Ind,XAdj):-      
   nodo(Adj)::cat::[quantif],      
   nodo(Adj)::pred::Pred,      
   nodo(Adj)::tab_ref::_,
   xlate_sn(Adj, FL),
   XAdj = wff(Pred,[Ind,FL]),
   !.

aggiunti_frasali(Nodo,Ind,Adjs) :-
   bagof(
      N-X,
      ( (
      nodo(Nodo)::adjs::X::nodo(N);
      nodo(Nodo)::adj/X::nodo(N);
      nodo(Nodo)::adj::X::nodo(N)),
      X\=avv
      ), 
      ListaAdjs1),
%   filtra_aperti(ListaAdjs1,ListaAdjs2),
   xlate_adjs_f(ListaAdjs1,Ind,Adjs), 
   !.
aggiunti_frasali(_,_,[]).


filtra_aperti([],[]).
filtra_aperti([T|C],XC) :- 
   aperto(T),
   !,
   filtra_aperti(C,XC).
filtra_aperti([T|C],[T|XC]) :- 
filtra_aperti(C,XC).

aperto(M-adj/_) :-
 nodo(M)::sogg/_::nodo(_X).

/* 
Trasla aggiunti di una frase 
Un elemento della lista e': Nodo-Funz/Ruolo    
*/

xlate_adjs_f([],_,[]).

xlate_adjs_f([M],Ind,XM) :- 
   xlate_adj_f(M,Ind,XM),
   !.
xlate_adjs_f([M|AltriM],Ind,XMods) :-
   xlate_adj_f(M,Ind,XM),
   xlate_adjs_f(AltriM,Ind,XAltriM),
   XMods = wff(and,[XM,XAltriM]).

xlate_adjs_f([M|AltriM],Ind,XMods) :-
   xlate_adjs_f(AltriM,Ind,XMods),
   !.

/* subordinata
xlate_adj_f(Adj-subordinata,Ind,XAdj) :-
   nodo(Adj)::sub::Pred,
   xlate(Adj,XSub),
   XAdj = wff(Pred,[Ind,XSub]), 
   !. 

xlate_adj_f(Adj-adj,Ind,XAdj) :-
   nodo(Adj)::sem_mark::Pred,
   nodo(Adj)::sub/prop::nodo(Sub),
   xlate(Sub,XSub),
   XAdj = wff(Pred,[Ind,XSub]),
   !. 
*/
xlate_adj_f(Adj-adj/gerund,Ind,XAdj) :-
   xlate(Adj,XSub),
   XAdj = wff(coincide,[Ind,XSub]), 
   !. 

xlate_adj_f(Adj-particip,Ind,XAdj) :-
   xlate(Adj,XSub),
   XAdj = wff(coincide,[Ind,XSub]), 
   !. 

xlate_adj_f(Adj-vcomp/_,Ind,XAdj) :-
   xlate(Adj,XSub),
   XAdj = wff(coincide,[Ind,XSub]), 
   !. 

xlate_adj_f(Adj-gerundive_coordinate,Ind,XAdj) :-
   findall(N-adj/gerund, nodo(Adj)::adj/gerund::nodo(N), Nodes),
   xlate_adjs_f(Nodes, Ind, XAdj),
   !. 

xlate_adj_f(Adj-adj/gerund,Ind, XAdj):-
   nodo(_)::adj/gerund::pred::Pred,
   nodo(Adj)::sogg/_::nodo(Sogg),
   nodo(Adj)::F/R::nodo(Ogg),F\=sogg,
   xlate(Sogg,XSogg),
   xlate(Ogg,XOgg),
   XProp = wff(Pred,[XSogg,XOgg]),
   XAdj = wff(coincide,[Ind,XProp]), 
   !.

/* aggiunti aperti */
xlate_adj_f(Adj-adj/_,Ind, XAdj):-
   nodo(Adj)::sem_mark::Pred,
   nodo(Adj)::sogg/_::nodo(Sogg),
   nodo(Adj)::ogg/_::nodo(Ogg),
   xlate(Sogg,XSogg),
   xlate(Ogg,XOgg),
   XAdj = wff(Pred,[Ind,XSogg,XOgg]),
   !.

/* aggiunti aperti   -  QUANTIFICATORI FLUTTUANTI  
xlate_mod(Adj-aperto,Ind,Pred):-      
nodo(Adj)::cat::[quantif],      
nodo(Adj)::pred::Pred,      
nodo(Adj)::indice::II,       
nodo(Adj)::sogg/_::nodo(Sogg), !.
xlate_adj_f(Adj-adj/_,Ind,XAdj):-
      nodo(Adj)::pred::Pred,
      nodo(Adj)::cat::Cat,
     Cat=[quantif],    
    nodo(Adj)::tab_ref::_,
    xlate_sn(Adj,FL),
      XAdj = wff(Pred,[Ind,FL]), !.
*/


/* aggiunti chiusi */
xlate_adj_f(Adj-adj/_,Ind,XAdj):-
      nodo(Adj)::sem_mark::Pred,
      nodo(Adj)::ogg/_::nodo(Ogg),
      xlate(Ogg,XOgg),
      XAdj = wff(Pred,[Ind,XOgg]), 
      !.
/* aggiunti aperti aggettivali */
xlate_adj_f(Adj-adj/Role,Ind, XAdj):-
   nodo(_)::adj/Role::pred::Pred,
   nodo(Adj)::sogg/_::nodo(Sogg),
   nodo(Adj)::F/R::nodo(Ogg),F\=sogg,
   xlate(Sogg,XSogg),
   xlate(Ogg,XOgg),
   XAdj = wff(Pred,[Ind,XSogg,XOgg]),
   !.

xlate_adj_f(Adj-adj/Role,Ind,XAdj):-
      nodo(Adj)::sem_mark::Pred,
      xlate(Adj,XOgg),
      XAdj = wff(Pred,[Ind,XOgg]), 
      !.

/* modali - allora */
xlate_adj_f(Adj-adj/Tipo,Ind,XAdj) :-
     Tipo \= quantitativo,
     nodo(Adj)::pred::Pred,
     XAdj = wff(Pred,[Ind]), 
     !.


nello_scope_di(Var,L) :-
%    cancella_rete(_X),
%    estendi_nome_file(InFile,'.net',InFileExt),
%    leggi_rete(InFileExt, NetId),
  xlate(n1,X),
  gen(X,Y),
%  ppout(Y),nl,
  nello_scope_di_x(Var,Y,L),!.

nello_scope_di_x(Var,wff(_Quant,[Var|_]),[]) :- !.

nello_scope_di_x(XVar,wff(Quant,[Var,Res,Body]),[Quant/Var|RestQ]) :-
     quantifier(Quant),
     !,
     (nello_scope_di_x(XVar,Res,RestQ);
      nello_scope_di_x(XVar,Body,RestQ)),
     !.

nello_scope_di_x(Var,wff(_Pred,Args),ListaQ):-
     nogen_member(Arg,Args),
     nello_scope_di_x(Var,Arg,ListaQ),
     !.

/*******
trova_quantif(+nodo,-quant,+pred, +snArgs, +altreRes)
*******/
% EP 93.01.14
trova_quantif(Nodo, plural, _, _, _) :-
   nodo(Nodo)::num::plur,
   !.
   
% EP 93.01.14: da controllare
trova_quantif(NodoX, Quant, _, _, 
         wff(controllore, [SnX, SnY])) :-
   nodo(NodoX)::controllore::SnX,
   SnX\=SnY,
   segui_catena_di_controllo(SnX, SnY),
   !,   
   nodo(NodoY)::indice::SnY,
   (
   nodo(NodoY)::num::plur
   -> 
   Quant=plural
   ;
   Quant=definito
   ).
   
trova_quantif(Nodo,Quant,Pred,IndContr,_) :-
   nodo(Nodo)::spec::nodo(NSpec),
   trova_quantif_x(NSpec,Quant,Pred,IndContr),
   !.

trova_quantif(Nodo,definito,Pred,IndContr,_) :-
   nodo(Nodo)::spec::nodo(NSpec),
   nodo(Nodo)::num::NNum,
   nodo(Nodo)::tab_ref::[+ ref, - pro, - ana, - class],
   trova_quantif_y(NNum,NSpec,definito,_),
   !.

trova_quantif(Nodo,Quant,Pred,IndContr,_) :-
   nodo(Nodo)::spec::nodo(NSpec),
   nodo(Nodo)::num::NNum,
   nodo(Nodo)::tab_ref::[+ ref, - pro, - ana, + class],
   trova_quantif_y(NNum,NSpec,Quant,Pred),
   !.

trova_quantif(Nodo,Quant,Pred,IndContr,_) :-
   nodo(Nodo)::spec::nodo(NSpec),
   nodo(Nodo)::num::NNum,
   nodo(Nodo)::tab_ref::[+ ref, - pro, - ana, + class],
   trova_quantif_y(NNum,NSpec,Quant,Pred),
   !.

trova_quantif(_,each,_,_,Adjs) :-    
   (
   Adjs=each
   ;   
   Adjs=wff(and,[each|_])
   ), 
   !.

trova_quantif(Nodo,arbitraria,Pred,IndContr,_) :-
   nodo(Nodo)::spec::nodo(NSpec),
   nodo(Nodo)::interpretazione::arbitraria,
   nodo(NSpec)::def::'+',
   !.

trova_quantif(Nodo,arbitraria,Pred,IndContr,_) :-
   nodo(Nodo)::interpretazione::arbitraria,
   !.

trova_quantif(_,definito,_,_,_).


/* 
def:0 & num:plur -> plural
def:0 & num:sing -> mass
def:- & num:plur -> mass
def:- & num:sing -> definito
def:- & num:sing -> quant
def:+ & num:plural -> plural
def:+ & num:sing -> definito
*/

trova_quantif_y(NNum,NSpec,Quant,_) :-
   nodo(NSpec)::def::Def,
   zero(Def), 
   (
   nonvar(Quant)
   ;
   var(Quant),                 
      (
      NNum=plur,
      Quant=plural
      ;
      NNum=sing,
      Quant=mass
      )
   ).
   
trova_quantif_y(NNum,NSpec,Quant,_) :-
   nodo(NSpec)::def::'+',
   (
   nonvar(Quant)
   ;
   var(Quant),                 
      (
      NNum=plur,
      Quant=plural
      ;
      NNum=sing,
      Quant=definito
      )
   ).   

trova_quantif_y(NNum,NSpec,Quant,_) :-
   nodo(NSpec)::def::'-',
   (
   nonvar(Quant)
   ;
   var(Quant),                 
      (
      NNum=plur,
      Quant=plural
      ;
      nodo(Nodo)::interpretazione::quantificata,
      NNum=sing,
      Quant=quant
      ;
      NNum=sing,
      Quant=definito
      )
   ).   

/* quantificatore tutto */      
trova_quantif_x(NSpec,Quant,_,_) :-
   nodo(NSpec)::def::'+',
   nodo(NSpec)::part::'-',
   nodo(NSpec)::quant::Quant,
   Quant \= [], % EP 93.01.13
   !.

trova_quantif_x(NSpec,Quant,Quant,_) :-
   nodo(NSpec)::def::'+',
   nodo(NSpec)::part::'-',
   !.

trova_quantif_x(NSpec,Quant,Quant,_) :-
   nodo(NSpec)::def::'-',
   nodo(NSpec)::part::'+',
   !.

/* articolo definito */
trova_quantif_x(NSpec,definito,_,IndContr) :-
   nodo(NSpec)::def::'+',
   nodo(Nodo)::interpretazione::arbitraria,
   !.

/* articolo indefinito */
trova_quantif_x(NSpec,indefinito,_,_) :-
   nodo(NSpec)::def::'-'. 

/* cardinali */      
trova_quantif_x(NSpec,Quant,_,_) :-
   nodo(NSpec)::def::Def,
   zero(Def), 
   nodo(NSpec)::part::'+',
   nodo(NSpec)::card::Card,
   nonvar(Card),
   Quant=plural,
   !.

trova_quantif_x(NSpec,Quant,_,_) :-
   nodo(NSpec)::def::Def,
   zero(Def), 
   nodo(NSpec)::foc::Foc,
   nodo(NSpec)::card::Card,
   nonvar(Card),
   Foc \= [], Card \= [], 
   mcon(Foc,'_',Foc1),
   mcon(Foc1,Card,Quant),
%   Quant=plural,
   !.

/* quantificatore */      
trova_quantif_x(NSpec,Quant,_,_) :-
   nodo(NSpec)::def::Def,
   zero(Def), 
   nodo(NSpec)::quant::Quant, 
   Quant \= [], !.

/* nome proprio */       
trova_quantif_x(NSpec,entity,_,_) :-
   nodo(NSpec)::def::Def,
   zero(Def).

trova_quantif_x(NSpec,Definito,_,IndContr) :-
   nonvar(IndContr),
   (
   IndContr=[arbitraria],
   Definito=arbitraria
   ;
   IndContr\=[arbitraria],  
   nodo(NSpec)::def::'+',
   Definito=definito
   ).   

xlate_args_sn(Nodo,La2) :-
   findall(
      N,
      (
      member(F,[sogg,ogg,vcomp,fcomp]),
      nodo(Nodo)::F/_::nodo(N)
        ;
      nodo(Nodo)::sn_int::nodo(N)
      ),
      La1),
   maplist(xlate,La1,La2), 
   !.
xlate_args_sn(_Nodo,[]).



createlemss(L,Lista, Lems):-
   5 =< L,
   createlems(Lista, Lems),!.
createlemss(L,Lista, Lems):-
   L =< 6,
   ccreatelemss(Lista, Lems),!.


ccreatelemss(Lista, Lems):-
   ccreatelems(Lista, Lems),
    !.

ccreatelems([], []):-!.
ccreatelems(Lista, [W|Lems]):-
   ccreatelems(Lista, Rest, Lemm),
   stringof(Lemm,W),       
   ccreatelems(Rest, Lems),
   !.

ccreatelems([], [], []):-!.
ccreatelems(['_'|Lista], Rest, ['.'|Lem]):-
   ccreatelems(Lista, Rest, Lem),!.
ccreatelems([A|Lista], Rest, [W|Lem]):-
    toupper(A,W),
   ccreatelems(Lista, Rest, Lem),
   !.

createlems([], []):-!.
createlems(Lista, [W|Lems]):-
   createlems(Lista, Rest, Lemm),
   stringof(Lemm,W),       
   createlems(Rest, Lems),
   !.

createlems([], [], []):-!.
createlems(['_'|Lista], Lista, []):-!.
createlems([A|Lista], Rest, [A|Lem]):-
   createlems(Lista, Rest, Lem),
   !.

summ_up_unders(SortedEnts, RevSortNew):-
    summup_unders(SortedEnts, Middelist, Multiwords),
    lowcase_allt(Multiwords, LowTops),
    sort(LowTops, SortInds, [2], 1),
    add_up_same_ref(Middelist, SortInds, NSortedEnts),
    sort(NSortedEnts,SortNew),
    reverse(SortNew,RevSortNew),
    !.

summup_unders([], [], []):-!.
summup_unders([Score-Ent|SortedEnts], [Score-Ent|M], [Score-Ent-Lems|NSortedEnts]):-
    stringof(Lista,Ent),
    on('_',Lista),
    length(Lista,L),
    createlemss(L,Lista, Lems),
    summup_unders(SortedEnts, M, NSortedEnts),
   !.
summup_unders([Score-[A]|SortedEnts], M, NSortedEnts):-
    summup_unders(SortedEnts, M, NSortedEnts),
   !.
summup_unders([Score-nil|SortedEnts], M, NSortedEnts):-
    summup_unders(SortedEnts, M, NSortedEnts),
   !.
summup_unders([Score-Ent|SortedEnts], [Score-Ent|M], [Score-Ent-Ent|NSortedEnts]):-
    summup_unders(SortedEnts, M, NSortedEnts),
   !.

add_up_same_ref(SortedEnts, SortInds, SortScoreInds):-
   reduce_mults(SortedEnts, SortInds, NoMultsEnts),
   sort(NoMultsEnts,SortNoMultsEnts),
   assscore_sortedents(SortNoMultsEnts, Ent, 0, SortScoreInds),
   !.

reduce_mults([Sco-Ent|SortedEnts], SortInds, [NEnt-Ent-Sco|NoMultsEnts]):-
   findall(NEnt, 
                 member(NEnt-Ent-S,SortInds), Ents),
   length(Ents,L),
   1 < L,
   member(NEnt, Ents),
   reduce_mults(SortedEnts, SortInds, NoMultsEnts),
   !.

reduce_mults([Sco-Ent|SortedEnts], SortInds, [Sco-Ent|NoMultsEnts]):-
   reduce_mults(SortedEnts, SortInds, NoMultsEnts),
   !.
reduce_mults([], SortInds, []):-!.
   
assscore_sortedents([], Ent, Score, []):-!.
assscore_sortedents([NEnt-Ent1-Sco, NEnt-Ent2-Sco1, NEnt-Ent3-Sco2, NEnt-Ent4-Sco3|SortInds], NEnt, Score, SortScoreInds):-
    Score1 is Score + Sco + Sco1 + Sco2 + Sco3,
   assscore_sortedents(SortInds, [Ent1,Ent2,Ent3,Ent4], Score1, SortScoreInds),
   !.
assscore_sortedents([NEnt-Ent1-Sco, NEnt-Ent2-Sco1, NEnt-Ent3-Sco2|SortInds], NEnt, Score, SortScoreInds):-
    Score1 is Score + Sco + Sco1 + Sco2,
   assscore_sortedents(SortInds, [Ent1,Ent2,Ent3], Score1, SortScoreInds),
   !.
assscore_sortedents([NEnt-Ent1-Sco, NEnt-Ent2-Sco1|SortInds], NEnt, Score, SortScoreInds):-
    Score1 is Score + Sco + Sco1,
   assscore_sortedents(SortInds, [Ent1,Ent2], Score1, SortScoreInds),
   !.
assscore_sortedents([NEnt-Ent-Sco|SortInds], NEnt, Score, SortScoreInds):-
    Score1 is Score + Sco,
   assscore_sortedents(SortInds, Ent, Score1, SortScoreInds),
   !.

assscore_sortedents([NEnt-Ent-Sco|SortInds], Ent1, Score, [Score-Ent1|SortScoreInds]):-
   assscore_sortedents([NEnt-Ent-Sco|SortInds], NEnt, 0, SortScoreInds),
   !.
assscore_sortedents([Sco-Ent|SortInds], Ent1, Score, [Sco-Ent|SortScoreInds]):-
   assscore_sortedents(SortInds, NEnt, 0, SortScoreInds),
   !.
lowcase_allt([], []):-!.
lowcase_allt([S-[]|Alltops], LowTops):-
   lowcase_allt(Alltops, LowTops),!.
lowcase_allt([S-E-Top|Alltops], [Top-E-S|LowTops]):-
   atomic(Top),
   spy_lower(Top,LowTop,P),
   P=0,
   lowcase_allt(Alltops, LowTops),!.

lowcase_allt([S-E-Top|Alltops], [LowTop-E-S|LowTops]):-
   atomic(Top),
   spy_lower(Top,LowTop,P),
   P=1,
   lowcase_allt(Alltops, LowTops),!.

lowcase_allt([S-E-Tops|Alltops], [Top-E-S|LowTops]):-
   list(Tops),
   remove(Top, Tops, LTops),
   append([S-E-LTops], Alltops, NAlltops),
   spy_lower(Top,LowTop,P),
   P=0,
   lowcase_allt(NAlltops, LowTops),!.

lowcase_allt([S-E-Tops|Alltops], [LowTop-E-S|LowTops]):-
   list(Tops),
   remove(Top, Tops, LTops),
   append([S-E-LTops], Alltops, NAlltops),
   spy_lower(Top,LowTop,P),
   P=1,
   lowcase_allt(NAlltops, LowTops),!.
lowcase_allt([Tops|Alltops], LowTops):-
    lowcase_allt(NAlltops, LowTops),!.


asserisci_proprieta(IdGov,Pred-ng-_,NoFr,SnY,Resto, NewRefs, NewR):-
   stringof(MWord,Pred),
   reverse(MWord,['_',s, '-'|Word]),
   reverse(Word,RevWord),
   stringof(RevWord,Lex),
    get_id_mod(NoFr, Lex, [], NewRefs, SnY, Id, NewR),
   shasserisci(NoFr, SnY, fact(of, [arg:IdGov, specif:Id], 1,univ, univ)),
%   asserisci_topic_ref_func(NoFr, Gov, Pred, of, Resto, Id, SnY),
    !.

asserisci_proprieta(IdGov,LowW-T-_,NoFr,SnY,Resto, NewRefs, NewR):-
    recover_description(LowW, Pred),
    Pred\=LowW,
    get_id_mod(NoFr, LowW, Pred, NewRefs, SnY, Id, NewR),
   shasserisci(NoFr, SnY, fact(of, [arg:IdGov, specif:Id], 1,univ, univ)),
    !.

asserisci_proprieta(IdGov,LowW-T-_,NoFr,SnY,Resto, NewRefs, NewR):-
   (proprieta_sempl(IdGov,LowW)
     ;
     (jj(LowW);fct(LowW)),
     shasserisci(NoFr, SnY, fact(LowW, [nil:IdGov], 1,univ, univ))
     ;
     shcreatert(NoFr,class,[],SnY,LowW,Card,Quant,Num,Id,univ, univ),
     shdefault_properties(NoFr, Gen, SnY, Cats, LowW, Id,univ, univ),
     shasserisci(NoFr,SnY,fact(isa,[ind:Id,class:LowW],1,univ,univ))),
%    get_id_mod(NoFr, LowW, Pred, NewRefs, SnY, Id, NewR),
   asserisci_semp(NoFr, SnY, LowW, fact(of, [arg:IdGov, specif:Id], 1,univ, univ)),
    !.

asserisci_proprieta(IdGov,LowW,NoFr,SnY,Resto, NewRefs, NewR):-
    recover_description(LowW, Pred),
    Pred\=LowW,
    get_id_mod(NoFr, LowW, Pred, NewRefs, SnY, Id, NewR),
    shasserisci(NoFr, SnY, fact(of, [arg:IdGov, specif:Id], 1,univ, univ)),
    !.

asserisci_proprieta(IdGov,LowW,NoFr,SnY,Resto, NewRefs, NewR):-
   (proprieta_sempl(IdGov,LowW)
     ;
     (jj(LowW);fct(LowW)),
     shasserisci(NoFr, SnY, fact(LowW, [nil:IdGov], 1,univ, univ))
     ;
     shcreatert(NoFr,class,[],SnY,LowW,Card,Quant,Num,Id,univ, univ),
     shdefault_properties(NoFr, Gen, SnY, Cats, LowW, Id,univ, univ),
     shasserisci(NoFr,SnY,fact(isa,[ind:Id,class:LowW],1,univ,univ))),
%    get_id_mod(NoFr, LowW, Pred, NewRefs, SnY, Id, NewR),
   asserisci_semp(NoFr, SnY, LowW, fact(of, [arg:IdGov, specif:Id], 1,univ, univ)),
    !.

asserisci_semp(NoFr, SnY, Head,fact(of, [arg:IdGov, specif:Id], 1,univ, univ))
     :-
     (jj(Head);fct(Head)),!.

asserisci_semp(NoFr, SnY, Head,fact(of, [arg:IdGov, specif:Id], 1,univ, univ))
     :-
      shasserisci(NoFr, SnY, fact(of, [arg:IdGov, specif:Id], 1,univ, univ)),!.


write_preds_rols(Gov,[]):-!.
write_preds_rols(Gov,[N|Nodes]):-
   nodo(Nodo)::F/Role::nodo(N),
   nodo(N)::pred::Pred,
   RolSem=..[sr,F-Role,Gov,Pred],
   asserta(RolSem),
   write(RolSem),nl,
   write_preds_rols(Gov,Nodes),
   !.
write_preds_rols(Gov,[N|Nodes]):-
   write_preds_rols(Gov,Nodes),
   !.

write_preds_adjs(Gov,[]):-!.
write_preds_adjs(Gov,[Adj|Nodes]):-
   Adj=..[wff,Sem|Body],
   Body=[[I]],
   nodo(_)::adj/Role::pred::Sem,
   RolSem=..[sr,adj-Role,Gov,Sem],
   asserta(RolSem),
   write(RolSem),nl,
   write_preds_adjs(Gov,Nodes),
   !.
write_preds_adjs(Gov,[Adj|Nodes]):-
   Adj=..[wff,Sem|Body],
   Sem\=and,
   get_pred_body_adj(Body,Pred),
   get_role_adj(Sem,Role),
   RolSem=..[sr,adj-Role,Sem,Gov,Pred],
   asserta(RolSem),
   write(RolSem),nl,
   write_preds_adjs(Gov,Nodes),
   !.
write_preds_adjs(Gov,Adj):-
   Adj=..[wff,Sem|Body],
   Body=[[I]],
   nodo(_)::adj/Role::pred::Sem,
   RolSem=..[sr,adj-Role,Gov,Sem],
   asserta(RolSem),
   write(RolSem),nl,
   write_preds_adjs(Gov,Nodes),
   !.
write_preds_adjs(Gov,Adj):-
   Adj=..[wff,Sem|Body],
   Sem\=and,
   get_pred_body_adj(Body,Pred),
   get_role_adj(Sem,Role),
   RolSem=..[sr,adj-Role,Sem,Gov,Pred],
   asserta(RolSem),
   write(RolSem),nl,
   write_preds_adjs(Gov,Nodes),
   !.
write_preds_adjs(Gov,Adj):-
   Adj=..[wff,and|Body],
   Body=[Wff],
   write_preds_adjs(Gov,Wff),
   !.
write_preds_adjs(Gov,[Adj|Nodes]):-
   Adj=..[wff,and|Body],
   Body=[Wff],
   write_preds_adjs(Gov,Wff),
   write_preds_adjs(Gov,Nodes),
   !.
write_preds_adjs(Gov,[Adj|Nodes]):-
   Adj=..[wff,Sem|Body],
   Body=[Wff],
   Wff=[A],
   atomic(A),
   RolSem=..[sr,mod,Gov,Sem],
   asserta(RolSem),
   write(RolSem),nl,
   write_preds_adjs(Gov,Nodes),
   !.
write_preds_adjs(Gov,[N|Nodes]):-
   write_preds_adjs(Gov,Nodes),
   !.
write_preds_adjs(Gov,Adj):-!.

get_role_adj(Sem,Role):-
   nodo(_)::adj/Role::sem_mark::Sem,
   !.
get_role_adj(Sem,Role):-
   nodo(_)::adj/Role::pred::Sem,
   !.
get_role_adj(Sem,prop):-!.

get_pred_body_adj([Body],Pred):-
   Body=[Ind,Wff],
   atomic(Ind),
   Wff=..[wff,Pred|_],
   !.
get_pred_body_adj([Body],Pred):-
   Body=[Ind,Wff],
   \+ atomic(Ind),
   Ind=..[wff,isa,[In,Pred]|_],
   !.
get_pred_body_adj(Wff,Pred):-
   Wff=..[wff,and|Body],
   get_pred_body_adj(Body,Pred),
   !.
get_pred_body_adj([Body],Pred):-
   Body=[Ind,Term],
   Term=..[term,Pre,In, Wff],
   get_pred_body_adj(Wff,Pred),
   !.

find_forms(Nodo,Pred,Pre):-
   nodo(Nodo)::F/form::pred::PPred,
   F\=sogg,
   concat(Pred, '_', NPred),
   concat(NPred, PPred, Pre),
   assert(new_pred(Pred,Pre)),
   !.


/****************
crea_arg(+IndInfo, -Individual, +Location)

ARGUMENTS
   IndInfo      :arg/6 term. Info about Individual.
   Individual   :atom. Individual identifier.
   Location     :atom. Location identifier.
****************/

% risolto - altri
crea_arg(arg(Arg), Id, Temp, Loc) :- var(Arg),!.

crea_arg(arg(arg(SnX/NoFr,Testa,Def,Part,Card, Class,Num, Cat, F/Role)), Id, Temp, Loc) :- 
      var(SnX),
      referente(SnX,[],Id,Testa,Num,Card),
      !.

crea_arg(arg(SnX/NoFr,Testa,Def,Part,Card, Class,Num, Cat, F/Role), Id, Temp, Loc) 
    :- 
   nodo(N)::indice::SnX,
   (setof(N1-Type,
                   (nodo(N)::Type::nodo(N1), 
                        atomic(Type),
                        (Type=mods;Type=adjs)
                     ), Mods2)
       ; Mods2=[]), !
     ,
   (setof(N1-Type,
                   (nodo(N)::Type::nodo(_), N1=N, 
                        \+ atomic(Type),
                        notnodlg(N1, _/predic)
                     ), Mods1)
        ; Mods1=[]), !,
    (F/Role=_/Role1, (Role1=tema_bound;Role1=theme_bound), 
     nodo(NN)::F/Role::indice::SnX,
     append(Mods2,[NN-F/Role],Mods)
     ;
     F/Role=ogg/nil,
     nodo(NN)::adjs::F1/R1::ogg/nil::indice::SnX,
     append(Mods2,[NN-F1/R1],Mods)
    ;
     append(Mods1, Mods2, Mods)), 
       (   
        Mods\=[],on(Nod-_/poss, Mods),
        notnodo0(Nod, _/poss, controllore),
        Def1= + def, Part1=Part
        ;
        nodo(N)::spec::mod::Mod,
        Def1= + def, Part1=Part
        ;
        F/Role=ncomp/Theme,
        nodo(_)::adjs::ncomp/Theme::nodo(N),
        Def1= + def, Part1 = nil
        ;        
        Def1=Def, Part1=Part),
   abolish(ref/1),
   dynamic(ref/1),
   crearg(SnX/NoFr,Testa,Def1,Part1,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc).

crearg(SnX/NoFr,Testa,Def,Part,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc) 
    :- 
    1<NoFr,
    risolto(NoFr, SnX, Anaf, Testa),
      (Anaf=pPro,
       nodo(N)::pred::Testa,
       nodo(N)::num::Num1
       ;
       Anaf\=pPro,
       inherit_number(Anaf,SnX,Num1)
       ;
       Num1=Num),
    resarg(SnX/NoFr,Anaf,Testa,Def,Part,Card,Class,Num1,Cat,F/Role,Mods,Id,Temp, Loc),
    nonvar(Id),
    asserta(rcs(Testa,Id)),
    !.


crearg(SnX/NoFr,Testa,Def,Part,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc) 
    :- 
    trova_deitt(Testa,Num1),
    (bindantecedent_deicticpredication(ref_ex(SnX,Testa,[+ref,+def,nil,_,+pro,-ana,+class],Pers,Gen,Num,Cat,F/Role))
    ;
    Role=subj_disc),
    resarg(SnX/NoFr,Testa,indefinite,Def,Part,Card,Class,Num1,Cat,F/Role,Mods,Id,Temp, Loc),
    nonvar(Id),
    asserta(rcs(Testa,Id)),
     !.


crearg(SnX/NoFr,Testa,Def,Part,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc) 
    :- 
    exarg(SnX/NoFr,Testa,Def,Part,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc),
    nonvar(Id),
    asserta(rcs(Testa,Id)).

inherit_number(Testa,SnX,Num):-
       nodo(N)::pred::Testa,
       (nodo(N)::num::Num
        ;
        F/Role=sogg/tema_bound,
        nodo(NN)::F/Role::indice::SnY,
        nodo(NN)::F/Role::pred::Testa,
        nodo(N1)::sogg/nil::controllore::SnY,
        nodo(N1)::num::Num),
        !.
% Argomenti risolti da Risolvi1:
% Si cerca la Testa nel mondo
%  risolto - altri

search_infer_rel(NoFr, NStrc):-
         info(NoFr, Node, FunRole, View, Intens, Change, Rel, VerbCat, Verb,TempRel, DiscRel, DiscDom, SubjConsc),
         facts_sits(Verb, Ind, Args),
         NStrc=[Ind:Verb:Args],
         !.

facts_sits(Rel, Ind, Args):-
         (fact(Ind, Rel, Args,1,_,Loc1);
         sit(Ind, Rel, Args,1,_,Loc1)).

 
build_prop_ant(NoFr,[NoCl], [NStrc]) :-
         1<NoFr,
         (Args=[_:_]; Args=[_:_, _:_]; Args=[_:_, _:_, _:_]),
         disc_struc(At,
         PNoFr-NoCl, Topics, MainRel, Tint, TempRel, 
         DiscRel, I-Strc, SimplDiscDom, Point),
         functor(MainRel,Rel,_),
         facts_sits(Rel, Ind),
         NStrc=[Ind:Rel].

build_prop_ant(NoFr,[FCl|FCls], [NStrc|Rstr]) :-
         1<NoFr,
         (Args=[_:_]; Args=[_:_, _:_]; Args=[_:_, _:_, _:_]),
         Ats=..[At,N-N1],
         disc_struc(Ats,
         PNoFr-FCl, Topics, MainRel, Tint, TempRel, 
         DiscRel, I-Strc, SimplDiscDom, Point),
         functor(MainRel,Rel,_),
         facts_sits(Rel, Ind),
         NStrc=[Ind:Rel],
         build_prop_ant(PNoFr, FCls, Rstr).


relazione_suoce(NoFr, SnX, Idx, Temp, Loc):-
         1<NoFr,
         main_or_expect(NoFr, Id),
         fact(_, marry, [agente:Id, tema_aff:Idz],1,_,Loc1),
         fact(_,relat,[daughter,Idz,Id1],1,Temp1,Loc1),
         fact(_,isa, [ind:Id1, class:Testa], 1, Temp2, Loc2),
         asserisci(NoFr,SnX,fact(has_prop,[arg:Id1,arg:Idx],1,Temp, Loc)),
         asserisci(NoFr,SnX,fact(relat,[Testa,Id1,Idx],1,Temp, Loc)),!.

trova_deitt(Anaf,Num1):-
          gr(italiano),
         (Anaf=questi, Num1=plur
          ; 
          Anaf=questo, Num1=sing
          ;
          Anaf=quella, Num1=sing
          ;
          Anaf=quello, Num1=sing
          ;
          Anaf=quelle, Num1=plur
          ;
          Anaf=quelli, Num1=plur).

trova_deitt(Anaf,Num1):-
          gr(english),
         (Anaf=these, Num1=plur
          ; 
          Anaf=this, Num1=sing
          ;
          Anaf=that, Num1=sing
          ;
          Anaf=those, Num1=plur).

assertinclusions(NoFr, SnX, Id,[]):-!.
assertinclusions(NoFr, SnX, Id,[Idx]):-
          asserisci(NoFr, SnX, in(Id,Idx)),
          !.
assertinclusions(NoFr, SnX, Id,[Idx|Ids]):-
          asserisci(NoFr, SnX, in(Id,Idx)),
          assertinclusions(NoFr, SnX, Id,Ids),
          !.

resarg(SnX/NoFr,Anaf,Testa,_,Part,_, _,Num, Cat, _/_,Mods,Id,Temp, Loc) :- 
         ( member(Anaf,[i]), Card=1, Type=ind;
            member(Anaf,[we]), Card=5, Type=set ),
         !,
         creatert(NoFr,Type,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),         
         asserisci(NoFr,SnX,fact(isa,[ind:Id,class:narrator],1,Temp, Loc)),
         class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
         !.

resarg(SnX/NoFr,Anaf,Testa,_,Part,_, _,Num, Cat, _/_,Mods,Id,Temp, Loc) :- 
         ( member(Anaf,[others]);
            member(Anaf,[other]) ),
         !,
         trova_card(SnX, others, Part, _, _, Card),
         referente(SnX,[],Idx,Testa,plur,Card1),
         in(_,IdSubset,Idx),
         referente(SnX,[],IdSubset,Testa,_,CardSub),
         Card is Card1-CardSub,
         0<Card,
         creatert(NoFr,set,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),         
         asserisci(NoFr,SnX,fact(isa,[ind:Id,class:Testa],1,Temp, Loc)),
         asserisci(NoFr, SnX, in(Id,Idx)),
         !.

resarg(SnX/NoFr,Anaf,Testa,_,Part,Card, _,Num, _, _/_,Mods,Id,Temp, Loc) :- 
         member(Anaf,[some]),
         !,
         trova_card(SnX, some, Part, _, _, Card),
         referente(SnX,Mods,Idx,Testa,plur,Card1),
         in(_,IdSubset,Idx),
         referente(SnX,Mods,IdSubset,Testa,_,CardSub),
         Card is Card1-CardSub,
         0<Card,
         creatert(NoFr,set,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),         
         asserisci(NoFr,SnX,fact(isa,[ind:Id,class:Testa],1,Temp, Loc)),
         asserisci(NoFr, SnX, in(Id,Idx)),
         !.

% risolto card minore (maggiore)
resarg(SnX/NoFr,Anaf,Testa,_,Part,_, _,Num,_, _/_, Mods,Id,Temp, Loc) :- 
         member(Anaf,[elder]),
         trova_card(SnX, maggiore, Part, _, _, Card),
         referente(SnX,[],Idx,Testa,plur,Card1),
         Card < Card1,
         creatert(NoFr,ind,Mods,SnX,Testa,Card, Quant,Num,Id,Temp, Loc),
         asserisci(NoFr,SnX,fact(isa,[ind:Id,class:Testa],1,Temp, Loc)),
         asserisci(NoFr, SnX, in(Id,Idx)),
         asserisci(NoFr,SnX,fact(maggiore,[arg:Id,arg:Idx],1,Temp, Loc)),
         !.

/* 4 risolto plurale si cerca referente decomposto */
resarg(SnX/NoFr,Anaf,Testa,_,_,Card,_,Num,Cat,F/Role,Mods,Id,Temp, Loc) :-  
         member(Anaf,[them]),
         on(T1,Testa),
         on(T2,Testa), T2\=T1,
         referente(SnX,Mods,Idz,T1,Nu,1),
         referente(SnX,Mods,Idx,T2,Nu,1),
         creatert(NoFr,set,Mods,SnX,Testa,2, _,_,Id,Temp, Loc),
         asserisci(NoFr, SnX, in(Idz,Id)),
         asserisci(NoFr, SnX, in(Idx,Id)),
         asserisci(NoFr,SnX,fact(isa,[arg:Id,class:Cat],1,Temp, Loc)),
         asserisci(NoFr,SnX,fact(name,[Testa,Id],1,Temp, Loc)),
         !.   

% 5 risolto si cerca referente: si lega una proposizione
resarg(SnX/NoFr,Anaf,indefinite,+ def,_,_,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc) :-  
         trova_deitt(Anaf,Num1),
         1<NoFr,
         (Class= +class; Class= +me),
         PNoFr is NoFr - 1,
         search_infer_rel(PNoFr, NStrc),
         gen_sym(id, Id),
         asserisci(NoFr, SnX, ent(Id)),
         asserisci(NoFr,SnX,fact(prop,[arg:Id,disc_set:NStrc],1,Temp, Loc)),
         !.  

resarg(SnX/NoFr,Anaf,Testa,+ def,Part,Card0,+ class,Num,Cat,sub/compar,Mods,Id,Temp, Loc) :-  
         trova_card(SnX, Num, Part, _, _, Card),
         referente(SnX,Mods,Id,Testa,Num,Card),
         proprieta(Id,Prop),
         nodo(n1)::F/prop::pred::P,
         asserisci(NoFr, SnX, fact(P,[nil:Id],0,Temp, Loc)),         
         !.   

% 7 risolto si cerca referente di istituzioni
resarg(SnX/NoFr,Anaf,Testa,_,_,_,_,Num,Cat,F/Role,Mods,Id,Temp, Loc) :-
         collective_head(Testa),
         (nogen_member(istituzione,Cat); nogen_member(umano,Cat)),   
         (Num1=sing;Num1=plur),
         trova_card(SnX, Num1, Part, _, _, Card),
         referente(SnX,Mods,Id,Testa,Num1,Card).

% 7 risolto si cerca referente
resarg(SnX/NoFr,Anaf,Testa,_,_,_,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc) :-  
         Testa\=indefinite,
         (Anaf=you, 
         (Num1=sing;Num1=plur),
         trova_card(SnX, Num1, Part, _, _, Card)
         ;
         trova_deitt(Anaf,Num1),
         referente(SnX,Mods,Id,Testa,Num1,Card)
         ;
         Anaf=pPro,
         referente(SnX,Mods,Id,Testa,Num1,1),
         (ind(_, Id)
           ;
          genre(legal),
          (ent(_,Id)
            ;
           set(_,Id)
            ;
           class(_,Id)
           )
         )
         ;
        (Num=sing,
         trova_card(SnX, Num, Part, _, _, Card)
         ; 
         Num1=Num)
        ),
         (
          (nonvar(Card); Num1=plur),
          (var(Id),
           (Class= +class, Tes=Anaf
            ;
            Class\= +class, Tes=Testa),
           \+ ref(nil),
          (Tes=exist,ent(_,Id),
            referente(SnX,Mods,Id,Te,Nu,_)
            ;
           referente(SnX,Mods,Id,Tes,Num1,Card)),
           (Card\=1,
            individua_controllato(SnX, Id, Temp, Loc)
            ;
            Card=1,
            (ent(_,Id),
            individua_controllato(SnX, Id, Temp, Loc)
            )
            ;
            Num1=sing           
            ))
           ;
          Num1=sing,
          referente(SnX,Mods,Id,Testa,sing,Card)
           ;
          Num1=plur,
          var(Id),
          referente(SnX,Mods,Id,Testa,sing,Card),
          notcard(Id),
          notind(Id),
          individua_controllato(SnX, Id, Temp, Loc),
          asserisci(NoFr, SnX, set(Id)),
          asserisci(NoFr, SnX, card(Id,5))
           ;
          Num1=plur,
          var(Id),
          \+ ref(nil),
          referente(SnX,Mods,Id,Testa,Num1,_)
           ;
          Num1=plur,
          nonvar(Card),
          nonvar(Id)
           ;
          Num1=nil,
          nonvar(Id)
          ),
         !.   

resarg(SnX/NoFr,Anaf,Testa,+ def,_,_,- me,plur,Cat,F/Role,Mods,Id,Temp, Loc) :-  
     on(T, Testa),
     piu_recente(Id),
     set(_,Id),
     proprieta_rec(Idx,Tx),
    (Tx=T
     ;
    (proprieta(Idx,T),
     (Id=Idx;
      inclus_in(Idx,Id))
     ;
     proprieta(Idx,T1),
     proprieta(Idx,T2),
     T2\=T1,
     (T=T1;T=T2
      ;
     inclus_in(Idx,Id),
     proprieta(Idy,T)),
    (proprieta(Idy,T1);
     proprieta(Idy,T2))
     )).
     
/*
resarg(SnX/NoFr,Anaf,indefinite,+ def,_,_,_,Num,Cat,F/Role,Mods,Id,Temp, Loc) :-  
        \+ trova_deitt(Anaf,Num),         
         gen_sym(id, Id),
         (Num=plur,
           asserisci(NoFr, SnX, set(Id)),
           asserisci(NoFr, SnX, card(Id,5));
           asserisci(NoFr, SnX, ind(Id))),          
         default_properties(NoFr, SnX, Cat, Pred, Id, Temp, Loc),
         !.   
*/

/* se l'argomento  indefinito si cerca di asserire un nuovo individuo nel mondo 
  altrimenti, se  definito si cerca un individuo nel mondo */

exarg(SnX/NoFr,Testa,def0,nil,Card,Class,Num,Cat,F/Role,Mods,Id,Temp,Loc) 
    :-
       trova_card(SnX,Num,nil,Quant,Card,Card0),
       prarg(SnX/NoFr,Testa,def0,nil,Quant,Card,Card0,Class,Num,Cat,F/Role,Mods,Id,Temp,Loc),!.

exarg(SnX/NoFr,Testa,Def,nil,Card,Class,Num,Cat,F/Role,Mods,Id,Temp,Loc) 
    :-
       (Class = -class; 
        Class = +class),
       (Def = +def
        ; Def = def0), 
       oldarg(SnX/NoFr,Testa,[Def,nil,Card,Class,Num,Cat,F/Role],Mods,Id,Temp,Loc),!.

exarg(SnX/NoFr,Testa,Def,nil,Card,Class,Num,Cat,F/Role,Mods,Id,Temp,Loc) 
    :-
       (Class = -class; 
        Class = +class),
       (Def = +def
        ; Def = def0), 
       oldarg1(SnX/NoFr,Testa,[Def,nil,Card,Class,Num,Cat,F/Role],Mods,Id,Temp,Loc),!.

exarg(SnX/NoFr,Testa,Def,Part,Card,Class,Num,Cat,F/Role,Mods,Id,Temp,Loc) 
    :-
     Role\=prop, Role\=compar,
       nonvar(Def),nonvar(Class),
       Part\=nil,
       (Class = +me; Class = +class), 
       (Testa=exist
        ;
        Testa\=exist,
        trova_card(SnX, Num, Part, Quant, Card, Card0)),
       qarg(SnX/NoFr,Testa,Def,Quant,Card0,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc),!.

exarg(SnX/NoFr,Testa,Def,Part,Card,Class,Num,Cat,F/Role,Mods,Id,Temp,Loc) 
    :-
       Def \= +def, 
       Testa\=exist,
       narg(SnX/NoFr,Testa,Def,Part,Card,Class,Num,Cat,F/Role,Mods,Id,Temp,Loc),!.

define_card(some, set):-!.
define_card(nil, class):-!.
define_card(Card, Type):-
   Card\=nil,
   (Card=1, Type=ind
    ; Type=set).

match_properties_and_mods(Id, Pred, Card, [], Type):-
    (
     infer_prop_class(Id,Pred), 
       define_card(Card, Type)
     ;
     proprieta_compl(Id,Pred),
    (Mods=[], Type=class, 
       define_card(Card, Type)
     ;
     Mods\=[], 
       define_card(Card, Type))
     ),
     !.

match_properties_and_mods(Ind, Pred, Card, Mods, Type):-
    Mods\=[],
    on(N-mods,Mods),
    setof(P, proprieta(Ind, P), PP),
    findall_mod_restriz(N,Res),
    Res\=[],
    on(Pr-_,Res),
    on(Pr,PP),!.     

prarg(SnX/NoFr,Testa,Def,Part,Quant,Card0,Card,Class,Num,Cat,F/R,Mods,Ind,Temp,Loc)
   :-  
   \+ ref(nil),
   coreferens(SnX, NoFr, Testa, Num, Mods, Id),
   match_properties_and_mods(Id, Pred, Card, Mods, Type),
    (Pred=Testa, 
      Ind=Id
%      Ind=Id, Card0=nil
     ;
     Pred\=Testa,
     (match_tops_descriptions(Testa,Pred,New),
      list(Testa), 
      Ind=Id
     ;
     creatert(NoFr,Type,Mods,SnX,Testa,Card,Quant,Num,Ind,Temp, Loc),
     class_props(NoFr, SnX, Cat, Ind, fact, isa, Testa, 1, Temp, Loc),
     asserisci(NoFr, SnX, in(Ind, Id)))
   ),    
   !.

% 28 nome con def0 in genre legal
prarg(SnX/NoFr,Testa,Def,Part,Quant,Card0,Card,Class,Num,Cat,F/R,Mods,Ind,Temp,Loc)
   :-  
   \+ ref(nil),
   (var(Card), trova_card(SnX,Num,Part, Quant, Card0,Card); nonvar(Card)),
    Part=nil,
    recover_description(Testa, Pred),
    match_properties_and_mods(Id, Pred, Card, Mods, Type),
    creatert(NoFr,Type,Mods,SnX,Pred,Card,Quant,Num,Ind,Temp, Loc),
    class_props(NoFr, SnX, Cat, Ind, fact, isa, Pred, 1, Temp, Loc),
    asserisci(NoFr, SnX, in(Ind, Id)),
    !.

prarg(SnX/NoFr,Testa,Def,Part,Quant,Card0,Card,Class,Num,Cat,F/R,Mods,Id,Temp,Loc):-
    (Mods=[], 
       define_card(Card, Type)
     ;
     Mods\=[], 
       define_card(Card, Type)),
    ( Num=plur,
     creatert(NoFr,Type,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
     class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc)
     ;
     (Num=sing;Num=nil),
       Class\= +me,
      shassert_names(NoFr,Cat,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc)
   ),
   !.   

/* nomi propri */
% 20 class+ e def0 con un role=comparativo si suppone nuovo
prarg(SnX/NoFr,Testa,Def,_,Quant,_,Card,Class,Num,Cat,F/comparativa,Mods,Ind,Temp, Loc):-  
   main_or_expect(NoFr1, Ind),
   restrizioni(NoFr, Mods, SnX, Ind, Temp, Loc),
   asserisci(NoFr, SnX, ind(Ind)), % EP 93.01.12
   class_props(NoFr, SnX, Cat, Ind, fact, isa, Testa, 1, Temp, Loc),
   !.   

% 21 nome proprio gia nominato
prarg(SnX/NoFr,Testa,Def,Part,Quant,_,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc):-  
   (Class= +class, Num=sing
    ;
    Class= -class),
           \+ ref(nil),
   refer_propr(Id,Testa,Num,Card),
   restrizioni(NoFr, Mods, SnX, Id, Temp, Loc),
   !.   

prarg(SnX/NoFr,Testa,Def,Part,Quant,_,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc):-  
   Class\= +class,
           \+ ref(nil),
   c_referente(SnX,Mods,Id,Testa,Num,Card),
   !.   

% 23 nome proprio ncomp
prarg(SnX/NoFr,Testa,Def,_,_,_,_,Class,sing,Cat,ncomp/prop,Mods,Idx,Temp, Loc):-  
   1<NoFr,
   (Role=tema_bound;Role=theme_bound),
   nodo(N)::_/Role::antecedente::An,
   topic(NoFr,_,Id),
   creatert(NoFr,ind,Mods,SnX, Testa,Card,Quant,Num,Idx,Temp, Loc),
   asserisci(NoFr, SnX, fact(role, [Testa, Idx, Id], 1, Temp, Loc)),
   class_props(NoFr, SnX, Cat, Idx, fact, isa, Testa, 1, Temp, Loc),
   asserisci(NoFr, SnX, fact(Testa,[nil:Id], 1, Temp, Loc)),
   !. 

prarg(SnX/NoFr,Testa,Def,_,Quant,_,Card,Class,sing,Cat,F/Role,Mods,Idn,Temp, Loc):-
   1<NoFr,
   Class = -class, 
   topic(NoFr,_,Id),
           \+ ref(nil),
   referen_plur(Id,Testa1,plur,Card2,Idx),
   fact(_,relat,[Testa1,Idz,Idx],1,_,_),
   creatert(NoFr,name,Mods,SnX, Testa,Card,Quant,Num,Idn,Temp, Loc),
   asserisci(NoFr, SnX, in(Idn,Idx)),
   class_props(NoFr, SnX, Cat, Idn, fact, name, Testa, 1, univ, univ),
   !.

prarg(SnX/NoFr,Testa,Def,_,Quant,_,Card,Class,sing,Cat,sogg/poss,Mods,Idn,Temp, Loc) 
   :-
   1<NoFr,
   Class = -class,
   nodo(N)::sogg/poss::indice::SnX,
   nodo(N)::cat::Cat1,
   (nogen_member(relazionale,Cat1); 
    nogen_member(relat,Cat1)), 
   nodo(N)::pred::Rel,
   topic(NoFr,_,Id),
   fact(_,Rel,[_:Id],1,_,_),
   creatert(NoFr,name,Mods,SnX,Testa,Card,Quant,Num,Idn,Temp, Loc),
   class_props(NoFr, SnX, Cat, Idn, fact, name, Testa, 1, univ, univ),
   Id\=Idn,
   asserisci(NoFr, SnX, fact(relat, [Rel, Idn, Id], 1, Temp, Loc)),
   !.

% 25 nome proprio si suppone nuovo
prarg(SnX/NoFr,Testa,Def,Part,Quant,_,Card,-class,Num,Cat,F/Role,Mods,Id,Temp, Loc)
   :-  
   creatert(NoFr,name,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
   class_props(NoFr, SnX, Cat, Id, fact, name, Testa, 1, univ, univ),
   !.   

% 28 nome comune apposizione
prarg(SnX/NoFr,Testa,Def,Part,Quant,Card0,Card,+class,Num,Cat,ncomp/Tema,Mods,Id,Temp, Loc)
   :-  
   (Tema=tema;Tema=theme),
   trova_card(SnX,Num,Part, Quant, Card0,Card),
           \+ ref(nil),
   c_referente(SnX,Mods,Id,Testa,Num,Card),
   default_properties(NoFr, SnX, Cat, Pred, Id, Temp, Loc),
   !.   

prarg(SnX/NoFr,Testa,Def,Part,Quant,_,Card,+class,plur,Cat,F/Role,Mods,Id,Temp, Loc)
   :-  
    (infer_prop_sempl(Ind,Testa)
     ;
     infer_prop_class(Ind,Testa)),
     creatert(NoFr,class,Mods,SnX,Testa,Card, Quant,Num,Id,Temp, Loc),
     asserisci(NoFr, SnX, in(Ind, Id)),
     class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
     !.

prarg(SnX/1,Testa,Def,Part,Quant,_,Card,+class,plur,Cat,F/Role,Mods,Id,Temp, Loc)
   :-  
     Card\=nil,
     creatert(NoFr,set,Mods,SnX,Testa,Card, Quant,Num,Id,Temp, Loc),
     class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
     !.

prarg(SnX/NoFr,Testa,Def,Part,Quant,_,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc):-  
     creatert(NoFr,class,Mods,SnX,Testa,Card, Quant,Num,Id,Temp, Loc),
     class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
     !.

assert_names(NoFr,Cat,Mods,SnX,[],Card,Quant,Num,[],Temp, Loc):-!.
assert_names(NoFr,Cat,Mods,SnX,Testas,Card,Quant,Num,Id,Temp, Loc):-
     list(Testas),
     nogen_member(umano, Cat), \+ nogen_member(plant,Cat),
     reverse(Testas, [Testa,Surn]),
     wn(Testa,Scats),
     (\+ nogen_member(mat,Scats),
      (nogen_member(nmf,Scats), Pred=woman;
      (nogen_member(nmm,Scats);nogen_member(sur,Scats)),
        Pred=man)
       ;
       nogen_member(mat,Scats), Pred=plant
       ),
     recover_description(Testas, Preds),
     creatert(NoFr,name,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
     asserisci(NoFr, SnX, fact(inst_of,[ind:Id, class:Pred], 1, univ, univ)),
     asserisci(NoFr, SnX, fact(isa,[ind:Id, class:Preds], 1, univ, univ)),
     asserisci(NoFr,SnX,fact(name,[Testa, Id],1,univ, univ)),
     asserisci(NoFr,SnX,fact(name,[Surn, Id],1,univ, univ)),
     !.

assert_names(NoFr,Cat,Mods,SnX,Testas,Card,Quant,Num,Id,Temp, Loc):-
     list(Testas),
     reverse(Testas, [Testa,Surn]),
     recover_description(Testas, Preds),
     creatert(NoFr,name,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
     default_properties(NoFr, SnX, Cat, Pred, Id, Temp, Loc),
     asserisci(NoFr, SnX, fact(inst_of,[ind:Id, class:Testa], 1, univ, univ)),
     asserisci(NoFr, SnX, fact(isa,[ind:Id, class:Testa], 1, univ, univ)),
     asserisci(NoFr, SnX, fact(isa,[ind:Id, class:Preds], 1, univ, univ)),
     creatert(NoFr,class,Mods,SnX,Surn,Card,Quant,Num,Idy,Temp, Loc),
     asserisci(NoFr, SnX, fact(isa,[ind:Idy, class:Surn], 1, univ, univ)),
     asserisci(NoFr,SnX,fact(of,[arg:Idy, specif:Id],1,univ, univ)),
     !.

assert_names(NoFr,Cat,Mods,SnX,Testas,Card,Quant,Num,Idx,Temp, Loc):-
     (Testas=.. [and|Teste]
      ;Testas=.. [or|Teste]),
     Teste=[Testae],
     reverse(Testae, [Testa,Surn]),
     creater_coo(NoFr,set,[],SnX,Testae,2,Quant,Num,Idx,univ, univ),
     creatert(NoFr,class,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
     asserisci(NoFr, SnX, fact(inst_of,[ind:Id, class:Cat], 1, univ, univ)),
     asserisci(NoFr, SnX, fact(isa,[ind:Id, class:Testa], 1, univ, univ)),
     creatert(NoFr,class,Mods,SnX,Surn,Card,Quant,Num,Idy,Temp, Loc),
     asserisci(NoFr, SnX, fact(inst_of,[ind:Idy, class:Cat], 1, univ, univ)),
     asserisci(NoFr, SnX, fact(isa,[ind:Idy, class:Surn], 1, univ, univ)),
     asserisci(NoFr, SnY, in(Id,Idx)),
     asserisci(NoFr, SnX, in(Idy,Idx)),
     !.

assert_names(NoFr,Cat,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc):-
     Testa=[Test],
     creatert(NoFr,class,Mods,SnX,Test,Card,Quant,Num,Id,Temp, Loc),
     class_props(NoFr, SnX, Cat, Id, fact, isa, Test, 1, Temp, Loc),
     !.

assert_listnames(NoFr,Cat,Mods,SnX,[],Card,Quant,Num,[],Temp, Loc):-!.
assert_listnames(NoFr,Cat,Mods,SnX,[Test|Testa],Card,Quant,Num,[Id|Ids],Temp, Loc):-
     if_first_name(Test),
     creatert(NoFr,ind,Mods,SnX,Test,Card,Quant,Num,Id,Temp, Loc),
     class_props(NoFr, SnX, Cat, Id, fact, isa, Test, 1, Temp, Loc),
     asserisci(NoFr,SnX,fact(name,[Test, Id],1,univ, univ)),
     assert_listnames(NoFr,Cat,Mods,SnX,Testa,Card,Quant,Num,Ids,Temp, Loc),
     !.
assert_listnames(NoFr,Cat,Mods,SnX,[Test|Testa],Card,Quant,Num,[Id|Ids],Temp, Loc):-
     creatert(NoFr,ind,Mods,SnX,Test,Card,Quant,Num,Id,Temp, Loc),
     class_props(NoFr, SnX, Cat, Id, fact, isa, Test, 1, Temp, Loc),
     assert_listnames(NoFr,Cat,Mods,SnX,Testa,Card,Quant,Num,Ids,Temp, Loc),
     !.

default_properties(NoFr, SnX, Cat, Pred, Ind, Temp, Loc) 
  :-
  nonvar(Ind),
  (
  (nodo(N)::F/R::indice::SnX,
   nodo(N)::F/R::gen::Gen,
   nonvar(Gen)
   ;
   nodo(N0)::F/tema_bound::indice::SnX,
   nodo(N0)::F1/prop::indice::SnY,
   nodo(N0)::F1/prop::gen::Gen,
   nonvar(Gen)
   ;
   Gen=mas
   ;
   gr(english)
   ),
   (
   nogen_member(hum_set,Cat),
   (gr(english), Pred=coll; gr(italiano), Pred=coll),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   (nogen_member(instit,Cat);nogen_member(istituzione,Cat)),
   (gr(english), Pred=institution; gr(italiano), Pred=istituzione),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(legale,Cat),
   (gr(english), Pred=legal; gr(italiano), Pred=giuridico),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(plant,Cat),
   (gr(english), Pred=plant_life; gr(italiano), Pred=creatura_viv),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(istituzione,Cat),
   (gr(english), Pred=institution; gr(italiano), Pred=istituzione),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(data,Cat),
   (gr(english), Pred=date; gr(italiano), Pred=data),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(sostanza,Cat),
   (gr(english), Pred=substance; gr(italiano), Pred=sostanza),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(ferocious,Cat),
   (gr(english), Pred=ferocious_animal; gr(italiano), Pred=animale_feroce),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(edible,Cat),
   nogen_member(sostanza,Cat),
   (gr(english), Pred=edible_substance; gr(italiano), Pred=sostanza_cibo),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(edible,Cat),
   (gr(english), Pred=edible_animal; gr(italiano), Pred=animale_cibo),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(animato,Cat), notmembro(umano, Cat),
   (gr(english), Pred=animal; gr(italiano), Pred=animale),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
    nogen_member(umano,Cat), Gen=mas,
   (gr(english), Pred=man; gr(italiano), Pred=uomo),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(umano,Cat), Gen=fem,
   (gr(english), Pred=woman; gr(italiano), Pred=donna),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1,univ, univ))
    ;
   nogen_member(luogo,Cat),
   (gr(english), Pred=place; gr(italiano), Pred=luogo),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(descrittivo,Cat),
   (gr(english), Pred=descriptive; gr(italiano), Pred=descrittivo),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1,univ, univ))
    ;
   nogen_member(mil,Cat),
   (gr(english), Pred=military; gr(italiano), Pred=militare),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1,univ, univ))
    ;
   nogen_member(oggetto,Cat),
   (gr(english), Pred=thing; gr(italiano), Pred=cosa),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(astratto,Cat),
   (gr(english), Pred=abstract_state; gr(italiano), Pred=stato_astratto),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(Ct,Cat),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Ct], 1, univ, univ))
   ;
   nonvar(R), 
   asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:R], 1, univ, univ))
    )
   ;
   Cat=nil,
   trova_CatSem(_,Pred,Cats),
   nogen_member(Ct,Cats),
    asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Ct], 1, univ, univ))
   ;
   (nonvar(Pred),
    (Cat\=nil,
     nogen_member(Ct,Cat)
     ;
     Cat=nil,
     nattributes(Pred,Ct))
    ;
    var(Pred),
    (atomic(Cat), Cat\=nil, Ct=Cat
        ;
        is_list(Cat),nogen_member(Ct,Cat)
        ;
        Cat=nil
        ), 
    Pred=Ct),
   asserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Cat], 1, univ, univ))
   ),!.

nattributes(Pred,quant):-
   nm(Pred,_,_)
   ;
   nm(_,_,Pred)
   ;
   grammw(Pred,_),
   !.
nattributes(Ct,Ct):-
   !.

/*  quantificatori, quantificatori universali */
qarg(SnX/NoFr,exist,Def,Quant,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc):-
   nodo(N0)::fcomp/R::F/Role::indice::SnX,
   nodo(N0)::cat::presuppositivo,
   nodo(N1)::F/Role::indice::SnX,
   nodo(N1)::pred::Rel,
   fact(_,Rel,[Role:Id, R2:_, R3:_],1,_,_),  
   fact(_,name,[Tes,Id],1,_,_),  
   fact(_,inst_of,[ind:Id, class:Te],1,_,_),  
   !.

qarg(SnX/NoFr,exist,Def,Quant,Card,Class,Num,Cat,Func/goal,Mods,Id,Temp, Loc):-
   1<NoFr,
   (Main=main;Main=secondary),
   confer_topic(NoFrP, Main, Id, Cont, _),
   referentes(SnX,Mods,Id,Ref,Nu,1),
   fact(_,inst_of,[ind:Id, class:Te],1,_,_),
   match_default_cats(Cat,Te),
   !.

qarg(SnX/NoFr,Testa,Def,Quant,Card,Class,Num,Cat,F/Role,Mods,Ind,Temp, Loc):-
         Testa\=exist,
          (
           \+ ref(nil),
           c_referente(SnX,Mods,Ind,Testa,Num,Card)
           ;
           infer_prop_sempl(Ind,Testa)
           ;
           infer_prop_class(Ind,Testa)
           ;
          proprieta_compl(Ind,Testa)),
        (Card\=nil,
         creatertq(NoFr,class,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
         default_properties(NoFr, SnX, Cat, Pred, Id, Temp, Loc),
         asserisci(NoFr,SnX,fact(isa,[ind:Id,class:Testa],1,Temp, Loc)),
         asserisci(NoFr, SnX, in(Id, Ind))
         ;
         Card=nil
         ),
          !.

qarg(SnX/NoFr,Testa,Def,Quant,Card,Class,Num,Cat,ogg/Role,Mods,Id,Temp, Loc):-
   1<NoFr,
   Card=nil,
   Testa\=exist,
   nodo(N)::ogg/Role::indice::SnX,
   nodo(N)::sogg/nil::controllore::Cont,
   confer_topic(NoFr, _, Ind, Cont, _),
   creatertq(NoFr,class,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
   default_properties(NoFr, SnX, Cat, Pred, Id, Temp, Loc),
   asserisci(NoFr,SnX,fact(isa,[ind:Id,class:Testa],1,Temp, Loc)),
   restrizioni(NoFr, N, SnX, Ind, Temp, Loc),
   !.

% 18 Quantificatore si arbitrario 
qarg(SnX/NoFr,si,Def,Quant,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc):-
   creatertq(NoFr,class,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
   default_properties(NoFr, SnX, Cat, Pred, Id, Temp, Loc),
   asserisci(NoFr,SnX,fact(isa,[ind:Id,class:Pred],1,univ,univ)),
   !.

% 19 Quantificatori esistenziali e arbitrari 
qarg(SnX/NoFr,Testa,+def,Quant,Card,Class,plur,Cat,F/Role,Mods,Id,Temp, Loc):-
   \+ integer(Card),
   Testa\=exist,
   creatertq(NoFr,set,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
   default_properties(NoFr, SnX, Cat, Pred, Id, Temp, Loc),
   (quantif(Testa), Quan=Pred
     ;
    \+ quantif(Testa), Quan=Testa),
    asserisci(NoFr,SnX,fact(isa,[ind:Id,class:Quan],1,univ,univ)),
   !.

qarg(SnX/NoFr,Testa,Def,Quant,Card,Class,plur,Cat,F/Role,Mods,Id,Temp, Loc):-
   Card=nil,
   Testa\=exist,
   creatertq(NoFr,class,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
   default_properties(NoFr, SnX, Cat, Pred, Id, Temp, Loc),
   (quantif(Testa), Quan=Pred
     ;
    \+ quantif(Testa), Quan=Testa),
    asserisci(NoFr,SnX,fact(isa,[ind:Id,class:Quan],1,univ,univ)),
   !.

% 20 Quantificatori universali 
qarg(SnX/NoFr,Testa,Def,Quant,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc):-
   (integer(Card);nm(Card,_,_)),
   (Num=sing;Num=plur),
   Testa\=exist,
   creatertq(NoFr,class,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
   default_properties(NoFr, SnX, Cat, Pred, Id, Temp, Loc),
   (quantif(Testa), Quan=Pred,
    asserisci(NoFr,SnX,fact(isa,[ind:Id,class:Quan],1,univ,univ))
     ;
    \+ quantif(Testa), Quan=Testa),
   infer_prop_sempl(Ind,Propp),
   asserisci(NoFr, SnX, in(Ind, Id)),
   !.

% 26 nome comune indefinito quantificato si suppone nuovo
qarg(SnX/NoFr,Testa,Def,Quant,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc):-
   (integer(Card),
     1 < Card ; Card\=nil),
   Class= +class, (Num=sing, Type=ind; Num=plur, Type=set),
   creatertq(NoFr,Type,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
   class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
   !. 

qarg(SnX/NoFr,Testa,Def,Quant,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc):-
   \+ integer(Card),
   Testa\=exist,
   quantif(Testa),
   Mods\=[],
   recover_restr(Mods, Restrs),
   on(Pred, Restrs),
   (         
     c_referente(SnX,Mods,Ind,Pred,Num,Card)
           ;
           infer_prop_sempl(Ind,Pred), Type=class
           ;
          match_properties_and_mods(Id, Pred, Card, Mods, Type),
          creatertq(NoFr,Type,[],SnX,Pred,Card, Quant,Num,Id,Temp, Loc),
          (negq(Testa),Pol=0;Pol=1),
          class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, Pol, Temp, Loc)
          ;
          \+ quantif(Pred),         
          (negq(Testa),Pol=0;Pol=1),
          creatertq(NoFr,class,[],SnX,Pred,Card,Quant,Num,Id,Temp, Loc),
          class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, Pol, Temp, Loc)),
          asserisci(NoFr, SnX, in(Id, Ind)),!.

qarg(SnX/NoFr,Testa,Def,Quant,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc):-
   Card=nil,
   Testa\=exist,
   \+ quantif(Testa),
   creatertq(NoFr,class,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
   default_properties(NoFr, SnX, Cat, Pred, Id, Temp, Loc),
   (on(neg,Cat), Pol=0;
    Card=any, Pol=0;
     Pol=1),
   asserisci(NoFr,SnX,fact(isa,[ind:Id,class:Testa],Pol,univ,univ)),
   !.
  
qarg(SnX/NoFr,Testa,Def,Quant,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc):-
   \+ integer(Card),
   Testa\=exist,
   (negq(Card),Pol=0;Pol=1),
   (Num=sing, Type=ind; Num=plur, Type=set),
   creatertq(NoFr,Type,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
   class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, Pol, Temp, Loc),
   !. 

memothers(Args, [], NoFr, Id) :-!.
memothers(Args, [Altro/P|Altri], NoFr, Id) :-
   legalpotopic(NoFr, Altro, SnX, Altri1, Role),
   once(mcrea_arg(Costs, Altri1, AltriInd, univ, univ)),
   asserisci_topic(NoFr, potential, AltriInd, SnX),
   asserisci_agg(NoFr,SnX,fact(adj,[arg:AltriInd, Role:Id],1,univ, univ)),
   memothers(Args, Altri, NoFr, Id),
   !.
memothers(Args, [Altro/P|Altri], NoFr, Id) :-
   memothers(Args, Altri, NoFr, Id),
   !.
legalpotopic(NF, X, SnX, Arg, R):-  
   X=ref_ex(SnX,Testa,Tab,_,Gen,Num,Cat,F/R),
   Tab=[Ref, Def, Part, Card, _, _, Class],
   Ref = + ref,
   Arg=arg(SnX/NF, Testa, Def, Part, Card, Class, Num, Cat, F/R),
   !.

mcrea_arg(Cost, Arg, Id, Temp, Loc) :-
       Arg=.. [arg|Argg], 
       var(Argg),!.

mcrea_arg(Cost, Arg, Id, Temp, Loc) :- 
      Arg=.. [arg|Argg], 
      Argg=[arg(SnX/NoFr,Testa,Def,Part,Card, Class,Num, Cat, F/Role)],
      var(SnX),
      referente(SnX,[],Id,Testa,Num,Card),
      !.

mcrea_arg(Cost, Arg, Id, Temp, Loc) 
    :- 
    Arg=.. [arg|Argg], 
    Argg=[SnX/NoFr,Testa,Def,Part,Card, Class,Num, Cat, F/Role],
    dynamic(ref/1),
    recover_modifiers(Cost, SnX, Mods),
    crearg(SnX/NoFr,Testa,Def,Part,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc).

memorizza_rels(NoFr, Lfs, Rels) :-
   relations(Lfs, Rels),
   genre_locations(NoFr, TimeId, LocId),
   assert_rels(Rels, _, NoFr, TimeId, LocId, _, rels),
   relassert_performatives(NoFr, Rels, TimeId, LocId),
   !.
memorizza_rels(_, _, _).

/*
genre_locations(NoFr, univ, univ):-
   genre(legal),
   !.
*/

genre_locations(NoFr, TimeId, LocId):-
   genre_locationt(NoFr, TimeId),
   genre_locations(NoFr, LocId),
   !.

genre_locationt(NoFr, TimeId):-
   current_main_loc(NoFr, tempo, TimeInfo),
   arg(1, TimeInfo, TimeId),!.
genre_locationt(NoFr, univ).

genre_locations(NoFr, LocId):-
   current_main_loc(NoFr, luogo, LocInfo),
   arg(1, LocInfo, LocId),!.
genre_locations(NoFr, univ).

assert_modality(NoFr, Rel, InfonId, Loc, Temp):-
   nodo(Node)::supporto::Modal,
   modality(Modal,Modality),
   Infon=..[fact, InfonType, Modality, Arg, 1, Temp, Loc], 
   gen_sym(infon, InfonType),
   gen_sym(id, Ind),
   Arg=[arg:Ind, Modality:InfonId], 
   assert(Infon),   
   assert(confer_infon(InfonType, NoFr, nil, nil, secondary)),
   !.

assert_modality(NoFr, Rel, InfonId, Loc, Temp):-!.

assert_performative(NoFr, Rel, InfonId, Loc, Temp):-
   nodo(Node)::perf::Perform,
   Infon=..[fact, InfonType, perf, Arg, 1, Temp, Loc], 
   gen_sym(infon, InfonType),
   gen_sym(id, Ind),
   Arg=[arg:Ind, Perform:InfonId], 
   assert(Infon),   
   assert(confer_infon(InfonType, NoFr, nil, nil, secondary)),
   !.

assert_performative(NoFr, Rel, InfonId, Loc, Temp):-!.


/**************
assert_rels(
   Infon, FactType, NoFr, TimeId, LocId, Role, RelsType) 
**************/
/* 
Relazione tra una main semplice e un aggiunto
*/
assert_rels(Infon, fact, NoFr, TimeId, LocId, Role, RelsType) 
  :-
  Infon=infon(Q,Inf,Rel,[Main, Adj], R, Pol),
  Main=infon(_,_,main,[Sit1],_,_),
  Adj=infon(_,_,adj,[Sit2],_,_),
  Sit1 \= and(_),
  Sit2 \= and(_),
  NewInfon=infon(Q,Inf,Rel,[Sit1, Sit2], R, Pol),
  assert_rels(NewInfon, fact, NoFr, TimeId, LocId, Role, RelsType).

/* 
Relazione tra un main coordinato e un aggiunto
*/
assert_rels(Infon, fact, NoFr, TimeId, LocId, Role, RelsType) 
  :-
  Infon=infon(Q,Inf,Rel,[Main, Adj], R, Pol),
  Main=infon(_,_,main,[and([Sit1, Sit2])],_,_),
  Adj=infon(_,_,adj,[AdjSit],_,_),
  NewInfon1=infon(Q,Inf,Rel,[Sit1, AdjSit], R, Pol),
  NewInfon2=infon(Q,Inf,Rel,[Sit2, AdjSit], R, Pol),
  assert_rels(NewInfon1, fact, NoFr, TimeId, LocId, Role, RelsType),
  assert_rels(NewInfon2, fact, NoFr, TimeId, LocId, Role, RelsType).

/* 
Relazione tra un main e un aggiunto coordinato
*/
assert_rels(Infon, fact, NoFr, TimeId, LocId, Role, RelsType) 
  :-
  Infon=infon(Q,Inf,Rel,[Main, Adj], R, Pol),
  Main=infon(_,_,main,[MainSit],_,_),
  Adj=infon(_,_,adj,[and([Sit1, Sit2])],_,_),
  NewInfon1=infon(Q,Inf,Rel,[MainSit, Sit1], R, Pol),
  NewInfon2=infon(Q,Inf,Rel,[MainSit, Sit2], R, Pol),
  assert_rels(NewInfon1, fact, NoFr, TimeId, LocId, Role, RelsType),
  assert_rels(NewInfon2, fact, NoFr, TimeId, LocId, Role, RelsType).

/* 
Aggiunto main coordinata
*/
assert_rels(Infon, fact, NoFr, TimeId, LocId, Role, RelsType) 
  :-
  Infon=infon(Q,Inf,Rel,[Adj], R, Pol),
  Adj=infon(_,_,adj,[and([Sit1, Sit2])],_,_),
  NewInfon1=infon(Q,Inf,Rel,[Sit1], R, Pol),
  NewInfon2=infon(Q,Inf,Rel,[Sit2], R, Pol),
  assert_rels(NewInfon1, fact, NoFr, TimeId, LocId, Role, RelsType),
  assert_rels(NewInfon2, fact, NoFr, TimeId, LocId, Role, RelsType).

/* 
Aggiunto main semplice
*/
assert_rels(Infon, fact, NoFr, TimeId, LocId, Role, RelsType) 
  :-
  Infon=infon(Q,Inf,Rel,[Adj], R, Pol),
  Adj=infon(_,_,adj,[Sit1],_,_),
  NewInfon=infon(Q,Inf,Rel,[Sit1], R, Pol),
  assert_rels(NewInfon, fact, NoFr, TimeId, LocId, Role, RelsType).

assert_rels([], _, _, _, _, _, _) .

/*
assert_rels(
   infon(att, Inf, time, Args, AttRestr, Pol),
   Type, NoFr, TimeId, LocId, Role, ev_restr) 
  :-
  Args=[Ev, ind(TQuant, T, TRestr, Role)],
  assert_quantifier
  assert_rels(NewInfon, Type, NoFr, TimeId, LocId, Role, RelsType).
*/

assert_rels(
   and([A | B]), Type, 
   NoFr, Time, Loc, _, RelsType) 
   :-
   assert_rels(A, Type, NoFr, Time, Loc, _, RelsType),
   assert_rels(and(B), Type, NoFr, Time, Loc, _, RelsType). 

assert_rels(and([]), _, _, _, _, _, _) .

assert_rels(
   Infon, InfonType, NoFr, MainTime, Loc, Role, RelsType) 
   :-
   Infon=..[_, _, InfonId, Rel, Args, Restr, Pol],
   infon_type(NoFr, InfonId, Role, InfonType),
   get_inds(Args, Inds, NoFr, MainTime, Loc),
   Infon1=..
      [InfonType, InfonId, Rel, Inds, Pol, MainTime, Loc],
   assert_infon_if_needed(Infon1, InfonId, NoFr, RelsType, RelTime),
   assert_ev_restr(Restr, InfonType, NoFr, RelTime, Loc).


infon_type(_, _, prop, InfonType) :-
  nonvar(InfonType),
  !.

infon_type(NoFr, InfonId, Role, InfonType) :-
  confer_ind(NoFr, SintInd, InfonId),
  nodo(Node)::indice::SintInd,
  !,
  get_factivity(NoFr, Node, Role, Intens),
  (
  Intens=nonfactive
  ->
  InfonType=sit
  ;
  InfonType=fact
  ).

infon_type(NoFr, _, prop, fact) .

get_factivity(NoFr, Node, Role, Intens) :-
  info(NoFr, Node, _/Role, _, Intens, _, _, _, _, _, _, _, _),
  !.

/* dovrebbe essere calcolato da factivity */
get_factivity(NoFr, Node, arg, nonfactive) :-
  nodo(N)::adj::nodo(Node),
  nodo(Node)::sem_mark::for,
  !.

/* dovrebbe essere calcolato da factivity 
(andarono) a cercare */
get_factivity(NoFr, Node, arg, nonfactive) :-
   nodo(_)::ogg/prop::nodo(Node),
   !.

get_factivity(NoFr, Node, arg, nonfactive) :-
   nodo(_)::vcomp/propint::nodo(Node),
   !.

get_factivity(NoFr, Node, arg, nonfactive) :-
   nodo(_)::vcomp/propadj::nodo(Node),
   !.

get_factivity(NoFr, Node, Role, Intens) :-
  nodo(N0)::vcomp/Role::coord::nodo(Node),
%  !,
  nodo(N0)::vcomp/Role::coord::pred::Pred,
  info(NoFr, N, Main/Role, _, Intens, _, _, _, Pred, _, _, _, _),!.


get_factivity(NoFr, Node, Role, Intens) :-
  nodo(N0)::vcomp/Role::coord::nodo(Node),
%  !,
  nodo(N0)::pred::Pred,
  info(NoFr, N0, Main/Role, _, Intens, _, _, _, Pred, _, _, _, _),!.


get_factivity(NoFr, Node, Role, Intens) :-
   nodo(N0)::Fun/Role::nodo(Node),
%   !,
  nodo(N0)::pred::Pred,
  info(NoFr, N0, main/prop, _, Intens, _, _, _, Pred, _, _, _, _).

get_factivity(NoFr, Node, Role, Intens) :-
   nodo(N0)::Fun/Role::nodo(Node),
  info(NoFr, N0, _, _, Intens, _, _, _, _, _, _, _, _).

get_factivity(NoFr, Node, Role, Intens) :-
  info(NoFr, Node, Fun/Role, _, Intens, _, _, _, _, _, _, _, _).

get_factivity(NoFr, Node, Role, factive) :-
   nodo(N0)::vcomp/Role::nodo(Node), !.

get_factivity(NoFr, Node, Role, factive) :-
   nodo(N0)::adjs::vcomp/Role::nodo(Node), !.

get_factivity(NoFr, Node, Role, factive) :-
   nodo(Nodo)::ip_ell/prop::[],
   nodo(Nodo)::adjs::avv::adj/Role::nodo(N),!.

get_factivity(NoFr, Node, Role, factive) :-
   nodo(Nodo)::ip_ell/prop::nodo(N),!.

get_factivity(NoFr, Node, Role, factive).

/**************
assert_arg_restr(
   and(+Restrictions), +NoFr, +Time, +Loc)
**************/

assert_arg_restr(and([]), _, _, _) :-
   !.    

/* NB: Nella forma logica sit indica una relativa */
assert_arg_restr(and([Restr | Restrictions]), NoFr, Time, Loc) :-
   (
   Restr=(Type:Restriction)
   ;
   Restr=Restriction
   ),
   (
   functor(Restriction, sit, _)
   ->
   InfonType=fact,
   RelsType=rels
   ; 
   InfonType=fact,
   RelsType=ind_restr
   ),
   assert_rels(
      Restriction, InfonType, NoFr, Time, Loc, _, RelsType),
   assert_arg_restr(and(Restrictions), NoFr, Time, Loc).    



/****************************
assert_ev_restr(
   +Restrictions, +InfonType, +NoFr, +Time, +Loc)
== asserts event restrictions
*****************************/

/* Special case: coincide */
assert_ev_restr(
  and([infon(Q1, Inf1, coincide, Args, _, Pol) | Restr]),
  InfonType, NoFr, Time, Loc) 
  :-
  remove(
    sit(Q2, Inf2, Rel, RelArgs, SitRestr, SitPol), 
    Args, [IdEv]),
  atomic(IdEv),
  assert_rels(
    sit(Q2, Inf2, Rel, RelArgs, SitRestr, SitPol),
    InfonType, NoFr, Time, Loc,_, rels),
  assert_rels(
    infon(Q1, Inf1, coincide, [IdEv,Inf2] , [], Pol),
    InfonType, NoFr, Time, Loc,_, rels),
  assert_ev_restr(
    and(Restr), 
    InfonType, NoFr, Time, Loc),
  !.

/* Standard case */
assert_ev_restr(
  and([infon(Q, Inf, Rel, Args, _, Pol) | Restrs]),
  InfonType, NoFr, Time, Loc) 
  :-
  assert_rels(
    infon(Q, Inf, Rel, Args , [], Pol),
    InfonType, NoFr, Time, Loc,_, rels),
  assert_ev_restr(and(Restrs), InfonType, NoFr, Time, Loc),
  !.

/* If the infon has a Type:Infon structure, Type becomes the Role of the second individual of the relation */
assert_ev_restr(
  and([Type:Infon | Restrs]),
  InfonType, NoFr, Time, Loc) 
  :-
  Infon=
     infon(
       Q, Inf, Rel, [Arg1, ind(Q1, V, R, _)], _, Pol),
  Args=[Arg1, ind(Q1, V, R, Type)],
  assert_rels(
    infon(Q, Inf, Rel, Args , [], Pol),
    InfonType, NoFr, Time, Loc,_, rels),
  assert_ev_restr(and(Restrs), InfonType, NoFr, Time, Loc),
  !.


/*
assert_ev_restr(
  and([Restr | Restrs]),
  InfonType, NoFr, Time, Loc) 
  :-
  (
  Restr=
    infon(Q, Inf, Rel, Args, _, Pol)
  ;
  Restr=
    (
    Type:infon(
       Q, Inf, Rel, [Arg1, ind(Q1, V, R, _)], _, Pol)
    ),
  Args=[Arg1, ind(Q1, V, R, Type)]
  ),
  assert_rels(
    infon(Q, Inf, Rel, Args , [], Pol),
    InfonType, NoFr, Time, Loc,_, rels),
  assert_ev_restr(and(Restrs), InfonType, NoFr, Time, Loc),
  !.
*/
/* End of recursion */
assert_ev_restr([], _, _, _, _) :-
   !.

/* A simple restriction is normalized to the and() form */
assert_ev_restr(
  infon(Q, Inf, Rel, Args, Restr, Pol),
  InfonType, NoFr, Time, Loc) 
  :-
  assert_ev_restr(
    and([infon(Q, Inf, Rel, Args, Restr, Pol)]),
    InfonType, NoFr, Time, Loc),
  !.

/* End of recursion */
assert_ev_restr(and([]), _, _, _, _) .


/* Escape clause */
assert_ev_restr(
  and([_ | Restr]), InfonType, NoFr, Time, Loc)
  :-
  assert_ev_restr(and(Restr), InfonType, NoFr, Time, Loc).




/*****************
assert_infon_if_needed(+Infon, +InfonId, +NoFr)
== Infon is asserted only if it is not already known.
Before searching for a map in the Model DB the infon identifier is dummified.
Notice that Infon has always role-qualified args, while in the asserted facts inds may be role-qualified or not. 
If we already know that an infon is a fact it would be trivial to assert that it is a sit. So if an infon is a fact we search for a fact, if it is a sit we search for a sit or a fact.
*****************/

/*
Individual Restriction.
sit or fact is an individual restriction about individuals created by the memorizza procedure. The restriction is not asserted 
*/

assert_infon_if_needed(Infon, InfonId, NoFr, ind_restr, _) :-
   Infon=..[fact, Ind, focus, Arg, Pol, Temp, Loc], 
   assert(Infon),   
   assert(confer_infon(InfonId, NoFr, nil, nil, secondary)),
   !.

assert_infon_if_needed(Infon, _, _, ind_restr, _) :-
   Infon=..[fact, _, _, [_:Id | Args] | _], 
   \+ new_ind(Id),
   !.


assert_infon_if_needed(Infon, _, _, _, _) :-
   known_infon(Infon, AssertedInfon),
   arg(1, Infon, InfId),
   arg(1, AssertedInfon, AssInfId),
   assert(eq_infon(InfId, AssInfId)),
   !.

/*
Individual restriction.
sit or fact isn't already known. The main temporal location is kept 
*/
assert_infon_if_needed(Infon, InfonId, NoFr, ind_restr, _) :-
   Infon=..[fact | Args],      
   assert(Infon),   
   assert(confer_infon(InfonId, NoFr, nil, nil, secondary)). 

assert_infon_if_needed(Infon, InfonId, NoFr, ind_restr, _) :-
   Infon=..[in, InfonId |Args],      
   assert(Infon),   
   assert(confer_infon(InfonId, NoFr, nil, nil, secondary)). 

assert_infon_if_needed(_, _, _, ind_restr, _).


/* 
Relations.
The relation  has a tema_bound:_ and a prop:_ in the args list . The tema_bound is removed. If the prop is already known in a different form, it is retracted in the current form, and the identifier of the known form is given as prop:id argument. An identifier for the temporal relation is build, and asserted instead of the main temporal location
*/
assert_infon_if_needed(Infon, InfId, NoFr,  rels, Time) :-
   Infon=..[A, InfId, Rel, Args, Pol, MainTemp, Loc],
   (Role=tema_bound;Role=theme_bound),
   remove(Role:Ind, Args, Args1),
   remove(prop:PropId, Args1, Args2),
   retract_if_needed(PropId, Rel, NewPropId),
   append(Args2, [prop:NewPropId], NewArgs),
   temp_loc(InfId, MainTemp, Time),
   NewInfon=..[A, InfId, Rel, NewArgs, Pol, Time, Loc],
   assert(NewInfon),   
   assert(confer_infon(InfId, NoFr, nil, nil, main)),     
   !.

/* 
Relations.
sit or fact isn't already known. An identifier for the temporal location is built  
*/
assert_infon_if_needed(Infon, InfonId, NoFr, rels, Time) :-
   Infon=..[A, InfId, C, Args, Pol, MainTemp, Loc],
   temp_loc(InfId, MainTemp, Time),
   NewInfon=..[A, InfId, C, Args, Pol, Time, Loc],
   assert(NewInfon),   
   assert(confer_infon(InfonId, NoFr, nil, nil, main)). 


assert_infon_if_needed(Infon, InfId, NoFr,  rels, Time) :-
   Infon=..[A, InfId, Rel, OArgs, Pol, MainTemp, Loc],      
   OArgs=[Arg1|Arg2],
   extract_roles(Args2, Id, R),
   remove(R:Id, Arg2, Narg2),
   append([R:Id],[Arg1], Nar),
   append(Nar, Narg2, NewArgs),
   temp_loc(InfId, MainTemp, Time),
   NewInfon=..[A, InfId, Rel, NewArgs, Pol, Time, Loc],
   assert(NewInfon),   
   assert(confer_infon(InfId, NoFr, nil, nil, main)),     
   !.

assert_infon_if_needed(Infon, InfonId, NoFr, rels, Time) :-
   Infon=..[A, InfId, be, [], Pol, MainTemp, Loc],      
   current_main_loc(NFrase, tempo, Ref),
   Ref=..[ref_ex, Id | Args],
   loc(LInfonId, Id, _),   
   temp_loc(InfId, MainTemp, Time),
   NewInfon=..[A, InfId, be, [tema_bound:LInfonId], Pol, Time, Loc],
   assert(NewInfon),   
   assert(confer_infon(InfonId, NoFr, nil, nil, main)). 

extract_roles(Args2, Id, R):-
   on(R:Id,Arg2),
   (R=agente;R=agent;R=causer),!.


/*
create_ell_rel([InfonId]):-
         frase_corrente(NoFr, File),
         gen_sym(infon, InfonId),
         gen_sym(id, EvId),
         Infon=..[fact, EvId, be, [InfonId], 1, Tr1, Loc],
         assert(Infon),
         assert(confer_infon(EvId, NoFr, nil, nil, main)),
         !.
*/

retract_if_needed(InfonId, Rel, AssertedInfonId) :-
   eq_infon(InfonId, AssertedInfonId),!.

/* senza la Rel non pu fare il retract!! */
retract_if_needed(InfonId, Rel, AssertedInfonId) :-
   member(Fun, [sit, fact]),
   Infon=..[Fun, InfonId, _, _, _, _, _],
   known_information(Infon, _, AssertedInfon),
   !,
   (retract(Infon) ; true),
   arg(1, AssertedInfon, AssertedInfonId).

retract_if_needed(InfonId, Rel, InfonId).
   
/***************
temp_loc(+InfonId, +MainTempId, -TimeLocId)
== Given an Infon Identifier, it gets the corresponding Sentence index ( (from the F-Structure), and it creates an identifier for the temporal location. If the mapping from the InfonId to the Sentence Index isn't available the identifier of the main temp loc is taken instead. Notice that temp_loc is called only for relations (=\= individual restrictions)
***************/
temp_loc(InfId, _, tes(TimeId)) :-
   confer_ind(_, FrX, InfId),
   rete(Rete),
   concatena(FrX, Rete, TimeId),
   !.
temp_loc(_, InfId, InfId).



known_information(Infon, Rel, AssertedInfon) :-
   call(Infon),
   Infon=..[Fun, InfId, Rel, [Arg] | Rest],
   KnownInfon=..[Fun, AssInfId, role, [Rel, Arg, _] | Rest],
   known_infon(KnownInfon, AssertedInfon),
   !.   
   
known_information(Infon, Rel, AssertedInfon) :-
   call(Infon),  %% ???
   Infon=..[Fun, InfId, Rel, [Arg] | Rest],
   KnownInfon=..[Fun, AssInfId, name, [Rel, Arg] | Rest],
   known_infon(KnownInfon, AssertedInfon).   



/* sit or fact is already known as a fact with role-qualified args. */
known_infon(Infon,  AssertedInfon) :-
   Infon=..[InfType, _ , Rel, Args| Rest],
   atomic(Rel),
   (
   InfType=sit
   ->
   on(AssertedInfType, [sit, fact])
   ;
   AssertedInfType=InfType
   ), 
   dummify_default_roles(Args, Args1),   
   AssertedInfon=..[AssertedInfType, _, Rel, Args1 | Rest],      
   call(AssertedInfon),
   !.

/* Abbreviated facts */
known_infon(Infon,  AssertedInfon) :-
   Infon=..[Pred, _ | Rest],
   on(Pred, [ind, set, loc, card]),
   AssertedInfon=..[Pred, _ | Rest],
   call(AssertedInfon),
   !.

/* sit or fact is already known with non role-qualified arguments - this has been added for legal genre where no additional information is needed in case the same property restriction is present - clear_ind_id is used rather than clear_roles */
known_infon(Infon, AssertedInfon) :-
   genre(legal),
   Infon=..[InfType, _, Rel, Inds | Rest],      
   atomic(Rel),
   clear_ind_id(Inds, Inds1),
   (
   InfType=sit
   ->
   on(AssertedInfType, [sit, fact])
   ;
   AssertedInfType=InfType
   ),      
   AssertedInfon =.. 
      [AssertedInfType, _, Rel, Inds1 | Rest],      
   call(AssertedInfon).

known_infon(Infon, AssertedInfon) :-
   Infon=..[InfType, _, Rel, Inds | Rest],      
   atomic(Rel),
   clear_roles(Inds, Inds1),
   (
   InfType=sit
   ->
   on(AssertedInfType, [sit, fact])
   ;
   AssertedInfType=InfType
   ),      
   AssertedInfon =.. 
      [AssertedInfType, _, Rel, Inds1 | Rest],      
   call(AssertedInfon).


/*****************
clear_roles(+IndsWithRoles, -IndsWithoutRoles)
?- clear_roles([a:b,n], IWR)
*****************/
clear_ind_id([R:I | Inds], [_:_ | Inds1]) :-
   !,
   clear_indclass(Inds, Inds1).

clear_ind_id([], []).

clear_indclass([R:I | Inds], [_:I | Inds1]) :-
   clear_indclass(Inds, Inds1).

clear_indclass([], []).

clear_roles([R:I | Inds], [I | Inds1]) :-
   !,
   clear_roles(Inds, Inds1).
clear_roles([I | Inds], [I | Inds1]) :-
   clear_roles(Inds, Inds1).
clear_roles([], []) .

dummify_default_roles([], []).
dummify_default_roles([arg:Arg | Args], [_:Arg | DumArgs]) :-
   !,
   dummify_default_roles(Args,  DumArgs).

dummify_default_roles([Role:Arg | Args], [Role:Arg | DumArgs]) :-
   dummify_default_roles(Args,  DumArgs).

/************************
get_inds(+Args, -Inds, +NoFr, +Time, +Loc)

ARGUMENTS.
   Args : <list> of (<term> one_of [ind/4, infon/6, sit/6]) 
        or <atom> 
        : individuals in complex notation
   Inds : <list> of (<term> = role:identifier)
        : individuals in simple fact notations
== As side effect all restrictions on individuals are asserted.
*************************/

get_inds([], [], _, _, _) :-
    !.

/* set : information is asserted about the individuals that are members of the set */

get_inds(
   [ind(set, IndSet, IndInSet, Role) | Args], 
   [(Role:IndSet) | Inds], 
   NoFr, Time, Loc) 
   :-
   !,
   (nonvar(Role);var(Role), Role=arg),
   assert_quantifier(set, IndSet, NoFr),
   get_inds(IndInSet, IndInSet1, NoFr, Time, Loc),
   assert_ind_in_set(IndInSet1, IndSet, NoFr),
  	get_inds(Args, Inds, NoFr, Time, Loc).

/* proper qualified individual */
get_inds(
   [ind(Quant, Ind, Restr, Role) | Args], 
   [(Role:Ind) | Inds], 
   NoFr, Time, Loc) 
   :-
   !,
   (nonvar(Role);var(Role), Role=arg),
   assert_quantifier(Quant, Ind, NoFr),
   assert_arg_restr(Restr, NoFr, Time, Loc), 
  	get_inds(Args, Inds, NoFr, Time, Loc).

/* non qualified individual : simple identifier */
get_inds(
   [Ind | Args], 
   [arg:Ind | Inds], 
   NoFr, Time, Loc) 
   :-
   atomic(Ind),
   !,
   get_inds(Args, Inds, NoFr, Time, Loc).

/* prop individual :  */

get_inds(
   [Infon | Args], 
   [Role:Ind | Inds], 
   NoFr, Time, Loc) 
   :-
   !,
   assert_rels(Infon, _, NoFr, Time, Loc, Role, rels),
   arg(2, Infon, Ind),   
   get_inds(Args, Inds, NoFr, Time, Loc).


/* catch all */
get_inds(
   [Arg | Args], 
   [Arg | Inds], 
   NoFr, Time, Loc) 
   :-
   get_inds(Args, Inds, NoFr, Time, Loc).




assert_quantifier(Quant, Ind, NoFr) :-
   on(Quant, [set, plural]),
   !,
   gen_sym(infon, Infon),
   assert_infon_if_needed(
      set(Infon, Ind), 
      Infon, NoFr, ind_restr, _).

assert_quantifier(_, Ind, NoFr) :-
   !,
   gen_sym(infon, Infon),
   assert_infon_if_needed(
      ind(Infon, Ind), 
      Infon, NoFr, ind_restr, _).

assert_quantifier(_, _, _).


assert_ind_in_set([_:Ind | Inds], IndSet, NoFr) :-
   !,
   gen_sym(infon, Infon),
   assert_infon_if_needed(
      in(Infon, Ind, IndSet), 
      Infon, NoFr, ind_restr, _),
   assert_ind_in_set(Inds, IndSet, NoFr).
assert_ind_in_set([], _, _) .

/*********************PARTIAL SYSTEM*********************/

get_id_gov(NoFr,NewRefs, SnX, Id):-
   confer_topic(NoFr, Type, Id, SnX, PropNode),
   !.

get_id_gov(NoFr,NewRefs, SnX, Id):-
   confer_infon(InfonId, NoFr, SnX, PropNode, secondary),
   fact(InfonId,isa,[_:Id, _:Testa],P,T,L),!.

get_id_gov(NoFr,NewRefs, SnX, Id):-
   nogen_member(ref_ex(SnX,Testa,Tab,_,Gen,Num,Cats,F/Role)/P,NewRefs),
   \+ grammw(Testa,_),
   shcreatert(NoFr,class,[],SnX,Testa,Card,Quant,Num,Id,univ, univ),
   shdefault_properties(NoFr, Gen, SnX, Cats, Pred, Id,univ, univ),
   shasserisci(NoFr,SnX,fact(isa,[ind:Id,class:Pred],1,univ,univ)),
   !.

get_id(NoFr, Testa, Resto, NewRefs, SnX, Id, NewRefs):-
   nonvar(SnX),
   confer_topic(NoFr, Type, Id, SnX, PropNode),
   !.

get_id(NoFr, Testa, Resto, NewRefs, SnX, Id, NewRefs):-
   nonvar(SnX),
   confer_infon(InfonId, NoFr, SnX, PropNode, secondary),
   fact(InfonId,isa,[_:Id, _:Testa],P,T,L),!.

get_id(NoFr, Testa, Resto, NewRefs, SnX, Id, NewRefs):-
   nonvar(SnX),
   confer_infon(InfonId, NoFr, _, PropNode, secondary),
   fact(InfonId,isa,[_:Id, _:Testa],P,T,L),!.

get_id(NoFr, Testa, Resto, NewRefs, SnX, Id, NRefs):-
   nonvar(Testa),Testa\=[],
   lemmatize_dic(Testa, Lemma, S),
   crearef_ex(Testa, Resto, Ref, Mods),
   (Ref=..[ref_ex,Ind,Lemma,Tab|_], Lem=Lemma
     ;
    Ref=..[ref_ex,Ind,Testa,Tab|_], Lem=Testa
     ;
    Ref=..[ref_ex,Ind,Lemm,Tab|_], Lem=Lemm),
   Tab=[Re, Def, Quant, Card, _, _, Class],
   mcoreference(NoFr, Lem, Id),
   (Mods\=[], 
    find_restrict(Mods, Id, Lem, Pros, Ps, Modd),
    (Modd=[],Pss=Ps, Pross=Pros; Modd\=[], Pss=[], Pross=[]),
     evaluate_properties(Id,Modd,NoFr,SnX,Resto, Ref, Pross, Pss)
    ;
    Mods=[]
    ;
    true),
    append([Ref/100], NewRefs, NRefs),
    !.

get_id(NoFr, Testa, Resto, Refs, SnX, Id, NRefss):-
   nonvar(Testa),Testa\=[],
   crearef_ex(Testa, Resto, Ref, Mods),
   (
    shasserisci_proprieta_multiw(NoFr,Resto,Ref,SnXx,Id)
     ;
     shasserisci_proprieta_multiw(NoFr,Testa,Ref,SnXx,Id)),
    append([Ref/100], Refs, NRef),
   (
    Mods\=[], 
    length(Mods,L),
    remove(Mod, Mods, Mods1),
    asserisci_proprieta(Id,Mod,NoFr,SnY,Resto, NRef, NRefs),
     (L=1, NRefss=NRefs
      ;
      1<L,Mods1\=[],
      crearef_ex(Test, Mods1, Ref1, Modss),
      append([Ref1/100], NRefs, NRefss),
      shasserisci_proprieta_multiw(NoFr,Test,Ref1,SnZ,Idd) )    
    ;
    Mods=[], NRefss=NRef
    ;
    true, NRefss=NRef),
   asserisci_topicreffunc(NoFr, Testa, Resto, Id, SnXx),
   !.

get_id(NoFr, Testa, Resto, NewRefs, SnX, Id, NewRefs):-
   nonvar(Testa),Testa\=[],
   lemmatize_dic(Testa, Lemma, S),
   (Lem=Testa;Lem=Lemma),
   nogen_member(ref_ex(SnX,Lem,Tab,_,Gen,Num,Cats,F/Role)/P,NewRefs),
   shcreatert(NoFr,class,[],SnX,Lem,Card,Quant,Num,Id,univ, univ),
   shdefault_properties(NoFr, Gen, SnX, Cats, Lem, Id,univ, univ),
   shasserisci(NoFr,SnX,fact(isa,[ind:Id,class:Lem],1,univ,univ)),
   asserisci_topicreffunc(NoFr, Lem, Resto, Id, SnX),
   !.

get_id(NoFr, Testa, Resto, Refs, SnX, Id, NRefs):-
   nonvar(Testa), Testa\=[],
   lemmatize_dic(Testa, Lemma, S),
   crearef_ex(Testa, Resto, Ref, Mods),
   (Ref=..[ref_ex,Ind,Lemma,Tab|_], Lem=Lemma
     ;
    Ref=..[ref_ex,Ind,Testa,Tab|_], Lem=Testa
     ;
    Ref=..[ref_ex,Ind,Lemm,Tab|_], Lem=Lemm),
   Tab=[Re, Def, Quant, Card, _, _, Class],
   shcreatert(NoFr,class,[],SnX,Lem,Card,Quant,Num,Id,univ, univ),
   shdefault_properties(NoFr, Gen, SnX, Cats, Lem, Id,univ, univ),
   shasserisci(NoFr,SnX,fact(isa,[ind:Id,class:Lem],1,univ,univ)),
    append([Ref/100], Refs, NRefs),
   asserisci_topicreffunc(NoFr, Lem, Resto, Id, Ind),
   !.

get_id_pl(NoFr, Testa, Resto, NewRefs, SnX, Id):-
   crearef_ex(Testa, Resto, Ref, Mods),
   Ref=ref_ex(SnX,Lemma,Tab,_,Gen,Num,Cats,F/Role),
   Tab=[Re, Def, Quant, Card, _, _, Class],
   Re = + ref,
   Resto=[Tes-Cc-Cost|RevParse],
   shassert_names(NoFr,Cats,[],SnX,and([Lemma,Tes]),Card,Quant,Num,Id,Temp, Loc),
   !.

crearef_ex(Testa, Resto, Ref, Mods):-
     Resto\=[],
     on(Testa-Cat-_, Resto),
     genera_tratti(Feats, Testa, [Pers,Gen,Num], Lemma, Cat),
     nonvar(Lemma),
     trova_CatSem(Cat, Lemma, CatSem),
     assegna_tab(Cat, Testa, Resto, Tab),
     assign_index(Ind),
     costruisci_mmod([], Tab, Cat, Testa, Resto, Mods, Tab1),
     Ref=ref_ex(Ind,Lemma,Tab1,Pers,Gen,Num,CatSem,adj/R),
     !.

crearef_ex(Testa, Resto, Ref, Mods):-
     genera_tratti(Feats, Testa, [Pers,Gen,Num], Lemma, Cat),
     nonvar(Lemma),
     trova_CatSem(Cat, Lemma, CatSem),
     assegna_tab(Cat, Testa, Resto, Tab),
     assign_index(Ind),
     costruisci_mmod([], Tab, Cat, Testa, Resto, Mods, Tab1),
     Ref=ref_ex(Ind,Lemma,Tab1,Pers,Gen,Num,CatSem,adj/R),
     !.

asserisci_agg(NoFr, SnX, Fact) :-
   gen_sym(infon, Id),
   Fact=..[Pred | Args],
   FactId=..[Pred, Id | Args],
   nonvar(Pred),
   assert(FactId),
   frase_corrente(NoFr,_),
   assert(confer_infon(Id, NoFr, nil, nil, secondary)),
   !.

asserisci_rel(NoFr, SnX, Fact, Id) :-
   gen_sym(id, Id),
   Fact=..[Pred | Args],
   FactId=..[Pred, Id | Args],
   nonvar(Pred),
   assert(FactId),
   frase_corrente(NoFr,_),
   assert(confer_infon(Id, NoFr, nil, nil, secondary)),
   !.

reconstructroles(Roles,Rels,Roles1):-
   nogen_member(purpose/Cl,Roles),
   nogen_member(Cl-Clause,Rels),
   remove(purpose/Cl,Roles,Roless),
   Clause=[Pred-Relss-N],
   append(Roless,[Pred-Relss],Roles1),
   !.
reconstructroles(Roles,Rels,Roles):-
   !.
   
assertrels(AllRefs,SentNo,[], [], Control,[], Inds):-!.
assertrels(AllRefs,SentNo,[Cl-[nil-nil-_]|Rels], [nil-nil|Aggs], Control,Asserts, Inds):-
   assertrels(AllRefs,SentNo,Rels, Aggs, Control,Asserts, Inds),!.
assertrels(AllRefs,SentNo,[nil-nil-_|Rels], [nil-nil|Aggs], Control, Asserts, Inds):-
   assertrels(AllRefs,SentNo,Rels, Aggs, Control,Asserts, Inds),!.
assertrels(AllRefs,SentNo,[Cl-Rel|Rels], AllAggs, Control,[Assert|Asserts], Inds):-
   Rel=[R-Roles-Pol],
   nonvar(R),
   reconstructroles(Roles,Rels,Roles1),
   recover_inds(AllRefs,SentNo,R-Roles1, OutInds, Inds),
   build_rel(SentNo-Cl, R-Roles1, Pol, OutInds, Id, Control, Assert),
   (contr(on), Control=Id,
     abolish(contr/1), 
     assert(contr(off))
     ;
    contr(off)),
   check_funcs_sems(Cl, Rel, [], NewRel, [], Contr),
   (AllAggs=[], Aggs=[]; AllAggs=[Agg|Aggs]),
   assertrels(AllRefs,SentNo,Rels,Aggs, Control, Asserts, Inds),!.

assertrels(AllRefs,SentNo,[Rel|Rels], AllAggs, Control,[Assert|Asserts], Inds):-
   Rel=R-Roles-Pol,
   reconstructroles(Roles,Rels,Roles1),
   recover_inds(AllRefs,SentNo,R-Roles1, OutInds, Inds),
   build_rel(SentNo-Cl, R-Roles1, Pol, OutInds, Id, Control, Assert),
   (contr(on), Control=Id,
     abolish(contr/1), 
     assert(contr(off))
     ;
    contr(off)),
   check_funcs_sems(Cl, Rel, [], NewRel, [], Contr),
   (AllAggs=[], Aggs=[]; AllAggs=[Agg|Aggs]),
   assertrels(AllRefs,SentNo,Rels,Aggs, Control, Asserts, Inds),!.

/*
assertrels(AllRefs,SentNo,[Rel|Rels], Aggs, Control,[Assert|Asserts], Inds):-
   recoverassertinds(Rel,Assert),
   assertrels(AllRefs,SentNo,Rels,Aggs, Control, Asserts, Inds),!.
*/

assertrels(AllRefs,SentNo,[Rel|Rels], Aggs, Control,Asserts, Inds):-
   assertrels(AllRefs,SentNo,Rels,Aggs, Control, Asserts, Inds),!.



recoverassertinds(Cl-Rel,Assert):-
   Rel=R-Roles-Pol,
   recoverindsass(R,Roles,OutInds),
   build_rel(SentNo-Cl, R-Roles, Pol, OutInds, Id, Control, Assert),
   !.
   
/*
recoverindsass(Pre,Roles,OutInds):-
    findall(Pred-F-R-Sem-Pre, (dgrs(N,Dgr),
                    (
                     (Dgr=..[Fun,Sem,Pre-In,Pred-Ind];
                      Dgr=..[Fun,Sem,Pre-Ind,Pred];
                      Dgr=..[Fun,Sem,Pre,Pred-Ind];
                      Dgr=..[Fun,Sem,Pre,Pred]), 
                      term_to_atom(F-R,Fun),
                       
*/

search_model(NoFr,arb, arb):-
%      gen_sym(infon, Id),
    !.

search_model(NoFr,Ind, Id):-
   confer_topic(NoFr, Type, Id, Ind, PropNode),
   !.

search_model(NoFr,Ind, Id):-
   confer_infon(InfonId, NoFr, Ind, PropNode, secondary),
   (Pred=ind;Pred=set;Pred=ent;Pred=class),
   FactId=..[Pred, InfonId, Id],
   call(FactId).

/*
checkrelsprops([], Asserts, RelIds):-!.
checkrelsprops([Cl-[Rel-Inds-_]|Rels], Asserts, RelIds):-
    recoverinds(Cl, Rel-Inds, RelIds, Asserts),
    checkrelsprops(Rels, Asserts, RelIds),
    !.

recoverinds(Cl1, Rel-[], Ids, Asserts):-!.
recoverinds(Cl, Rel-[Role/Ind|Inds], Ids, Asserts):-
     nonvar(Ind),
     stringof(Lis,Ind),
     Lis=[c,l|_],
     on(Assert,Asserts),
     Assert=asserisci_rel(NoFr,SnX,fact(Rel,Args,Pol,univ, univ), Cl),
     on(Cl-Id,Ids),
     Fact=..[fact,Id,Rel,Args,Pol,univ, univ],
     retract(Fact),
     on(Assert1,Asserts),
     Assert1=asserisci_rel(NoFr,SnX,fact(Rel1,Argss,Pol1,univ, univ), Cl1),
     Ind=Cl1,
     on(Cl1-Id1,Ids),
     append(Args,[Role:Id1],Args1),
     Fact1=..[fact,Id,Rel,Args1,Pol,univ, univ],
     assert(Fact1),
     recoverinds(Cl, Rel-Inds, Ids, Asserts),!.
recoverinds(Cl1, Rel-[Role/Ind|Inds], Ids, Asserts):-
     recoverinds(Cl1, Rel-Inds, Ids, Asserts),!.
*/
recover_inds(AllRefs,NoFr,Rel-[], [], []):-!.
recover_inds(AllRefs,NoFr,Rel-[], [], OutInds):-
%   remove(Id/Ind, OutInds, Outs),
%   var(Ind), Outs=[],
   !.
recover_inds(AllRefs,NoFr,Rel-[prop/Ind|Inds], Ids, OutInds):-
   nonvar(Ind),
     stringof(Lis,Ind),
     Lis=[c,l|_],
   recover_inds(AllRefs,NoFr,Rel-Inds, Ids, OutInds),!.

recover_inds(AllRefs,NoFr,Rel-[purpose/Ind|Inds], Ids, OutInds):-
   nonvar(Ind),
     stringof(Lis,Ind),
     Lis=[c,l|_],
   recover_inds(AllRefs,NoFr,Rel-Inds, Ids, OutInds),!.

recover_inds(AllRefs,NoFr,Rel-[result/Ind|Inds], Ids, OutInds):-
   nonvar(Ind),
     stringof(Lis,Ind),
     Lis=[c,l|_],
   recover_inds(AllRefs,NoFr,Rel-Inds, Ids, OutInds),!.

recover_inds(AllRefs,NoFr,Rel-[Role/Ind|Inds], [Role1:Id|Ids], OutInds):-
   nonvar(Ind),
   remove(Id/Ind, OutInds, Outs),
   nonvar(Id),
   (nonvar(Role), Role1=Role;var(Role),Role1=arg),
   recover_inds(AllRefs,NoFr,Rel-Inds, Ids, Outs),!.

recover_inds(AllRefs,NoFr,Rel-[Role/Ind], [Role1:Id], OutInds):-
   nonvar(Ind),
   remove(Id/Ind, OutInds, Outs),
   nonvar(Id),
   (nonvar(Role), Role1=Role;var(Role),Role1=arg),
   !.

recover_inds(AllRefs,NoFr,Rel-[Role/Ind], [Role1:Id], OutInds):-
   nonvar(Ind),
   remove(Id/Ind, OutInds, Outs),
   var(Id),
   on(ref_ex(Ind,Pred,Tab,Pers,Gen,Num,Cat,F/Role)/N,AllRefs),
   proprieta(Id,Pred),
   (nonvar(Role), Role1=Role;var(Role),Role1=arg),
   !.

recover_inds(AllRefs,NoFr,Rel-[Role/Ind], [Role1:Id], OutInds):-
   nonvar(Ind),
   remove(Id/Ind, OutInds, Outs),
   nonvar(Id),
   (nonvar(Role), Role1=Role;var(Role),Role1=arg),
   !.

recover_inds(AllRefs,NoFr,Rel-[CRel-[Role/Ind|Inds]], [prop:RelId], OutInds):-
   nonvar(Ind),
   search_model(NoFr,Ind, Id),
   (Inds=[], Ids=[Role:Id]
     ;
    Inds\=[], Inds=[SRole/SInd], 
   search_model(NoFr,SInd, SId),
        Ids=[Role:Id, SRole:SId]),
   recover_inds(AllRefs,NoFr,CRel-Inds, Idc, OutInds),
   build_vrel(NoFr,CRel-CInds, 1, Ids, RelId,Control),
   !.

recover_inds(AllRefs,NoFr,Rel-[CRel-[Role/Ind|Inds]], Ids, OutInds):-
   recover_inds(AllRefs,NoFr,Rel-[Role/Ind|Inds], Ids, OutInds),!.

recover_inds(AllRefs,NoFr,Rel-[CRel-[Role/Ind|Inds]|Rels], [prop:RelId|Idss], OutInds):-
   nonvar(Ind),
   search_model(NoFr,Ind, Id),
   (Inds=[], Ids=[Role:Id]
     ;
    Inds\=[], Inds=[SRole/SInd], 
   search_model(NoFr,SInd, SId),
        Ids=[Role:Id, SRole:SId]),
   recover_inds(AllRefs,NoFr,CRel-Inds, Idc, OutInds),
   build_vrel(NoFr,CRel-CInds, 1, Ids, RelId, Control),
   recover_inds(AllRefs,NoFr,Rel-Rels, Idss, OutInds),
   !.

recover_inds(AllRefs,NoFr,Rel-[CRel-[Role/Ind|Inds]|Rels], Ids, OutInds):-
   recover_inds(AllRefs,NoFr,Rel-Rels, Ids, OutInds),!.

recover_inds(AllRefs,NoFr,Rel-[Role/Ind|Inds], Ids, OutInds):-
   recover_inds(AllRefs,NoFr,Rel-Inds, Ids, OutInds),!.

check_funcs_sems(Cl, Rels, Aggs, NewRels, NewAggs, Contr):-
    integer(Cl),
    Cl1 is Cl + 1,
    funcs(sem, Cl1-_, Avv, First),
    (First = Func-[Cong-Cat-Func]
      ;
      First = Func-Rest, on(_-dirs-Func, Rest)),
    (Func=fs;Func=fc;Func=fac;Func=f2;Func=fint;Func=dirsp),
    reconstructrels(Func, Rels, Aggs, NewAggs, NewRels, Contr),
    !.
check_funcs_sems(Cl, Rels, Aggs, Rels, Aggs, Contr):-
     !.

reconstructrels(fac, Rels, Aggs, NewAggs, NewRel, Contr):-
    reconstruct_rels(fac, Rels, NewRel, Contr),!.
reconstructrels(dirsp, Rels, Aggs, NewAggs, NewRel, Contr):-
    reconstruct_rels(fac, Rels, NewRel, Contr),!.
reconstructrels(fs, Rels, Aggs, NewAggs, Rels, Contr):-
    reconstruct_adjs(fs, Aggs, NewAggs, Contr),!.
reconstructrels(fc, Rels, Aggs, NewAggs, Rels, Contr):-
    reconstruct_adjs(fc, Aggs, NewAggs, Contr),!.
reconstructrels(fint, Rels, Aggs, NewAggs, Rels, Contr):-
    reconstruct_adjs(fint, Aggs, NewAggs, Contr),!.

reconstruct_rels(Func, [Rel], NewRel, Ind):-
     Rel=Pred-Args-N,
     on(prop/Role, Args),
     var(Role),
     abolish(contr/1),
     assert(contr(on)),
     !.
reconstruct_adjs(Func, NewRel, NewRel, Ind).

reconstruct_adjs(Func, [Rel], NewRel, Ind):-
     Rel=Pred-Args,
     assign_index(Ind),
     build_aggs_props(Func, Ind, Args),
     append(Args, [Arg], NArgs),
     NewRel=[Pred-NArgs-N],
     !.

build_args_props(fac, Ind, prop/Ind).
build_aggs_props(fs, Ind, adj/Ind).
build_aggs_props(fc, Ind, adj/Ind).
build_aggs_props(fint, Ind, adj/Ind).

/**************
memorizza(+noFrase, +location, +tempo, +args)
**************/
memorizza(NoFr, Loc, Temp, Args) :-
   proposto(Top),
   (Top\=nil, Type=expected,
    Top=ref_ex(SnX,Head,Tab,_,Gen,Num,Cat,F/Role),
    (record_topics(NoFr, Loc, Temp, SnX,Head,Type,Args, Args1)
      ;
     mem_topic(Args, Type, Top, NoFr, Temp, Loc), Args1=Args)
   ;
    Top=nil,
     Args1=Args),
   principale(Top1), 
   (Top1\=nil, Type1=main,
    Top1=ref_ex(SnX,Head1,_,_,_,_,_,_/_),
    (record_topics(NoFr, Loc, Temp, SnX,Head1,Type1,Args1, Args2)
     ;
     mem_topic(Args, Type1, Top1, NoFr, Temp, Loc), Args2=Args1)
    ;
    Top1=nil,
    Args2=Args1),
   secondario(Sec),
   (Sec\=nil, Type2=secondary,
    Sec=ref_ex(_,Secc,_,_,_,_,_,_/_),
     recover_descriptions(Secc, PredS),
    (
     (remove(ref_ex(SnX1,Secc,Tab1,_,Gen1,Num1,Cat1,F1/Role1)/P1, Args2, Args3), 
     mem_secondary(Args, ref_ex(SnX1,Secc,Tab1,_,Gen1,Num1,Cat1,F1/Role1), NoFr, Temp, Loc)
     ;
     (
      remove(ref_ex(SnX1,PredS,Tab1,_,Gen1,Num1,Cat1,F1/Role1)/P1, Args2, Args3), PreddS=PredS
      ;
       list(PredS),
       on(PredS1, PredS),
      remove(ref_ex(SnX1,PredS1,Tab1,_,Gen1,Num1,Cat1,F1/Role1)/P1, Args2, Args3), PreddS=PredS1
      ),
     mem_secondary(Args, ref_ex(SnX1,PreddS,Tab1,_,Gen1,Num1,Cat1,F1/Role1), NoFr, Temp, Loc)
     ;
     (referente(SnX1,[],Id1,Secc,_,_)
      ;
      referente(SnX1,[],Id1,PredS,_,_)
      ;
       list(PredS),
       on(PredS1, PredS),
     referente(SnX1,[],Id1,PredS1,_,_)
      ),
    asserisci_topic(NoFr, secondary, Id1, SnX1),
    Args3=Args2)
     ;
     mem_secondary(Args, Sec, NoFr, Temp, Loc), Args3=Args2)
    ;
    Args3=Args2),
   mem_other(Args3, [Top,Top1,Sec], NoFr, Temp, Loc).

memorizza(_, _, _, _) .

record_topics(NoFr,Loc, Temp, SnX,Top,Type,Args, Args1):-
    remove(ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role)/P, Args, Args1),
    mem_topic(Args, Type, ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role), NoFr, Temp, Loc)
    ;
    (
     recover_descriptions(Top, Pred),
      remove(ref_ex(SnX,Pred,Tab,_,Gen,Num,Cat,F/Role)/P, Args, Args1), Predd=Pred
      ;
       list(Pred),
       on(Pred1, Pred),
       remove(ref_ex(SnX,Pred1,Tab,_,Gen,Num,Cat,F/Role)/P, Args, Args1), Predd=Pred1
       ),       
    mem_topic(Args, Type, ref_ex(SnX,Predd,Tab,_,Gen,Num,Cat,F/Role), NoFr, Temp, Loc)
    ;
    (
     recover_descriptions(Top, Pred),
      referente(SnX,[],Id,Top,Num,Card)
      ;
      referente(SnX,[],Id,Pred,Num,Card)
      ;
       list(Pred),
       on(PredS1, Pred),
     referente(SnX1,[],Id1,PredS1,_,_)
     ),
    asserisci_topic(NoFr, Type, Id, SnX),
    Args1=Args, 
    !.

record_topics(NoFr,Loc, Temp, SnX, Top, Type, Args, Args):-
    mem_topic(Args, Type, Top, NoFr, Temp, Loc),
    !.

mem_topic(Args, Type, Topic, NoFr, Temp, Loc) :-
   legal_topic(Args, NoFr, Topic, SnX, TopicInfo),
   crea_arg(TopicInfo, Ind, Temp, Loc),
   !,
   asserisci_topic(NoFr, Type, Ind, SnX).

mem_topic(Args, Type, Topic, NoFr, Temp, Loc) :-
   legal_main_topic(Topic, Ind, SnX),
   !,
   asserisci_topic(NoFr, main, Ind, SnX).

mem_topic(_, _, _, _, _, _).

mem_secondary(Args, Sec, NoFr, Temp, Loc) :-
   legal_topic(Args, NoFr, Sec, SnX, Sec1),
   crea_arg(Sec1, SecInd, Temp, Loc),
   !,
   asserisci_topic(NoFr,secondary,SecInd,SnX).

mem_secondary(Args, Sec, NoFr, Temp, Loc) :-
   legal_sec_topic(NoFr, Sec, SecInd, SnX),
   !,   
   asserisci_topic(NoFr, secondary, SecInd, SnX).

mem_secondary(_, _, _, _, _).

remove_alt(ref_ex(SnX,Top1,Tab,_,Gen,Num,Cat,F/Role)/P, Args, Args1):-
       nonvar(Top1),
       remove(ref_ex(SnX,Top1,Tab,_,Gen,Num,Cat,F/Role)/P, Args, Args1),!.
remove_alt(ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role)/P, Args, Args):-!.

mem_other(Args, [Top,Top1,Sec], NoFr, Temp, Loc) :-
   (remove_alt(ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role)/P, Args, Args1)
     ; Args1=Args),
   (remove_alt(ref_ex(SnX,Top1,Tab,_,Gen,Num,Cat,F/Role)/P, Args1, Args11)
     ; Args11=Args),
   (remove_alt(ref_ex(SnX1,Sec,Tab1,_,Gen1,Num1,Cat1,F1/Role1)/P1, Args11, Altri)
     ; Altri=Args11),
   mem_others(Args, Altri, NoFr, Temp, Loc),
   !.   

mem_others(Args, [], NoFr, Temp, Loc) :-!.
mem_others(Args, [Altro/P|Altri], NoFr, Temp, Loc) :-
   legal_pot_topic(Args, NoFr, Altro, SnX, Altri1),
   once(crea_arg(Altri1, AltriInd, Temp, Loc)),
   asserisci_topic(NoFr, potential, AltriInd, SnX),
   mem_others(Args, Altri, NoFr, Temp, Loc),
   !.
mem_others(Args, [Altro/P|Altri], NoFr, Temp, Loc) :-
   mem_others(Args, Altri, NoFr, Temp, Loc),
   !.
mem_other(_, _, _, _, _, _).


/* stampa cose memorizzate */
memor :- listing(ind),
       listing(set),
       listing(in),
       listing(card),
       listing(fact),
       listing(class),
       listing(topic).
     
 

/**************
legal_topic(+Argomenti, +NumeroFrase, +ArgIn, -ArgOut)

ARGUMENTS
   Argomenti        : la lista delle ref_ex
   NumeroFrase      :integer. Sentence identifier.
   ArgIn            :term. ref_ex/8 or nil . 
   ArgOut           :term. arg/6 or nil. 

ref_ex/8 has_structure ref_ex(_,Testa,_,_,_,_,_,_) . 
arg/6 has_structure arg(SnId/NoFrase, Testa, Def, Part, Class, Num). 

== Recupera informazione su Topic da argomenti(NoFrase, Topics) e stabilisce se un certo topic  un individuo ammissibile
**************/

legal_topic(Args, NF, X, SnX, Arg):-  
   X=..[ref_ex,SnX,Testa|_],
  (nogen_member(ref_ex(SnX,Testa-sc,Tab,_,Gen,Num,Cat,F/Role)/P, Args), 
      Testa1=Testa
      ;
   nogen_member(ref_ex(SnX,Testa,Tab,_,Gen,Num,Cat,F/Role)/P, Args), 
    (recover_descriptions(Testa, PredS),
      \+ is_list(Testa), 
      Testa1=PredS
      ;
      is_list(Testa), Testa1=Testa
      ;
      recover_description(Testa, PredS),
      Testa1=PredS)
      ;
    nogen_member(ref_ex(SnX,indefinite,Tab,_,Gen,Num,Cat,F/Role)/P, Args),
      Testa1=indefinite),
  ( Tab=[Ref, Def, Part, Card, _, _, Class];
    Tab=[Ref, Def, Part, Card, _, _, Class, _]),
   Ref = + ref,
   Testa \= vbl,
   F \= nil,
   Role \= misura,
   (F = ogg, Role = prop
     ;
    F \= ogg, Role \= prop
     ;
    F = ncomp
     ;
    F = ogg),
   Role \= esplicativa,
   nonvar(Cat),
   notmembro(tempo, Cat),
   notmembro(modo, Cat),
   Arg=arg(SnX/NF, Testa1, Def, Part, Card, Class, Num, Cat, F/Role),
   !.

legal_main_topic(ref_ex(SnX,Testa,_,_,Gen,Num,Cat,F/Role), Id, SnX):-  
        referente(SnX,Mods,Id,Testa,Num,_).

/*
legal_pot_topic(Args, NF, X, SnX, Arg):-  
   X=..[ref_ex,SnX,Testa|_],
   checkpots(Args, SnX-Testa),!.
*/
checkpots([], Aa-Bb):-!.
checkpots([ref_ex(A,B,_,_,_,_,_,_/_)/_|Pairs], A-B):-
        fail,!.
checkpots([ref_ex(A,B,_,_,_,_,_,_/_)/_|Pairs], Aa-Bb):-
        A\=Aa, B\=Bb,
        checkpots(Pairs, Aa-Bb),!.

legal_pot_topic(Args, NF, X, SnX, Arg):-  
   X=..[ref_ex,SnX,Testa|_],
   nogen_member(ref_ex(SnX,Testa,Tab,_,Gen,Num,Cat,F/Role)/P, Args), 
     (Testa=Testa1-sc
      ;
      is_list(Testa), Testa1=Testa
      ;
      recover_descriptions(Testa, PredS),
      Testa1=PredS
      ;
      recover_description(Testa, PredS),
      Testa1=PredS),
   Testa\=pPro,
  ( Tab=[Ref, Def, Part, Card, _, _, Class];
    Tab=[Ref, Def, Part, Card, _, _, Class, _]),
   Ref = + ref,
   Testa \= vbl,
   Role \= misura,
   F/Role \= acomp/prop,
   Role \= comparativa,
   Role \= esplicativa,
   (
     nonvar(Cat),Cat\=[],Cat\=[_|_],
     notmembro(tempo, Cat),
     notmembro(temp, Cat),
     notmembro(modo, Cat);
     (var(Cat);Cat=[];Cat=[_|_];Cat=nil)
   ),
   Arg=arg(SnX/NF, Testa1, Def, Part, Card, Class, Num, Cat, F/Role),
   !.

legal_sec_topic(_, Sec, Id, SnX) :-
   Sec=ref_ex(SnX,Testa,Tab,_,Gen,Num,Cat,F/R),
   referente(SnX,Mods,Id,Testa,Num,Card1).

filtra_poten(Altri,NoFr) :-
   Altri=ref_ex(SnX,Testa,Tab,_,Gen,Num,Cat,F/R),
   !,
   Tab=[Ref, Def, Part, Card, _, _, Class],
   \+  
      (
      main_or_expect(NoFr, Ind),
      nonvar(Ind),
      fact(_,Testa, [Ind], 1, Temp, Loc) 
      ).


/* indefiniti e sn con definitezza zero */

narg(SnX/NoFr,Testa,Def,Part,Card,Class,Num,Cat,ncomp/prop,Mods,Id,Temp, Loc):-  
         nodo(N)::ncomp/_::indice::SnX,
         nodo(N)::ncomp/_::_/nil::controllore::An,
         referente(An,Mods,Id,Testa,Num,1),
         !.

narg(SnX/NoFr,Testa,Def,Part,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc):-  
   \+ ref(nil),
   coreferens(SnX, NoFr, Testa, Num, Mods, Id),
   proprieta(Id, Prop),
   (Prop=Testa
     ;
     Prop\=Testa,
     creatert(NoFr,Type,Mods,SnX,Testa,Card,Quant,Num,Ind,Temp, Loc),
     class_props(NoFr, SnX, Cat, Ind, fact, isa, Testa, 1, Temp, Loc),
     asserisci(NoFr, SnX, in(Ind, Id))
   ),    
   !.

narg(SnX/NoFr,Testa,Def,Part,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc):-  
   \+ ref(nil),
    recover_description(Testa, Pred),
    referente(SnX,Mods,Id,Pred,Num,Card),
    (
     proprieta_sempl(Id,Pred)
     ;
     proprieta_compl(Id,Pred)),
         !.   

narg(SnX/NoFr,Testa,Def,Part,Card,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc):-  
         nodo(N0)::adjs::adj/R::F/Role::indice::SnX,
         nodo(N0)::adjs::adj/R::F/Role::adjs::adj::sub/compar::pred::Pred,
         referente(SnX,Mods,Id,Pred,Num,1),
         fact(_,inst_of,[ind:Id, class:Testa],1,_,_),  
         !.   

/* come di una facile occasione*/
/* cio una specie di */
narg(SnX/NoFr,Tes,Def,Part,Card,Class,Num,Cat,sub/compar,Mods,Id,Temp, Loc):-  
         nodo(N0)::adjs::adj::sub/compar::F/R::pred::Testa,
         nodo(N)::F1/R1::nodo(N0),
         nodo(N)::F1/R1::pred::Test,
         referente(SnX,[],Id,Test,Num,1),
         (
          (Tes=specie; Tes=tipo; Tes=kind; Tes=type),Rel=kind_of
           ;
           Rel=isa),
         asserisci(NoFr,SnX,sit(Rel,[ind:Id,class:Testa],1,Temp, Loc)),
         !.   

narg(SnX/NoFr,Testa,Def,Part,Card,Class,Num,Cat,sub/compar,Mods,Id,Temp, Loc):-  
         nodo(n1)::adjs::adj::sub/compar::pred::Testa,
         nodo(n1)::sogg/_::indice::SnI,
         nodo(n1)::F1/R1::pred::Test,
         (referente(SnI,_,Id,Test,Num,1)
          ;
           1<NoFr, risolto(NoFr, SnI, Test, Test1),
           proprieta(Id,Test1)),  
         creatert(NoFr,ind,Mods,SnX,Testa,Card,Quant,Num,Idx,Temp, Loc),
         class_props(NoFr, SnX, Cat, Idx, fact, isa, Testa, 1, Temp, Loc),
         asserisci(NoFr,SnX,fact(isa,[ind:Id,class:Testa],1,Temp, Loc)),
         !.   

narg(SnX/NoFr,Testa,Def,Part,Card,Class,Num,Cat,sub/compar,Mods,Id,Temp, Loc):-  
         nodo(N0)::adjs::adj::sub/compar::_::nome_mod::pred::Tes,
         (Tes=specie; Tes=tipo; Tes=kind; Tes=type),
         creatert(NoFr,ind,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
         asserisci(NoFr,SnX,sit(kind_of,[ind:Id,class:Testa],1,Temp, Loc)),
         default_properties(NoFr, SnX, Cat, Pred, Id, Temp, Loc),
         !.   

narg(SnX/NoFr,Testa,Def,Part,Card,Class,Num,Cat,sub/compar,Mods,Idx,Temp, Loc):-  
         nodo(N0)::F1/R1::adjs::adj::sub/compar::indice::SnX,
         nodo(N0)::F1/R1::pred::Test,
         (referente(SnX,Mods,Id,Test,Num,1), Test1=Test
          ;
           1<NoFr, risolto(NoFr, SnY, Test, Test1)),
         !,
         fact(_,isa,[ind:Id, class:Test1],1,_,_),  
         creatert(NoFr,ind,Mods,SnX,Testa,Card,Quant,Num,Idx,Temp, Loc),
         class_props(NoFr, SnX, Cat, Idx, sit, isa, Testa, 1, Temp, Loc),
         asserisci(NoFr,SnX,sit(isa,[ind:Id,class:Testa],1,Temp, Loc)),
         !.   

narg(SnX/NoFr,Testa,Def,Part,Card0,Class,Num,Cat,_/compar,Mods,Id,Temp, Loc):-  
         nodo(N0)::adjs::adj/R::F/compar::indice::SnX,
         trova_card(SnX,Num,Part, Quant, Card0,Card),
         creater(NoFr,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
         class_props(NoFr, SnX, Cat, Id, sit, isa, Testa, 1, Temp, Loc),
         !.   

narg(SnX/NoFr,Testa,Def,Part,Card0,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc):-  
         nodo(N0)::fcomp/R::F/Role::indice::SnX,
         nodo(N0)::cat::SemCat, 
         (SemCat=presuppositivo;SemCat=soggettivo),
         nodo(N1)::F/Role::indice::SnX,
         nodo(N1)::pred::Rel,
         1<NoFr,risolto(NoFr,SnY,Anaf,Tes), 
         nodo(N1)::_/R3::pred::Anaf,
         fact(_,Rel,[R1:_, R2:Id2, R3:Id3],1,_,_),  
         fact(_,name,[Tes,Id3],1,_,_),  
         fact(_,isa,[ind:Id2, class:Te],1,_,_),  
         trova_card(SnX,Num,Part, Quant, Card0,Card),
         creater(NoFr,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
         class_props(NoFr, SnX, Cat, Id, sit, isa, Testa, 1, Temp, Loc),
         asserisci(NoFr,SnX,fact(isa,[Te,Id],1,Temp, Loc)),
         !.   

narg(SnX/NoFr,Testa,Def,Part,Card0,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc):-
         (Role=tema_bound;Role=theme_bound),
         nogen_member(attivita,Cat),
         PrecNoFr is NoFr - 1,
         topic(PrecNoFr,_,Id1),
         ind(_,Id1),
         fact(_,Rel,[R1:_, prop:Infon],1,_,_),
         fact(Infon,Prop,[nil:Id1],1,_,_),
         fact(_,role,[Prop,Idx,Id1],1,_,_),  
         trova_card(SnX,Num,Part, Quant, Card0,Card),
         creater(NoFr,Mods,SnX,Testa,Card, Quant,Num,Id,Temp, Loc),
         class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
         asserisci(NoFr,SnX,fact(isa,[ind:Idx,class:Testa],1,Temp, Loc)),
         !.   

narg(SnX/NoFr,Testa,Def,Part,Card0,Class,Num,Cat,F/R,Mods,Idy,Temp, Loc):-  
   F\=sogg,
   nodo(N0)::cat::soggettivo,
   \+ nogen_member(relazionale,Cat), 
   proprieta(Idy,Testa),
   fact(_, poss, [Prop, Id, Idy], 1, _, _),
   main_or_expect(NoFr, Id),
   fact(_, isa,[ind:Idy,class:Testa],1,_,_),
   restriz_sit(SnX, Idy, Temp, Loc),
   !.
 
narg(SnX/NoFr,Testa,Def,Part,Card0,Class,sing,Cat,F/Role,Mods,Ind,Temp, Loc):-  
         trova_card(SnX,Num,Part, Quant, Card0,Card),
          atomic(Testa),
         referente(SnX,[],Id,Testa,plur,Card1),
         creatert(NoFr,ind,Mods,SnX,Testa,Card,Quant,Num,Ind,Temp, Loc),
         class_props(NoFr, SnX, Cat, Ind, fact, isa, Testa, 1, Temp, Loc),
         asserisci(NoFr, SnX, in(Ind, Id)),
         !.   

narg(SnX/NoFr,Testa,Def,Part,Card0,Class,sing,Cat,F/Role,Mods,Id,Temp, Loc):-  
         nonvar(Cat),
         nogen_member(oggetto,Cat),
         nogen_member(luogo,Cat),
         current_main_loc(NoFr, luogo, LocInfo),
         arg(1, LocInfo, Ind),
         arg(2, LocInfo, Pred),
         getmain_location(N,Pred1), 
         included(Pred1,Pred),
         PrecNoFr is NoFr - 1,
         topic(PrecNoFr,_,Idy),
         ind(_,Idy),
         fact(Infon,name,[Prop,Idy],1,_,_),  
         trova_card(SnX,Num,Part, Quant, Card0,Card),
         creater(NoFr,ind,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
         class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
         asserisci(NoFr,SnX,in(Id,Ind)),
         create_infer_rel(NoFr, Idy,Id,Temp, Loc),
         !.   

narg(SnX/NoFr,Testa,Def,Part,Card0,Class,Num,Cat,obl/Role,Mods,Id,Temp, Loc):-
         (Role=locative;Role=locat
         ;
         nonvar(Cat),
         nogen_member(luogo,Cat)),
         current_main_loc(NoFr, luogo, LocInfo),
         arg(1, LocInfo, Id),
         arg(2, LocInfo, Pred),
         Pred=Testa,
         class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
         !.   

narg(SnX/NoFr,Testa,Def,Part,Card0,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc):-  
        quant_scope(SnX,Num,F/Role,Num1), 
        (var(Card),
         trova_card(SnX,Num1,Part, Quant, Card0,Card)
         ;
         nonvar(Card)),
         creater(NoFr,Mods,SnX,Testa,Card,Quant,Num1,Id,Temp, Loc),
         ( 
           nodo(N0)::F/R::indice::SnX,
           F\=sogg,
           nodo(N0)::cat::soggettivo, 
          asserisci(NoFr,SnX,sit(isa,[ind:Id,class:Testa],1,Temp, Loc))
          ;
          nodo(N0)::F/R::nodo(N),
          nodo(N)::mods::mod/predic::nodo(N1),
          nodo(N1)::modo::cong,
          asserisci(NoFr,SnX,sit(isa,[ind:Id,class:Testa],1,Temp, Loc))
          ;
          nodo(N2)::antecedente::SnX,
          nodo(N2)::interpretazione::arbitraria,
          asserisci(NoFr,SnX,sit(isa,[ind:Id,class:Testa],1,Temp, Loc))
          ;
          nodo(N4)::F/Role::indice::SnX,
          nodo(N4)::adjs::neg::_,
          Pol=0,
          asserisci(NoFr,SnX,sit(isa,[ind:Id,class:Testa],0,Temp, Loc))
          ;
          ( nodo(N0)::vcomp/_::F/R::indice::SnX
          ->
          asserisci(NoFr,SnX,sit(isa,[ind:Id,class:Testa],1,Temp, Loc))
          ;
          asserisci(NoFr,SnX,fact(isa,[ind:Id,class:Testa],1,Temp, Loc))
          )
         ),
         default_properties(NoFr, SnX, Cat, Pred, Id, Temp, Loc),
         !.   

narg(SnX/NoFr,Testa,Def,Part,Card0,Class,Num,Cat,F/Role,Mods,Id,Temp, Loc):-  
         genre(legal),
          atomic(Testa),
          (referente(SnX,Mods,Id,Testa,Num,Card)
          ;
          infer_prop_sempl(Ind,Testa),
          creatert(NoFr,class,Mods,SnX,Testa,Card, Quant,Num,Id,Temp, Loc),
          asserisci(NoFr, SnX, in(Ind, Id)),
          class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc)
           ;
          creatert(NoFr,class,Mods,SnX,Testa,Card, Quant,Num,Id,Temp, Loc),
          class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc)
          ),
          !.

getmain_location(N,Pred) :-
   (Role=locat;Role=locativo;Role=goal),
   nodo(N)::adj/Role::sem_mark::Sem,
   nodo(N)::adj/Role::pred::Pred,
   nodo(N)::adj/Role::cat::Cat,
   (on(luogo,Cat);
   on(place,Cat)),
   !.

getmain_location(N,Pred) :-
   (Role=locat;Role=locativo;Role=goal),
   nodo(N)::adj/Role::sem_mark::Sem,
   nodo(N)::adj/Role::nodo(N1),
   nodo(N1)::ogg/_::pred::Pred,
   nodo(N1)::ogg/_::cat::Cat,
   (on(luogo,Cat);
   on(place,Cat)),
   !.

getmain_location(N,Pred) :-
   (Role=locat;Role=locativo;Role=goal),
   nodo(N)::pcomp/Role::nodo(N1),
   nodo(N1)::ogg/_::pred::Pred,
   nodo(N1)::ogg/_::cat::Cat,
   (on(luogo,Cat);
   on(place,Cat)),
   !.

create_infer_rel(NoFr, Agent,Location,Temp, Loc):-
         gen_sym(id, EvId),
         info(NoFr, Node, FunRole, View, Intens, Change, Rel, VerbCat, Verb,TempRel, DiscRel, DiscDom, SubjConsc),
         TempRel=..[Relt,Tr1, Tr2],
         gen_sym(f, Fr),
         concat(Fr, '_', Tr),
         concat(Tr, EvId, Tr3),
         Infon=..[fact, EvId, sit, [actor:Agent,locat:Location], 1, tes(Tr3), Loc],
         assert(Infon),
         assert(confer_infon(EvId, NoFr, nil, nil, main)),
         assert(after(tes(Tr3), Tr2)),
         assert_time_infer(NoFr, EvId, tes(Tr3), Loc),
         assert_tense_infer(NoFr,tes(Tr3), Loc),
         write_inclusion(after, tes(Tr3), Tr2),
         !.
assert_time_infer(NoFr, EvId, T, L):-
         gen_sym(infon, InfonId),
         Infon=..[fact, InfonId, isa, [arg:EvId, arg:ev], 1, T, L],
         assert(Infon),
         assert(confer_infon(InfonId, NoFr, nil, nil, main)),!.

assert_tense_infer(NoFr, T, L):-
         gen_sym(infon, InfonId),
         gen_sym(id, TenseId),
         Infon=..[fact, InfonId, isa, [arg:TenseId, arg:tloc], 1, T, L],
         assert(Infon),
         gen_sym(infon, InfonId1),
         Infon1=..[fact, InfonId1, isa, [arg:TenseId], 1, T, L],
         assert(Infon1),
         assert(confer_infon(InfonId, NoFr, nil, nil, main)),
         assert(confer_infon(InfonId1, NoFr, nil, nil, main)),!.

quant_scope(SnX,Num,F/R,Num1):-
       (  nodo(N)::indice::SnX,
          nodo(N)::qmark::Q1,
        (
          nodo(N4)::F/Role::indice::SnX,
          nodo(N4)::adjs::neg::_,
          Pol=0,
          Num1=Num
         ;
          nodo(N1)::qmark::Q2,
          Q2\=Q1,
   /*ci sono due quants che devono essere uno nello scope dell'altro */
         (nodo(N1)::spec::card::Card,
          nodo(N)::interpretazione::quantificata,
          nodo(_)::qops::Quants, on(Q2, Quants), on(Q1, Quants)
          ;
          nodo(N)::interpretazione::quantificata,
          nodo(_)::qops::Quants, on(Q2, Quants), on(Q1, Quants),
          Num1=nil
          ;
          nodo(N)::interpretazione::arbitraria,
          Num1=nil
          ;
          nodo(N)::interpretazione::quantificata,
          nodo(N1)::spec::quant::_,
          nodo(N1)::sogg/nil::controllore::Contr,
          individua_antecedente(Contr, Idx, _, Card),
          (integer(Card),
           Num1=plur
           ;
           Num1=sing)
           ;
           Num1=Num)
         )
         ;
          nodo(N)::antecedente::SnX,
          nodo(N)::interpretazione::arbitraria,
          Num1=nil
         ;
          nodo(N0)::F/R::nodo(N),
          nodo(N)::mods::mod/predic::nodo(N1),
          nodo(N1)::modo::cong,
          Num1=nil
          ;
          Num1=Num).

write_rhet_structure(Win, NoFrase) :-
   nl, nl, writenl('RHETORICAL STRUCTURE:'),
   stato(NoFrase, Stato),
   writenl(
      stato(NoFrase, Stato)),
   (
   on(Type, [expected, main, secondary, potential]),
   once(topic(NoFrase, Type, Ind)), 
   writenl(topic(NoFrase, Type, Ind)),
   fail 
   ; 
   true
   ),
   !.
write_rhet_structure(_, _). 


write_sentence_infons(Win, NoFr) :-
   confer_infon(Id, NoFr, _, _, _),
   infon(Id, Fact),
   writenl(Fact), 
   fail. 
write_sentence_infons(_,_).
    

infon(Id, loc(Id,A,B)) :-
   nonvar(Id),
   loc(Id,A,B),
   !.

infon(Id, ind(Id,A)) :-
   nonvar(Id),
   ind(Id,A),
   !.

infon(Id, set(Id,A)) :-
   nonvar(Id),
   set(Id,A),
   !.

infon(Id, ent(Id,A)) :-
   nonvar(Id),
   ent(Id,A),
   !.

infon(Id, class(Id,A)) :-
   nonvar(Id),
   class(Id,A),
   !.

infon(Id, in(Id,A,B)) :-
   nonvar(Id),
   in(Id,A,B),
   !.

infon(Id, card(Id,A,B)) :-
   nonvar(Id),
   card(Id,A,B),
   !.

infon(Id, fact(Id,B,C,D,E,F)) :-
   nonvar(Id),
   fact(Id,B,C,D,E,F),
   !.

infon(Id, sit(Id,B,C,D,E,F)) :-
   nonvar(Id),
   sit(Id,B,C,D,E,F),
   !.

find_ref(NoFr,N,SnX,SnY,Testa,Id,Typ,Ro,Temp, Loc) :-
   cerca(modo,N,_),
   setof(N1-Type,(nodo(N)::Type::nodo(N1)), Mods),
   on(_-sogg/R, Mods),
   nodo(N)::sogg/R::controllore::SnW,
   remove(_-sogg/R, Mods, Args),
   (Args=[]
    ;
   on(N0-Type, Args),
   (atomic(Type), Typ=adj,
    N2=N0 
    ;
    nodo(N2)::F/Ro::nodo(N0), Typ=arg
   ),
   nodo(N2)::F/Ro::pred::Testa,
   nodo(N2)::F/Ro::indice::SnY,
   (proprieta(Id, Testa)
   ;
    build_ref(NoFr,N0,SnY,Testa,Id,Temp, Loc),
    class_props(NoFr, SnY, Cat, Id, fact, isa, Testa, 1, Temp, Loc)
    )),
   !.

build_ref(NoFr,N,SnX,Testa,Id,Temp, Loc) :-
   cerca(pers,N,Pers),
   cerca(gen,N,Gen),
   cerca(num,N,Num),
   cerca(cat,N,Cat),
   cercadef(N,Def),
   cercapart(N,Part),
   cercacard(N,Card),
   (f_struttura(Ind,Funz/Ruolo,N),
   ! ; Funz/Ruolo = nil/nil),
   trova_card(SnX,Num,Part,Quant,Card,Card0),
   (genre(legal),
     (nogen_member(istituzione,Cat), 
      ClassSpec=set, 
      (Card0=1,Cardin='>10'
         ;
       Cardin=Card0)
     ;
     Cardin=Card0, ClassSpec=class),
     (
      notnodco(_, coordina, F/R, SnX),
      creatert(NoFr, ClassSpec, 
                N, SnX, Testa, Cardin, Quant, Num, Id, Temp, Loc)
      ;
     creater_coo(NoFr, Type, 
                Mods, SnX, Testa, Cardin, Quant, Num, Id, Temp, Loc) 
     )      
    ;
    (
      notnodco(_, coordina, F/R, SnX),
     creater(NoFr, N, SnX, Testa, Card0, Quant, Num, Id, Temp, Loc)
     ;
     creater_coo(NoFr, Type, 
                Mods, SnX, Testa, Card0, Quant, Num, Id, Temp, Loc) 
      )).

notnodco(N, Attributo, Funzioni, Ind):-
   findall(Funzioni, 
           nodo(N)::Attributo::Funzioni::indice::Ind, Ps),
   Ps=[],!.

notnodco1(N, Attributo, Funzioni):-
   findall(Value, 
           nodo(N)::Funzioni::Attributo::nodo(Value), Ps),
   Ps=[],!.

creatertq(NoFr, Class, Mods, SnX, Testa, Card, Quant, Num, Ind, Temp, Loc) 
   :-
   \+ interp(compl),
    creatert(NoFr, Class, Mods, SnX, Testa, Card, Quant, Num, Ind, Temp, Loc),
   !.

creatertq(NoFr, Class, Mods, SnX, Testa, Card, Quant, Num, Ind, Temp, Loc) 
   :-
   interp(compl),
    creatert(NoFr, Class, Mods, SnX, Testa, Card, Quant, Num, Ind, Temp, Loc),
   !.

creatert(NoFr, Type, Mods, SnX, Testa, Card, Quant, Num, Ind, Temp, Loc) 
   :-
   \+ interp(compl),
   gen_sym(id, Ind),
  (
   (Type=ind;Type=name),
   asserisci(NoFr, SnX, ind(Ind)), 
   ! ;
   Type=class,
   asserisci(NoFr, SnX, class(Ind)),
   ! ;
   Type=set,
   asserisci(NoFr, SnX, set(Ind)),
   asserisci(NoFr, SnX, card(Ind,Card))
   ),!.

creatert(NoFr, Type, Mods, SnX, Testa, Card, Quant, Num, Ind, Temp, Loc) 
   :-
   interp(compl),
   gen_sym(id, Ind),
   poss_restriction(Mods, Modd, NoFr, SnX, Ind, Loc, Temp, Card, Card1),
  (
   (Type=ind;Type=name),
   asserisci(NoFr, SnX, ind(Ind)), 
   ! ;
   Type=class,
   asserisci(NoFr, SnX, class(Ind)),
   ! ;
   Type=set,
   asserisci(NoFr, SnX, set(Ind)),
   asserisci(NoFr, SnX, card(Ind,Card))
   ),
   restrizioni(NoFr, Modd, SnX, Ind, Temp, Loc),
   restriz(NoFr, Modd, SnX, Ind, Temp, Loc),
   cerca_coordinati(Type, class, NoFr, SnX, Ind, Testa, Temp, Loc),!.

/*
qui viene passato il primo ind, poi gli altri/altro vengono creati
dentro coordinati */

cerca_coordinati(Type, Class, NoFr, SnX, Ind, Testa2, Temp, Loc):-
   nodo(N)::Fun/Role::indice::SnX,
   (      
%     notnodco1(_, coordina, Fun/Role),
    coordinati(Type, -class, NoFr, SnX, Ind, Pred, Idx, Temp, Loc),
    nonvar(Idx),
    asserisci(NoFr, _, fact(isa,[ind:Idx, class:[Testa2,Pred]], 1, Temp, Loc))
    ;
    nodo(N)::Fun/Role::coordina::nodo(N1)).

cerca_coordinati(Type, Class, NoFr, SnX, Ind, Testa2, Temp, Loc).

creater_coo(NoFr, Type, 
                Mods, SnX, Testa, Card, Quant, Num, Ind, Temp, Loc) 
   :-
   gen_sym(id, Ind),
   poss_restriction(Mods, Modd, NoFr, SnX, Ind, Loc, Temp, Card, Card1),
  (Type=ind,
   asserisci(NoFr, SnX, ind(Ind)), 
   ! ;
   Type=class,
   asserisci(NoFr, SnX, class(Ind)),
   ! ;
   Type=set,
   asserisci(NoFr, SnX, set(Ind)),
   asserisci(NoFr, SnX, card(Ind,Card))
   ),
   restrizioni(NoFr, Modd, SnX, Ind, Temp, Loc),
   restriz(NoFr, Modd, SnX, Ind, Temp, Loc),
   (Type=set,asserisci_topic(NoFr, potential, Ind, SnX);Type\=set),
   !.

creater(NoFr, Mods, SnX, Testa, Card, Quant, Num, Ind, Temp, Loc) 
   :-
   gen_sym(id, Ind),
   poss_restriction(Mods, Modd, NoFr, SnX, Ind, Loc, Temp, Card, Card1),
   (
   nonvar(Card1),
   var(Card),
   Card0=Card1,
   Card=Card1
   ;
   nonvar(Card),
   Card=some,
   (var(Quant), Quant=Card;Card0=5)
   ;
   nonvar(Card1),
   nonvar(Card),
   Card1<Card,
   Card0 is Card - Card1
   ;
   nonvar(Card1),
   nonvar(Card),
   Card<Card1,
   Card0 is Card1 - Card
   ;
   nonvar(Card1),
   Card0=Card1
   ;
   Card0=Card
   ),
%   individua_controllato(SnX, Ind, Temp, Loc),
   (
   nonvar(Card0),
   Card0=1,
   asserisci(NoFr, SnX, ind(Ind)), 
   Class=ind, 
   ! ;
   nonvar(Quant), Quant\=some,
   asserisci(NoFr, SnX, class(Ind)), 
   Class=class,
   ! ;
   nonvar(Quant), Quant=some,
   asserisci(NoFr, SnX, ent(Ind)), Class=ent,
   ! ;
   testcard3(Card0),
   asserisci(NoFr, SnX, set(Ind)), Class=set,
   asserisci(NoFr, SnX, card(Ind,Card0))
   ),
   restrizioni(NoFr, Modd, SnX, Ind, Temp, Loc),
   restriz(NoFr, Modd, SnX, Ind, Temp, Loc),
   cerca_coordinati(Type, Class, NoFr, SnX, Ind, Testa, Temp, Loc),!.

antecedent_deictic_predication(RefList,Est,R1):-
          ((R1\=tema_bound;R1\=theme_bound); 
            (R1=tema_bound;R1=theme_bound), 
            on(ref_ex(Es2,Testa2,Tab_ref2,Pers2,Gen2,Num2,Cat2,ncomp/R2)/_,RefList),
            Testa2\=reason,Testa2\=way),                      
            verifycontroller_antecendent(Es2,Est),
            !.
antecedent_deicticpredication(ref_ex(Est,Testa,Tab_ref,Pers,Gen,Num,Cat,F/R)):-
                   Tab_ref = [+ref,+def,nil,_,+pro,-ana,+class],
          ((R1\=tema_bound;R1\=theme_bound); 
            (R1=tema_bound;R1=theme_bound), 
            verifycontroller_antecendent_head(Tes,Est),
            Tes\=reason,Tes\=way),                      
            !.
antecedent_deicticpredication(ref_ex(Est,Testa,Tab_ref,Pers,Gen,Num,Cat,F/R)):-
                   Tab_ref \= [+ref,+def,nil,_,+pro,-ana,+class],!.


bindantecedent_deicticpredication(ref_ex(Est,Testa,Tab_ref,Pers,Gen,Num,Cat,F/R1)):-
                   Tab_ref = [+ref,+def,nil,_,+pro,-ana,+class],
          ((R1\=tema_bound;R1\=theme_bound); 
            (R1=tema_bound;R1=theme_bound), 
            verifycontroller_antecendent_head(Tes,Est),
            (Tes=reason;Tes=way)),                      
            !.
verifycontroller_antecendent(Ind, Contr):-
	nodo(N)::indice::Ind,
	nodo(N)::sogg/nil::controllore::Contr,!.

verifycontroller_antecendent_head(Pred, Contr):-
	nodo(N)::indice::Ind,
	nodo(N)::pred::Pred,
	nodo(N)::sogg/nil::controllore::Contr,!.


/* *************************************************** */
matcha2(NFrase,ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R),proposto,Tes) 
:-
       proposto(ref_ex(_,Tes,_,P,G,N,C,F1/R1)),
       matcha_features(Testa,Tab,P,G,N,Pers,Gen,Num,C),
       instance(Tes,C,Cat),!.

matcha2(NFrase,ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R),secondario,Tes) 
:-
       secondario(ref_ex(_,Tes,_,P,G,N,C,F1/R1)),
       matcha_features(Testa,Tab,P,G,N,Pers,Gen,Num,C),
       instance(Tes,C,Cat),!.

matcha2(NFrase,ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R),altri,FrasePrec,Tes) 
:-
       altri(ref_ex(_,Tes,_,P,G,N,C,F1/R1),FrasePrec),
       matcha_features(Testa,Tab,P,G,N,Pers,Gen,Num,C),
       instance(Tes,C,Cat),!.

matcha(NFrase,ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R),altri,FrasePrec,Tes1, Tes) 
:-
       antecedent_deicticpredication(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)),
       altri(ref_ex(Ind,Tes,_,P,G,N,C,F1/R1),FrasePrec),
       Tes\=Tes1,
       matcha_features(Testa,Tab,P,G,N,Pers,Gen,Num,C),
       controlla_cat1(Cat,C),
       !.

matcha(NFrase,ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R),proposto,Tes) 
:-
       antecedent_deicticpredication(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)),
       proposto(ref_ex(_,Tes,_,P,G,N,C,F1/R1)),
       Tes\=this,Tes\=that,
      (
       gr(romance),
       (F/R=sogg/poss; F/R=sogg/creator),
       (Num=N ; Num=nil ; N=nil; Num\=N)
       ; 
       Testa=pPro
       ;
       nogen_member(istituzione,C), notmembro(umano,C), Num\=N
				   ; 
       N\=Num, generic_head(Tes,_)
       ;
       matcha_features(Testa,Tab,P,G,N,Pers,Gen,Num,C),
       controlla_cat1(Cat,C)
       ),!.

matcha(NFrase,ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R),principale,Tes) 
:-
       antecedent_deicticpredication(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)),
       principale(ref_ex(_,Tes,_,P,G,N,C,F1/R1)),
       Tes\=this,Tes\=that,
      (
       gr(romance),
       (F/R=sogg/poss; F/R=sogg/creator),
       (Num=N ; Num=nil ; N=nil; Num\=N)
       ;
       Testa=pPro
       ;
       nogen_member(istituzione,C), notmembro(umano,C), Num\=N
	; 
       generic_head(Tes,_), Num\=N
       ;
       matcha_features(Testa,Tab,P,G,N,Pers,Gen,Num,C),
       controlla_cat1(Cat,C)
       ),!.

matcha(NFrase,ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R),secondario,Tes) 
:-
       antecedent_deicticpredication(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)),
       secondario(ref_ex(_,Tes,_,P,G,N,C,F1/R1)),
       Tes\=this,Tes\=that,
      (
       gr(romance),
       (F/R=sogg/poss; F/R=sogg/creator),
       (Num=N ; Num=nil ; N=nil; Num\=N)
       ;
       Testa=pPro
       ;
       nogen_member(istituzione,C), notmembro(umano,C), Num\=N
       ;
       matcha_features(Testa,Tab,P,G,N,Pers,Gen,Num,C),
       controlla_cat1(Cat,C)
       ),!.

matcha(NFrase,ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R),altri,FrasePrec,Tes) :-
       antecedent_deicticpredication(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)),
       altri(ref_ex(_,Tes,_,P,G,N,C,F1/R1),FrasePrec),
       Tes\=this,Tes\=that,
       Tes\=indefinite,
      (
       gr(romance),
       (F/R=sogg/poss; F/R=sogg/creator),
       (Num=N ; Num=nil ; N=nil; Num\=N)
       ;
       Testa=pPro
       ;
       nogen_member(istituzione,C), notmembro(umano,C), Num\=N
       ;
       matcha_features(Testa,Tab,P,G,N,Pers,Gen,Num,C),
       controlla_cat1(Cat,C)
       ),!.

/*
matcha(NFrase,ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R),_,indefinite) 
:-
       assert(indefinite(SnX)), !.


matcha(NFrase,ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R),altri,_,indefinite) 
:-
       assert(indefinite(SnX)), !.
*/

recover_ref(Ind, Ref_ex):-
       trova_predpPro(Ind, Ref_ex),
       !.

trova_predpPro(Ind, ref_ex( Ind, Pred, [Ref,Def,Part,Card|Cref],
      Pers,Gen,Num,Cat,Funz/Ruolo))
   :-
   foglia(N1,Ind,_),
   arco(N,N1,indice,_),
   cerca(pred,N,Pred),
   cerca(tab_ref,N,[Ref|Cref]),
   cerca(pers,N,Pers),
   cerca(gen,N,Gen),
   cerca(num,N,Num),
   cerca(cat,N,Cat),
   cercadef(N,Def),
   cercapart(N,Part),
   cercacard(N,Card),
   (f_struttura(Ind,Funz/Ruolo,_), !
     ; 
    nodo(Nodo)::focus::sn_int::nodo(N),!,
     (nodo(Nodo)::F1/Ruolo::controllore::Contr      
      ;
      nodo(Nod)::sogg/nil::controllore::Contr
      ),

     Funz = focus
     ;
     nodo(Nodo)::focus::nodo(N),!,
     (nodo(Nodo)::F1/Ruolo::controllore::Contr
      ;
      nodo(Nod)::sogg/nil::controllore::Contr
      ),
      Funz = focus
     ;
     Funz/Ruolo = nil/nil).

matcha_features(Testa,Tab,P,G,N,Pers,Gen,Num,C) :-
        (Num=N ; Num=nil ; N=nil),
        (P=1; P=2; Pers=1; Pers=2; Pers=P ; Pers=nil ; P=nil),
        (var(Gen), Testa=it, notmembro(umano,C);
         var(Gen), member(+me, Tab);
         var(Gen), Testa=pro
        ;
         nonvar(Gen), 
        (Gen=G ; Gen=nil ; G=nil)).

check(ref_ex(S,T,Ta,P,G,N,C,F/R)/Pu,ref_ex(S1,T,Ta1,P1,G1,N1,C1,F1/R1)/Pu1):-
       (P=P1 ; P=nil ; P1=nil),
       (G=G1 ; G=nil ; G1=nil),
       (N=N1 ; N=nil ; N1=nil),
       (C=C1 ; C=nil ; C1=nil), !.

check_quantifier_scope(N, Num1):-
      nodo(N)::qmark::Q1,
      nodo(N1)::qmark::Q2,
      nodo(N2)::qops::Qop,
      member(Q1, Qop),
      member(Q2, Qop),
      nodo(N1)::spec::quant::Quant,
      on(Quant, [ogni, ognuno, molto, ciascuno, each, every]),
      Num1=nil.

modifica_testa([],_).
modifica_testa([ref_ex(Ind,Pred,Tab,Pers,Gen,Num,Cat,F/R)|Altri],
               [ref_ex(Ind,Ante,Contr,Tab,Pers,Gen,Num,Cat,F/R)|Rest]) :-
                nodo(N)::indice::Ind,
                nodo(N)::controllore::Contr,
                nuova_testa(Contr,Ante),
                modifica_testa(Altri,Rest).

modifica_testa([ref_ex(Ind,Pred,Tab,Pers,Gen,Num,Cat,F/R)|Altri],
               [ref_ex(Ind,Pred,Tab,Pers,Gen,Num1,Cat,F/R)|Rest]) :-
               Tab=[+ref, -def, nil, Card, -pro, -ana, +class],
                nodo(N)::indice::Ind,
                nodo(N)::interpretazione::quantificata,
                check_quantifier_scope(N, Num1),
                modifica_testa(Altri,Rest).

modifica_testa([ref_ex(Ind,Pred,Tab,Pers,Gen,Num,Cat,F/R)|Altri],
               [ref_ex(Ind,Ante,Tab1,Pers,Gen,Num,Cat,F/R)|Rest]) :-
                nodo(N)::indice::Ind,
                nodo(N)::antecedente::esterno,
                nodo(N)::interpretazione::arbitraria,
                (Tab = [Ref,Def,Part,Card,Pro,Ana,Me];
                 Tab = [Ref,Def,Part,Card,Pro,Ana,Me,Sub]),
                 Tab1 = [+arb,Def,Part,Card,Pro,Ana,Me,Sub],
                modifica_testa(Altri,Rest).


modifica_testa([ref_ex(Ind,Pred,Tab,Pers,Gen,Num,Cat,F/R)|Altri],
               [ref_ex(Ind,Ante,Contr,Tab,Pers,Gen,Num,Cat,F/R)|Rest]) :-
                nodo(N)::indice::Ind,
                nodo(N)::antecedente::Contr,
                nuova_testa(Contr,Ante),
                modifica_testa(Altri,Rest).

modifica_testa([ref_ex(Ind,Pred,Tab,Pers,Gen,Num,Cat,F/R)|Altri],Resto) 
                :-
                nodo(N)::indice::Ind,
                nodo(N)::pred::vbl,
                modifica_testa(Altri,Resto).

modifica_testa([ref_ex(Ind,Pred,Tab,Pers,Gen,Num,Cat,F/R)|Altri],
               [ref_ex(Ind,Pred,Tab,Pers,Gen,Num,Cat,F/R)|Resto]) 
                :-
                modifica_testa(Altri,Resto).

nuova_testa([Ind, In],[Nt1, Nt2]):-
            nodo(N1)::indice::Ind,
            nodo(N1)::pred::Nt1,
            nodo(N2)::indice::In,
            nodo(N2)::pred::Nt2.

nuova_testa(Indice,Ntesta):-
            nodo(N1)::indice::Indice,
            (nodo(N1)::antecedente::Contr ; 
              nodo(N1)::controllore::Contr),
            Indice\=Contr,
            nuova_testa1(Contr,Indice,Ntesta).

nuova_testa(Indice,Ntesta):-
            nodo(N1)::indice::Indice,
            nodo(N1)::pred::Ntesta.

nuova_testa1(Indice,Contr,Ntesta):-
            nodo(N1)::indice::Indice,
            nodo(N1)::pred::Ntesta.


modifica_testa1(OldList,List) :-
     estrai(est(SnX,Testa1),OldList,List1),
     estrai(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)/P,List1,List2),
    
    (F=sogg, R=poss,
       (principale(ref_ex(_,Testa1,_,Pe,G,Nu,C,F1/R1));
        altri(ref_ex(_,Testa1,_,Pe,G,Nu,C,F1/R1),FrasePrec);
        secondario(ref_ex(_,Testa1,_,Pe,G,Nu,C,F1/R1))),
       Gen1=G, Pers1=Pe
     ;
     (Testa=pro;Testa=pPro),
       (principale(ref_ex(_,Testa1,_,Pe,G,Nu,C,F1/R1));
        altri(ref_ex(_,Testa1,_,Pe,G,Nu,C,F1/R1),FrasePrec);
        secondario(ref_ex(_,Testa1,_,Pe,G,Nu,C,F1/R1))),
       Gen1=G, Pers1=Pe
     ;
     Gen1=Gen, Pers1=Pers, F1=F, R1=R),

     append([ref_ex(SnX,Testa1,Tab,Pers1,Gen1,Num,Cat,F/R)/P],List2,List3),
%     retract(esterno(SnX)),
     frase_corrente(N,_),
     (Testa1=TestA-sc;Testa1=TestA),                     % MODIFICATO!!
     assertz(risolto(N, SnX, Testa, TestA)),     % memorizza risolti - Testa=Anaf 
     modifica_testa1(List3,List),
     !.

modifica_testa1(Lis,Lista1) :- bubblesort(Lis,Lista1).

modifica_testa_deic(OldList,List) :-
     estrai(deic(SnX,Testa1),OldList,List1),
     estrai(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)/P,List1,List2),
     append([ref_ex(SnX,Testa1,Tab,_,Gen,Num,Cat,F/R)/P],List2,List3),
%     retract(esterno(SnX)),
     frase_corrente(N,_),                      % MODIFICATO!!
     assertz(risolto(N,SnX,Testa,Testa1)),     % memorizza risolti - Testa1=Ante
     modifica_testa1(List3,List),
     !.
/* punteggio dei tratti semantici */

punteggio_tratto1(Lista,1) :-
                 member(X,Lista),
                 member(X,[animato,istituzione,luogo,role,informa,strumento]), !.

punteggio_tratto1(Lista,0) :-
                 member(X,Lista),
                 member(X,[umano,hum_set,hum,legale]), !.

punteggio_tratto1(Lista,100).

bubblesort1(List,Sorted) :-
  swap1(List,List1), !,
  bubblesort1(List1,Sorted).
bubblesort1(Sorted,Sorted).

swap1([X,Y|Rest],[Y,X|Rest]) :- gt1(X,Y).
swap1([Z|Rest],[Z|Rest1]) :- swap1(Rest,Rest1).

gt1(N1/P1,N2/P2) :- P2<P1.

/* predicati per accessi alle f_strutture  

cerca(gen,N,nil) :-
              nodo(N)::tab_ref::Tab,
              Tab = [+ref,+pro,-ana,+me],!.
*/
 
/* IL GENERE DI UN POSSESSIVO NON VIENE UTILIZZATO */

cerca(Attrib,N,Val) :-
                arco(N,N1,Attrib,_),
                foglia(N1,Val,_), !
               ;
                 Val = nil, 
%               Val \= prep(P),
                  !.
cercadef(N,Def):-
                arco(N,N1,spec,_),
                 cerca(def,N1,Def1),
                 (conv_def(Def1,Def);
                 conv_def_n(Def1,Def)),!;
                  Def = def0.
conv_def(+,+def).
conv_def(-,-def).
conv_def_n(0,def0).
conv_def_n('0',def0).
cercapart(N,Part):-
                arco(N,N1,spec,_),
                 cerca(part,N1,Part1),
                 conv_part(N1,Part1,Part),!;
                 Part = nil.
conv_part(N1,+,Part):-
  cerca(quant,N1,Quant),
  (Quant\= nil,
   classe(Quant, Cl),
    (Cl=2, Part=Quant; Cl\=2, Part= +part)
   ;
   Quant=nil, Part= +part).
conv_part(N1,-,Part):-
  cerca(quant,N1,Quant),
  (Quant\= nil,
   classe(Quant, Cl),
    (Cl=2, Part=Quant; Cl\=2, Part= +part)
   ;
   Quant\=nil, Part= Quant
   ;
   Quant=nil, Part= +part).
conv_part(N1,'0','0part').

cercacard(N,Card):-
                 arco(N,N1,spec,_),
                 cerca(card,N1,Card),!;
                 Card = nil.


trova_pred(
   Ind,
   ref_ex(
      Ind,
      Pred,
      [Ref,Def,Part,Card|Cref],
      Pers,Gen,Num,Cat,Funz/Ruolo))
   :-
   foglia(N1,Ind,_),
   arco(N,N1,indice,_),
   cerca(pred,N,Pred),
%   Pred\=pPro,
   cerca(tab_ref,N,[Ref|Cref]),
   cerca(pers,N,Pers),
   cerca(gen,N,Gen),
   cerca(num,N,Num),
   cerca(cat,N,Cat),
   cercadef(N,Def),
   cercapart(N,Part),
   cercacard(N,Card),
   (f_struttura(Ind,Funz/Ruolo,_), !
     ; 
    nodo(Nodo)::focus::sn_int::nodo(N),!,
     (nodo(Nodo)::F1/Ruolo::controllore::Contr      
      ;
      nodo(Nod)::sogg/nil::controllore::Contr
      ),

     Funz = focus
     ;
     nodo(Nodo)::focus::nodo(N),!,
     (nodo(Nodo)::F1/Ruolo::controllore::Contr
      ;
      nodo(Nod)::sogg/nil::controllore::Contr
      ),
      Funz = focus
     ;
     Funz/Ruolo = nil/nil).

/* pretty print anafora */

ppa(X,I) :- atomic(X),tab(I),write(X),nl, !.
ppa([],I) :- tab(I),write([]),nl,!.
ppa([H|T],I) :- !,
          J is I + 1, ppa(H,J), ppxa(T,J),
          !.
ppa(Struttura,I) :- Struttura =.. [Func|[[]]],
          tab(I),write(Func),tab(1),write([]),nl,!.
ppa(Struttura,I) :- Struttura =.. [Func|Args],
          member(Func,[a,sn,/,x_ref]),
          tab(I),write(Struttura),nl,!.
ppa(Struttura,I) :- Struttura =.. [Func|Args],tab(I),write(Func),nl,
          J is I + 1, ppa(Args,J),!.

ppxa([],_) :- !.
ppxa([H|T],I) :- ppa(H,I), ppxa(T,I), !.


check_itpleonastic(RefList,it,sogg,R):-
     (R=theme_bound;R=tema_bound),
       on(ref_ex(Ind,it,Tab_ref,Pers,Gen,Num,Cat,sogg/R)/_,RefList),
          nodo(N)::indice::Ind,
          nodo(N)::pred::Pred,Pred=it,
          nodo(N2)::sogg/Ruolo::nodo(N),
          nodo(N2)::acomp/Ruol::nodo(N1),
          nodo(N1)::sogg/nil::controllore::Ind,
     !.
     

risolvi_esterni(Frase, RefList, L1) :-
   findall(esterno(Snx), 
      (
      nodo(N) :: indice :: Snx,
      nodo(N) :: antecedente :: esterno
      ),
      L),
   (
   L \= [],
   sort_eq(L, LL),
   risolvi1(Frase, RefList, LL, L1)
   ;
   LL = [],
   L1 = RefList
   ),!.

sort_eq([], LL):-!.

sort_eq([L], [L]):- !.

sort_eq([L|Rest], L2):- 
    on(L, Rest),
    efface(L, Rest, NRest),
    sort_eq(NRest, [L], L2)
    ;
    sort_eq(Rest, [L], L2),
   !.
sort_eq(L, L1, L2):- 
     append(L1, L, L2),!.


risolvi1(NFrase, RefList, [], []) :-!.
risolvi1(NFrase, RefList, [esterno(Deic1)], ListOut) :-
   N1 is NFrase - 1,
%   N1 \= 0,
   RefList =
      [ref_ex(Ind, Testa, Tab_ref, Pers, _, _, _, F/R) / _ | Altri],
   nonvar(Pers),
   on(Pers, [1, 2]),
   risolvi_uno_deic(NFrase, RefList, Deic1, ListOut),
   !.

risolvi1(NFrase,RefList,[esterno(Est1),esterno(Est2)],ListOut) 
     :-
   (Ind=Est1, Ind1=Est2;Ind=Est2, Ind1=Est1),
   remove(ref_ex(Ind, Testa, Tab_ref, Pers, _, _, _, F/R)/_,RefList,Altri),
   nonvar(Pers),
   on(Pers, [1, 2]),
   risolvi_uno_deic(NFrase, RefList, Ind, Out),
   risolvi1(NFrase,Out,[esterno(Ind1)],ListOut),
   !.
   
risolvi1(NFrase,RefList,[esterno(Est1),esterno(Est2)],ListOut) 
     :-
   RefList =
      [ref_ex(I, Testax, Tab_ref, Per, _, _, _, _) / _ | Altr],
     (     
     fetch_sc(NFrase, TestaX, Factive, Change, Rel, VerbCat, DiscDom, Testa), 
     (
      check_definit(short_ana, RefList, F, R, Tab_ref, Gen, Es, Testa1)
       ;
      check_definit(clit,RefList, F,  R, Tab_ref, Gen, Es, Testa1)
       ;
      check_definit(p_pron, RefList, F,  R, Tab_ref, Gen, Es, Testa1)
      ),
       (Es=Est1,Es2=Est2;Es=Est2,Es2=Est1),
%       nonfactive, null, background, risultato, subjective
       (
       nonvar(Gen),
       FPrec is NFrase - 1,
       (stato(FPrec,continua),
        principale(ref_ex(_,Testa,_,P,G,N,C,F1/R1))
         ;
        stato(FPrec,retaining),
        proposto(ref_ex(_,Testa,_,P,G,N,C,F1/R1))
       ),
       Gen=G
        ; 
       nonvar(Gen),
       fact(_,name, [Testa, Id], 1, Tem, Lo),
       check_gender(Gen, Id)
       ),
       on(ref_ex(Es2,Testa2,Tab_ref1,Pers1,Gen1,Num1,Cat1,F2/R2)/_,RefList),
       Testa2\=Testa1,
       Ref1 = ref_ex(Es2,Testa2,Tab_ref1,Pers1,Gen1,Num1,Cat1,F2/R2),
      (Tab_ref1\=[+ ref, + def, nil, nil, + pro, - ana, + class],
       try_agreement(NFrase,  Ref1/Px, [prin, sec, prop, altri],  Testa1Y)
       ;
       Tab_ref1=[+ ref, + def, nil, nil, + pro, - ana, + class],
       Testa1Y=indefinite
       ;
       referente(SnX,[],Idx,Testa1Y,Num1,Card1),
       fact(_,name, [Testa1Y, Idx], 1, Tem, Lo),
       check_gender(Gen1, Idx)
       ),
      append([est(Es,Testa-sc),est(Es2,Testa1Y-sc)],RefList,L3),
      modifica_testa1(L3,ListOut)
      ;
       risolvi_due(NFrase,RefList,Est1,Est2,ListOut)
      ),!.


risolvi1(NFrase,RefList,[esterno(Est1),esterno(Est2)],ListOut) :-
                risolvi_uno(NFrase,RefList,Est2,ListOut), !.

risolvi1(NFrase,RefList,[esterno(Est1),esterno(Est2)],ListOut) :-
                risolvi_uno(NFrase,RefList,Est1,ListOut), !.

/* stato continua: un nominale definito e un pronome deittici anche lui */
risolvi1(NFrase,RefList,[esterno(Est)],ListOut)  
         :-
          N1 is NFrase - 1,
          N1 \= 0,
          principale(X), X \= nil,
          RefList=[ref_ex(Ind,Testa,Tab_ref,_,_,_,_,F/R)/_|Altri],
          Tab_ref = [+ref,Def,nil,_,+pro,-ana,+me] ,
          nodo(N)::indice::Ind,
          nodo(N)::pred::Pred,Pred=lui,
          nodo(N2)::sogg/Ruolo::nodo(N),
          nodo(N2)::adjs::adj/focal::pred::Foc,Foc=anche,
          risolvi_uno_deitt(NFrase,RefList,Est,ListOut),!.

risolvi1(NFrase,RefList,[esterno(Est)],ListOut)  
      :-
       N1 is NFrase - 1,
       N1 \= 0,
      (principale(X), 
         X \= nil
       ;
       proposto(X), X \=nil),
      (
      check_definit(deit,RefList, F,  R, Tab_ref, Gen, Es, Testa1),
          risolvi_due_deit(NFrase,RefList,Ind,Est,ListOut)
      ;
      check_definit(n_subs,RefList, F,  R, Tab_ref, Gen, Es, Testa1),
          F\=sogg_foc,                      
          risolvi_uno_deit(NFrase,RefList,DumNum,Est,ListOut)
      ;
      on(ref_ex(Est,Testa1,Tab_ref1,Pers1,Gen1,Num1,Cat1,F1/R1)/_,RefList),
          antecedent_deictic_predication(RefList,Est,R1),
          check_definit(deit,RefList, F,  R, Tab_ref, Gen, Es, Testa1),
          risolvi_uno_deitt(NFrase,RefList,Est,ListOut)
        ), !.

risolvi1(N,RefList,[esterno(Est)],ListOut)  
      :-
     1<N,
     N1 is N - 1,
     N1 \= 0,
     stato(N1, Stato),
     (Stato=continua ; Stato = cont_analyze ; Stato = retaining),
     principale(X), X \= nil,
     secondario(Y), Y \= nil,
     check_definit(n_com, RefList, F, R, Tab, Gen, Es, Testa1),
     risolvi_due_bis(N,RefList,Es,Est,ListOut),!.

/*  stato cambia: un nominale definito e un pronome */
risolvi1(N,RefList,[esterno(Est)],ListOut)  
     :-
     1<N,
   N1 is N - 1,
   N1 \= 0,
   stato(N1,Stato),
   (Stato=cambia ; Stato = retaining),
   proposto(X), X \= nil,
   altri(Y,N1),
   RefList=[ref_ex(Est,Testa,Tab_ref,Pers,Gen,Num,Cat,sogg/R)/_|Rest],
   check_definit(n_com, Rest, F, R1, Tab, Gen, Es, Testa1),
   risolvi_due_tris(N,N1,RefList,Testa1,ref_ex(Est,Testa,Tab_ref,Pers,Gen,Num,Cat,sogg/R),Es,Est,ListOut),!.

risolvi1(NFrase,RefList,[esterno(Est)],ListOut)  
     :-
    RefList=[ref_ex(_,TestaX,_,_,_,_,_,_)/_|_],
     (
      NoFr is NFrase - 1,
      NoFr \= 0,
     fetch_sc(NFrase, TestaX, Factive, Change, Rel, VerbCat, DiscDom, Testa), Testa\=pPro,
     (
      check_definit(short_ana, RefList, ogg, R, Tab_ref, Gen, Es, Testa1)
       ;
      check_definit(clit,RefList, F,  R, Tab_ref, Gen, Es, Testa1)
       ;
      check_definit(p_pron, RefList, sogg,  R, Tab_ref, Gen, Es, Testa1)
      ),
       (
       nonvar(Gen),
       (
      % stato(NoFr,continua),
        principale(ref_ex(_,Testa,_,P,G,N,C,F1/R1))
         ;
        stato(FPrec,retaining),
        proposto(ref_ex(_,Testa,_,P,G,N,C,F1/R1))
       ),
       Gen=G,
       append([est(Est,Testa-sc)],RefList,L3),
       modifica_testa1(L3,ListOut)
        ; 
       nonvar(Gen),
       atomic(Testa),
       fact(_,name, [Testa, Id], 1, Tem, Lo),
       check_gender(Gen, Id),
       append([est(Est,Testa-sc)],RefList,L3),
       modifica_testa1(L3,ListOut)
        ; 
       nonvar(Gen),
       is_list(Testa),
       on(Test,Testa),
       fact(_,name, [Test, Id], 1, Tem, Lo),
       check_gender(Gen, Id),
       append([est(Est,Test-sc)],RefList,L3),
       modifica_testa1(L3,ListOut)
       ;
       (Gen=nil;var(Gen)),
        (Testa1=it;Testa1=pro),
       principale(ref_ex(_,Testa2,_,P,G,N,C,F1/R1)), 
       Test=indefinite,
       check_itpleonastic(RefList, Testa1,F,R),
       assertz(risolto(NFrase, Est, Testa1, indefinite)),
       elimina(ref_ex(Est,_,_,Pp,Gp,Np,Cp,F/R)/Px, RefList, L1),
       append([ref_ex(Est,Test,_,Pp,Gp,Np,Cp,F/R)/Px], L1, L2)
        ;
       (nonvar(Gen), Gen\=G, Gen\=nil,
        var(L2), RefL=L1, Test1=Test
       ;
        nonvar(L2), RefL=L2, Test1=Test
        ;
       nonvar(Gen), Gen=G, Test1=Testa, RefL=RefList),
       append([est(Est,Test1-sc)],RefL,L3),
       modifica_testa1(L3,ListOut))
      ;
     risolvi_uno(NFrase,RefList,Est,ListOut)       
      ),
     !.

risolvi1(NFrase,RefList,[esterno(Est)],ListOut) :-
                risolvi_uno(NFrase,RefList,Est,ListOut), !.

risolvi1(NFrase,RefList,[esterno(Est)|Rest],ListOuts) :-
                Rest\=[],
                risolvi1(NFrase,RefList,[esterno(Est)],Out),
                remove(ref_ex(Est,Test,_,Pp,Gp,Np,Cp,F/R)/Px, RefList,RefRest),
                risolvi1(NFrase,RefRest,Rest,Lists),
%                append([ref_ex(Est,Test,_,Pp,Gp,Np,Cp,F/R)/Px],ListOut,Lists),
                append(Out,Lists,ListOu),
                sort(ListOu,ListOuts),
                !.

risolvi1(NFrase,RefList,[esterno(Est)|Rest],ListOut) :-
                risolvi_uno(NFrase,RefList,Est,ListOut), 
                !.

check_gender(mas, Id) :-
       (gr(english),
        (fact(_,inst_of,[ind:Id,class:man],1,Temp1,Loc1)
         ;
         fact(_,isa,[ind:Id,class:man],1,Temp2,Loc2))
       ;
       gr(italiano),
       (fact(_,inst_of,[ind:Id,class:uomo],1,Temp1,Loc1)
        ;
        fact(_,isa,[ind:Id,class:uomo],1,Temp2,Loc2))
       ).

check_gender(fem, Id) :-
       (gr(english),
        (fact(_,inst_of,[ind:Id,class:woman],1,Temp1,Loc1)
        ;
        fact(_,isa,[ind:Id,class:woman],1,Temp2,Loc2))
       ;
       gr(italiano),
       (fact(_,inst_of,[ind:Id,class:donna],1,Temp1,Loc1)
        ;
        fact(_,isa,[ind:Id,class:donna],1,Temp2,Loc2))
       ).

fetch_sc(NFrase, TestaX, Factive, Change, Rel, VerbCat, DiscDom, Test) 
      :-
      NoFr is NFrase - 1,
      NoFr \= 0,
      once(info(
      NoFr, Node, _, _, _,_, _,
      _, _, _, _, DiscDom, Subject)),
     simplify_domain(MainRel,DiscDom, SimplDiscDom),
     find_subject(SimplDiscDom, NoFr, Subject, Point), 
        Point\=narrator,
        Point\=legislator,
        Point\=T-sc, 
        Test=Point,
      search_dmod(Test,Id).

search_dmod(Testa,Id) :-
        atomic(Testa),
        (fact(_,name, [Testa, Id], 1, Temp, Loc);
        fact(_,isa,[ind:Id,class:Testa],1,Temp1,Loc1);
        sit(_,isa,[ind:Id,class:Testa],1,Temp1,Loc1);
        fact(_,role,[Testa,Id,Idx],1,Temp1,Loc1);
        fact(_, isa, [arg:Id, arg:Testa], 1, Temp1,Loc1)).
search_dmod(Testas,Id) :-
        is_list(Testas),
        on(Testa,Testas),
        (fact(_,name, [Testa, Id], 1, Temp, Loc);
        fact(_,isa,[ind:Id,class:Testa],1,Temp1,Loc1);
        sit(_,isa,[ind:Id,class:Testa],1,Temp1,Loc1);
        fact(_,role,[Testa,Id,Idx],1,Temp1,Loc1);
        fact(_, isa, [arg:Id, arg:Testa], 1, Temp1,Loc1)).
        
check_definit(short_ana, RefList, F, R, Tab_ref, Gen, Es, Testa1) :-
      (F=ogg;F=adj),
      RefList=[ref_ex(Es,Testa1,Tab_ref,Pers,Gen,Num,Cat,F1/R)/_|Rest],
       Tab_ref=[+ ref, + def, nil, nil, - pro, + ana, + me, - subj].

check_definit(clit,RefList, F,  R, Tab_ref, Gen, Es, Testa1) :-
      RefList=[ref_ex(Es,Testa1,Tab_ref,Pers,Gen,Num,Cat,F/R)/_|Rest],
       Tab_ref=[+ ref, + def, nil, nil, + pro, + ana, + me].

check_definit(p_pron, RefList, F,  R, Tab_ref, Gen, Es, Testa1) :-
      RefList=[ref_ex(Es,Testa1,Tab_ref,Pers,Gen,Num,Cat,F/R)/_|Rest],
       Tab_ref=[+ ref, + def, nil, nil, + pro, - ana, + me].

check_definit(clit,RefList, F,  R, Tab_ref, Gen, Es, Testa1) :-
      RefList=[_,ref_ex(Es,Testa1,Tab_ref,Pers,Gen,Num,Cat,F/R)/_|Rest],
       Tab_ref=[+ ref, + def, nil, nil, + pro, + ana, + me].

check_definit(p_pron, RefList, F,  R, Tab_ref, Gen, Es, Testa1) :-
      RefList=[_,ref_ex(Es,Testa1,Tab_ref,Pers,Gen,Num,Cat,F/R)/_|Rest],
       Tab_ref=[+ ref, + def, nil, nil, + pro, - ana, + me].

check_definit(n_com,RefList, F,  R, Tab_ref, Gen, Es, Testa1) :-
      RefList=[_, ref_ex(Es,Testa1,Tab_ref,Pers,Gen,Num,Cat,F/R)/_|Rest],
       Tab_ref = [+ref,+def,nil,_,-pro,-ana,+class] .

check_definit(deit,RefList, F,  R, Tab_ref, Gen, Es, Testa1) :-
      RefList=[ref_ex(Es,Testa1,Tab_ref,Pers,Gen,Num,Cat,F/R)/_|Rest],
         Tab_ref = [+ref,+def,nil,_,+pro,-ana,+class] .

check_definit(n_subs,RefList, F,  R, Tab_ref, Gen, Es, Testa1) :-
      RefList=[ref_ex(Es,Testa1,Tab_ref,Pers,Gen,Num,Cat,F/R)/_|Rest],
          Tab_ref = [+ref,Def,Part,_,+pro,-ana,+class], 
          nonvar(Part), Part\=nil.

find_antecedents(NumFrase, SnX, SnY, ListaArgs, Types, L4) :-
       ListaArgs=[ref_ex(Sn1,T,Ta,P,G,N,C,F/R)/Px|Args],
      (SnX=Sn1, Sn2=SnY; SnY=Sn1, Sn2=SnX),
       on(ref_ex(Sn2,T1,Ta1,P1,G1,N1,C1,F1/R1)/Py, Args),
       try_agreements(NumFrase,  ref_ex(Sn1,T,Ta,P,G,N,C,F/R)/Px,  ref_ex(Sn2,T1,Ta1,P1,G1,N1,C1,F1/R1)/Py, Types, Testa1, Testa1Y), 
       append([est(Sn1,Testa1),est(Sn2,Testa1Y)],ListaArgs,L3),
       modifica_testa1(L3,L4).

find_antecedent(NumFrase, SnX, Num, ListaArgs, Types, L4) :-
       on(ref_ex(SnX,T,Ta,P,G,_,C,F/R)/Px, ListaArgs),
       try_agreement(NumFrase, ref_ex(SnX,T,Ta,P,G,_,C,F/R)/Px, Types, Testa1), 
       append([est(SnX,Testa1)],ListaArgs,L3),
       modifica_testa1(L3,L4).

find_anteced(NumFrase, SnX, ListaArgs, Types, L4) :-
       on(ref_ex(SnX,T,Ta,P,G,N,C,F/R)/Px, ListaArgs),
       try_agreement(NumFrase, ref_ex(SnX,T,Ta,P,G,N,C,F/R)/Px, Types, Testa1), 
       argsdisj(ListaArgs, Testa1),
       append([est(SnX,Testa1)],ListaArgs,L3),
       modifica_testa1(L3,L4).

find_anteced(NumFrase, SnX, ListaArgs, Types, L4) :-
       on(ref_ex(SnX,T,Ta,P,G,N,C,F/R)/Px, ListaArgs),
       on(+pro, Ta), on(+me, Ta),
       append([est(SnX,indefinite)],ListaArgs,L3),
       modifica_testa1(L3,L4),!.

argsdisj([],T1):-!.
argsdisj([ref_ex(SnX,T,Ta,P,G,N,C,F/R)/Px|ListaArgs],T1):-
       T\=T1,
       argsdisj(ListaArgs,T1),!.
       
try_agreement(NumFrase,  Ref1/Px, [],  Testa1):- Testa1\=[],!.

try_agreement(NumFrase,  Ref1/Px, [Type | OtherType],  Testa1) :- 
       (try_agree(NumFrase, Ref1/Px, Type, Testa1)
        ;
        try_agreement(NumFrase, Ref1/Px, OtherType, Testa1)
       ).


try_agree(NumFrase, Ref1/Px, Type, Testa1) :-
       (Type=sec, Funct=secondario
        ;
        Type=prin, Funct=principale
        ;
        Type=prop1, Funct=proposto
        ;
        Type=prop, Funct=proposto
        ),
       Top=..[Funct,X], 
       Top, X\=nil,
       matcha(NumFrase, Ref1, Funct, Testa1),
       Testa1\=indefinite.
     
try_agree(NumFrase, Ref1/Px, altri, Testa1) :-
       FrasePrec is NumFrase - 1,
       altri(X, FrasePrec), X\=nil,
       matcha(NumFrase, Ref1, altri, FrasePrec, Testa1),
        Testa1\=indefinite.

try_agree(NumFrase, Ref1/Px, prop, Testa1) :-
       proposto(X), X\=nil,
       matcha(NumFrase, Ref1, proposto, Testa1),
       Testa1\=indefinite,
       !.

try_agreements(NumFrase, Ref1/Px, Ref2/Py, [], Testa1, Testa1Y) :- 
       Testa1\=[], Testa1Y\=[],!.

try_agreements(NumFrase, Ref1/Px, Ref2/Py, [Type | OtherType], Testa1, Testa1Y) 
       :- 
       (try_agrees(NumFrase, Ref1/Px, Ref2/Py, [Type], Testa1, Testa1Y)
        ;
        try_agreements(NumFrase, Ref1/Px, Ref2/Py, OtherType, Testa1, Testa1Y)
       ).

try_agrees(NumFrase,  Ref1/Px,  Ref2/Py, [prin-altri], Testa1, Testa1Y) :-
       principale(X), X\=nil,
       FrasePrec is NumFrase - 1,
       altri(Y, FrasePrec), Y\=[],
       matcha(NumFrase, Ref1, principale, Testa1),
       matcha(NumFrase, Ref2, altri, FrasePrec, Testa1Y),
       Testa1\=indefinite,Testa1Y\=indefinite,Testa1\=Testa1Y,Testa1\=[].

try_agrees(NumFrase,  Ref1/Px, Ref2/Py, [altri-prin], Testa1, Testa1Y) :-
       principale(X), X\=nil,
       FrasePrec is NumFrase - 1,
       altri(Y, FrasePrec), Y\=[],
       matcha(NumFrase, Ref2, principale, Testa1Y),
       matcha(NumFrase, Ref1, altri, FrasePrec, Testa1),
       Testa1\=indefinite,Testa1Y\=indefinite,Testa1\=Testa1Y,Testa1\=[].


try_agrees(NumFrase, Ref1/Px, Ref2/Py, [prin-sec], Testa1, Testa1Y) :-
       principale(X), X\=nil,
       secondario(Y), Y\=nil,
       matcha(NumFrase, Ref1, principale, Testa1),
       matcha(NumFrase, Ref2, secondario, Testa1Y),
       (Testa1Y=indefinite, 
        arg(3, Ref2, Tab),
        Tab=[+ ref, + def, nil, nil, + pro, - ana, + class]
        ;
        Testa1\=indefinite,Testa1Y\=indefinite,Testa1\=Testa1Y,Testa1\=[]).

try_agrees(NumFrase, Ref1/Px, Ref2/Py, [prop-sec], Testa1, Testa1Y) :-
       proposto(X), X\=nil,
       secondario(Y), Y\=nil,
       matcha(NumFrase, Ref1, proposto, Testa1),
       matcha(NumFrase, Ref2, secondario, Testa1Y),
       Testa1\=indefinite,Testa1Y\=indefinite,
       arg(8,Ref2,F/R),
       (F/R=sub/compar
        ;
        Testa1\=Testa1Y),
       Testa1\=[].

try_agrees(NumFrase, Ref1/Px, Ref2/Py, [sec-prin], Testa1, Testa1Y) :-
       principale(X), X\=nil,
       secondario(Y), Y\=nil,
       matcha(NumFrase, Ref2, principale, Testa1Y),
       matcha(NumFrase, Ref1,secondario,Testa1),
       Testa1\=indefinite,Testa1Y\=indefinite,Testa1\=Testa1Y,Testa1\=[].

try_agrees(NumFrase, Ref1/Px, Ref2/Py, [prin-prop], Testa1, Testa1Y) :-
       principale(X), X\=nil,
       proposto(Y), Y\=nil,
       matcha(NumFrase, Ref1, principale, Testa1),
       matcha(NumFrase, Ref2, proposto, Testa1Y),
       Testa1\=indefinite,Testa1Y\=indefinite,Testa1\=Testa1Y,Testa1\=[].

try_agrees(NumFrase, Ref1/Px, Ref2/Py, [prop-prin], Testa1, Testa1Y) :-
       principale(X), X\=nil,
       proposto(Y), Y\=nil,
       matcha(NumFrase, Ref2, principale, Testa1Y),
       matcha(NumFrase, Ref1, proposto, Testa1),
       Testa1\=indefinite,Testa1Y\=indefinite,Testa1\=Testa1Y,Testa1\=[].

try_agrees(NumFrase, Ref1/Px, Ref2/Py, [prop-prop], Testa1, Testa1Y) :-
       proposto(X), X\=nil,
       matcha(NumFrase, Ref2, proposto, Testa1),
       matcha(NumFrase, Ref1, proposto, Testa1Y),
       Testa1\=indefinite,Testa1Y\=indefinite,Testa1\=Testa1Y,Testa1\=[].

try_agrees(NumFrase, Ref1/Px, Ref2/Py, [prop-altri], Testa1, Testa1Y) :-
       FrasePrec is NumFrase - 1,
       altri(X, FrasePrec), X\=[],
       proposto(Y), Y\=nil,
       matcha(NumFrase, Ref1, proposto, Testa1),
       matcha(NumFrase, Ref2, altri, FrasePrec, Testa1Y),
       Testa1\=indefinite,Testa1Y\=indefinite,Testa1\=[].

try_agrees(NumFrase, Ref1/Px, Ref2/Py, [prop-altri], Testa1, Testa1Y) :-
       FrasePrec is NumFrase - 1,
       altri(X, FrasePrec), X\=[],
       proposto(Y), Y\=nil,
       matcha(NumFrase, Ref2, proposto, Testa1),
       matcha(NumFrase, Ref1, altri, FrasePrec, Testa1Y),
       Testa1\=indefinite,Testa1Y\=indefinite,Testa1\=[].

try_agrees(NumFrase, Ref1/Px, Ref2/Py, [altri-prop], Testa1, Testa1Y) :-
       FrasePrec is NumFrase - 1,
       altri(X, FrasePrec), X\=[],
       proposto(Y), Y\=nil,
       matcha(NumFrase, Ref1, proposto, Testa1Y),
       matcha(NumFrase, Ref2, altri, FrasePrec, Testa1),
       Testa1\=indefinite,Testa1Y\=indefinite,Testa1\=[].

try_agrees(NumFrase, Ref1/Px, Ref2/Py, [altri-prop], Testa1, Testa1Y) :-
       FrasePrec is NumFrase - 1,
       altri(X, FrasePrec), X\=[],
       proposto(Y), Y\=nil,
       matcha(NumFrase, Ref2, proposto, Testa1Y),
       matcha(NumFrase, Ref1, altri, FrasePrec, Testa1),
       Testa1\=indefinite,Testa1Y\=indefinite,Testa1\=[].

try_agrees(NumFrase, Ref1/Px, Ref2/Py, [altri-altri], Testa1, Testa1Y) :-
       FrasePrec is NumFrase - 1,
       altri(X, FrasePrec), X\=[],
       matcha(NumFrase, Ref1, altri, FrasePrec, Testa1),
       altri(Y, FrasePrec), Y\=[],
       X\=Y,
       matcha(NumFrase, Ref2, altri, FrasePrec, Testa1Y),
       Testa1\=indefinite,Testa1Y\=indefinite,Testa1\=Testa1Y,Testa1\=[].

/* ex. PAR1.ROD */


/* Risolve gli esterni, cioe' quegli elementi che hanno un antecedente
   al di fuori della frase in cui si trovano. Tiene conto dello stato
   della frase precedente */

back_state(NumFrase,FrasePrec,Stati) :-
       FrasePrec is NumFrase - 1,
       stato(FrasePrec,Stato),
       on(Stato, Stati), !.

back_state(NumFrase,FrasePrec,Stato) :-
       FrasePrec is NumFrase - 1,
       stato(FrasePrec,Stato), !.

/* due argomenti da risolvere nello stato di  shifting */
risolvi_due(NumFrase,ListaArgs,SnX,SnY,L4) :-
       back_state(NumFrase,FrasePrec,shifting),
       find_antecedents(NumFrase, SnX, SnY, ListaArgs, [prin-sec, sec-prin], L4),
       !.

/* 2  due argomenti da risolvere nello stato di  retaining */
risolvi_due(NumFrase,ListaArgs,SnX,SnY,L4) :-
       back_state(NumFrase,FrasePrec,[cambia,retaining]),
       find_antecedents(NumFrase, SnX, SnY, ListaArgs, [prin-prop, prin-sec, altri-prin, sec-prin, prop-prin, prop-sec, prop-altri, prop-prop, altri-altri], L4),
       !.

/* stato cambia : due pronomi da risolvere - uno dei pronomi e' un tema_bound ed e' il controllore di un ncomp - il match viene fatto con il pred del ncomp attraverso is_a */
risolvi_due(NumFrase,ListaArgomenti,SnX,SnY,L4) :-
       back_state(NumFrase,FrasePrec,cambia),
       on(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)/Px,ListaArgomenti),
       on(ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CatY,FY/Role)/Py,
              ListaArgomenti),
       (Role=theme_bound;Role=tema_bound),
       nodo(NN)::sogg/_::controllore::SnY,
       nodo(NN)::pred::Pred,
       Ref1=ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R),
       infer_match_global(A-B, Pred, Ref1, R, NumFrase, FrasePrec, Testa1Y, Testa1),
       append([est(SnX,Testa1),est(SnY,Testa1Y)],ListaArgomenti,L3),
       modifica_testa1(L3,L4),
       !.
/* stato cambia: c' un riflessivo logoforico, si matcha il primo
pronome con gli altri, e il riflessivo con il secondario */

risolvi_due(NumFrase,ListaArgomenti,SnX,SnY,L4) :-
       back_state(NumFrase,FrasePrec,cambia),
       on(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)/Px,ListaArgomenti),
       on(ref_ex(SnY,TestaY,[+ref, +def, nil, nil, -pro, +ana, +me, -subj],PersY,GenY,NumY,CatY,FY/RY)/Py,ListaArgomenti),
       matcha2(NumFrase,ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R),
               altri,FrasePrec,Testa1),
       matcha2(NumFrase,ref_ex(SnY,TestaY,[+ref, +def, nil, nil, -pro, +ana, +me, -subj],PersY,GenY,NumY,CatY,FY/RY), secondario,Testa1Y),
       Testa1 \= Testa1Y,
       append([est(SnX,Testa1),est(SnY,Testa1Y)],ListaArgomenti,L3),
       modifica_testa1(L3,L4),
       !.

/* 4  stato cambia : due pronomi da risolvere, regola di default */


risolvi_due(NumFrase,ListaArgs,SnX,SnY,L4) :-
       back_state(NumFrase,FrasePrec,[cambia, retaining, resume]),
       find_antecedents(NumFrase, SnX, SnY, ListaArgs, [prop-altri, prop-sec, altri-prop, altri-altri], L4),
%      TabY=[+ ref, + def, - part, nil, + pro, - ana, + class]
       !.

/* 5  due argomenti da risolvere nello stato di continua   il secondario e' diverso da nil  */
risolvi_due(NumFrase,ListaArgs,SnX,SnY,L4) :-  
       back_state(NumFrase,FrasePrec,[continua, cont_analyze, retaining, resume]),
      (secondario(Y), Y\=nil),
       on(ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CatY,FY/RY)/Py,ListaArgs),
       ((RY=tema_bound;RY=theme_bound),
        nodo(_)::_/prop::pred::Pred,
        nodo(_)::_/prop::cat::Cc, 
        nogen_member(attivita,Cc),
        fact(_, isa, [compito, Id], 1, _, _),
        fact(_, role, [Role, Id1, Id], 1, _, _),
        fact(_, name, [TestaX, Id1], 1, _, _),
        secondario(ref_ex(_,TestaX,_,_,_,_,_,_/_)),
       find_antecedents(NumFrase, SnX, SnY, ListaArgs, [prin-sec], L4)
       ;
%        (Px =< Py,
       find_antecedents(NumFrase, SnX, SnY, ListaArgs, [prin-sec, sec-prin], L4)
       ),
       !.

/* 6  due argomenti da risolvere nello stato di continua  Il secondo deve essere preso da altri essendo secondario = nil  */
risolvi_due(NumFrase,ListaArgs,SnX,SnY,L4) :-
       back_state(NumFrase,FrasePrec,[continua, cont_analyze, resume]),
       find_antecedents(NumFrase, SnX, SnY, ListaArgs, [prin-sec, sec-prin, prin-altri, altri-prin, prin-prop, prop-prin], L4),
       !.

/*
risolvi_due(NumFrase,ListaArgs,SnX,SnY,L4) :-
       back_state(NumFrase,FrasePrec,[continua, cont_analyze, resume]),
       find_antecedents(NumFrase, SnX, SnY, ListaArgs, [prin-altri], L4),
       !.
*/

/* is-a */
risolvi_due_bis(NumFrase,ListaArgomenti,SnX,SnY,L4) :-
       back_state(NumFrase,FrasePrec,[continua, cont_analyze]),
       on(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)/Px,ListaArgomenti),
       on(ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CatY,FY/RY)/Py,
              ListaArgomenti),
       Ref1=ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R),
       infer_match_global(prin-sec, Testa, R, Ref1, NumFrase, FrasePrec, Testa1Y, Testa1),
       assert(esterno(SnX)),
       append([est(SnX,Testa1),est(SnY,Testa1Y)],ListaArgomenti,L3),
       modifica_testa1(L3,L4),
       !.

risolvi_due_bis(NumFrase,ListaArgomenti,SnX,SnY,L4) :-
       back_state(NumFrase,FrasePrec,[continua]),
       on(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)/Px,ListaArgomenti),
       on(ref_ex(SnY,TestaY,TabY,PersY,GenY,plur,CatY,FY/RY)/Py,
              ListaArgomenti),
       fact(_,relat,[Testa,Idx,Idy],1,Temp1,Loc1),
       infer_split_ante(Testa1, [Id, Id1]),
       fact(_,name, [Testa2, Id2], 1, Temp, Loc),
       noton(Testa2,Testa1),
       assert(esterno(SnX)),
       assert(esterno(SnY)),
       append([est(SnX,Testa2),est(SnY,Testa1)],ListaArgomenti,L3),
       modifica_testa1(L3,L4),
        !.

risolvi_due_bis(NumFrase,ListaArgomenti,SnX,SnY,L4) :-
       back_state(NumFrase,FrasePrec,[continua]),
       on(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)/Px,ListaArgomenti),
       on(ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CatY,FY/RY)/Py,
              ListaArgomenti),
        fact(_,role,[Testa,Idx,Id],1,Temp1,Loc1),
       principale(ref_ex(_,Testa1,_,_,_,_,_,_)),
        fact(_,name, [Testa1, Id], 1, Temp, Loc),
        fact(_,name, [Testa2, Id2], 1, Temp, Loc),
       secondario(ref_ex(_,Testa2,_,_,_,_,_,_)),
        Testa2 \= Testa1,
       topic(_,secondary,Id2),
       check_gender(GenY, Id2),
       assert(esterno(SnX)),
       append([est(SnX,Testa1),est(SnY,Testa2)],ListaArgomenti,L3),
       modifica_testa1(L3,L4),
        !.
risolvi_due_bis(NumFrase,ListaArgomenti,SnX,SnY,L4) :-
       back_state(NumFrase,FrasePrec,[continua]),
       on(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)/Px,ListaArgomenti),
       on(ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CatY,FY/RY)/Py,
              ListaArgomenti),
        fact(_,role,[Testa,Id,Idx],1,Temp1,Loc1),
       principale(ref_ex(_,Testa1,_,_,_,_,_,_)),
        fact(_,name, [Testa2, Id2], 1, Temp, Loc),
        Testa2 \= Testa1,
       topic(_,secondary,Id2),
       check_gender(Gen, Id2),
       secondario(ref_ex(_,Testa2,_,_,_,_,_,_)),
       assert(esterno(SnX)),
       append([est(SnX,Testa2),est(SnY,Testa1)],ListaArgomenti,L3),
       modifica_testa1(L3,L4),
        !.

risolvi_due_bis(NumFrase,ListaArgomenti,SnX,SnY,L4) :-
       back_state(NumFrase,FrasePrec,[continua, cont_analyze, retaining]),
       on(ref_ex(SnX,suocero,Tab,Pers,Gen,Num,Cat,F/R)/Px,ListaArgomenti),
       on(ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CatY,FY/RY)/Py,
              ListaArgomenti),
       check_disjoint(FrasePrec,suocero,Gen,[main-sec, sec-main],Test,Testa2),
       assert(esterno(SnX)),
       append([est(SnX,Test),est(SnY,Testa2)],ListaArgomenti,L3),
       modifica_testa1(L3,L4),
        !.

risolvi_due_bis(NumFrase,ListaArgomenti,SnX,SnY,L4) :-
       back_state(NumFrase,FrasePrec,[retaining]),
       on(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)/Px,ListaArgomenti),
       on(ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CatY,FY/RY)/Py,
              ListaArgomenti),
       check_disjoint(FrasePrec, Testa, Gen, [prop-sec],Test, Testa2),
       assert(esterno(SnX)),
       append([est(SnX,Test),est(SnY,Testa2)],ListaArgomenti,L3),
       modifica_testa1(L3,L4),
        !.

risolvi_due_deit(NumFrase,ListaArgomenti,SnX,SnY,L4) :-
       FrasePrec is NumFrase - 1,
       stato(FrasePrec,Stato),
       on(ref_ex(SnX,Testa,Tab,Pers,Gen,_,Cat,F/R)/Px,ListaArgomenti),
       on(ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CatY,FY/RY)/Py,
              ListaArgomenti),
       principale(ref_ex(_,Testa1,_,_,_,_,_,_)),
       matcha(NumFrase,ref_ex(SnX,Testa,Tab,Pers,Gen,_,CatX,FX/RX),
              principale,Testa1Y),
       proposto(ref_ex(_,Testa1,_,_,_,_,_,_)),
       is_a(Testa1,TestaY),
       matcha(NumFrase,ref_ex(SnY,TestaY,TabY,PersY,GenY,NumY,CatY,FY/RY),
                 secondario,Testa1),
        assert(esterno(SnX)),
        append([est(SnX,Testa1),est(SnY,Testa1Y)],ListaArgomenti,L3),
        modifica_testa1(L3,L4),
        !. 

/* stato cambia : un nominale definito e un pronome da risolvere che e' un tema_bound ed e'il controllore di un ncomp - il match viene fatto con il pred del ncomp attraverso is_a  il Pred  il predicato del sn predicativo in cui viene legato il pronome poi tenta l'inferenza tra il nominale definito e altri tenta l'inferenza tra il nominale legato e altri */
risolvi_due_tris(NumFrase,N1,ListaArgomenti,Testa,Ref1,SnX,SnY,L4) :-
       nodo(NN)::sogg/_::controllore::SnY,
       nodo(NN)::pred::Pred,  
       infer_global(Pred, Testa, N1, SnX), 
       append([est(SnX,Testa1),est(SnY,Testa1Y)],ListaArgomenti,L3),
       modifica_testa1(L3,L4),
       !.

/* snx e' il nominale definito sny e' il pronome  si cerca il predicato del sn predicativo in cui viene legato il pronome come in il loro nome era */
risolvi_due_tris(NumFrase,N1,ListaArgomenti,Testa,Ref1,SnX,SnY,L4) :-
       nodo(NN)::sogg/_::nodo(N1),
       nodo(N1)::pred::nome,  
       matcha(NumFrase,Ref1,proposto,Testa1),
       assert(esterno(SnY)),
       append([est(SnY,Testa1)],ListaArgomenti,L3),
       modifica_testa1(L3,L4),
       !.

/* snx e' il nominale definito sny e' il pronome  si tenta l'inferenza con il proposto poi tenta l'inferenza tra il nominale definito e altri poi tenta l'inferenza tra il nominale legato e altri */
risolvi_due_tris(NumFrase,N1,ListaArgomenti,Testa,Ref1,SnX,SnY,L4) :-
       nodo(NN)::sogg/_::controllore::SnX,
       nodo(NN)::pred::Pred, 
       infer_global(Pred, Testa, N1, SnX), 
       append([est(SnX,Testa1),est(SnY,Testa1Y)],ListaArgomenti,L3),
       modifica_testa1(L3,L4),
       !.

infer_global(Pred, Testa, N1, SnX) :-
       (proposto(ref_ex(_,Testa1Y,_,_,_,_,_,_)), 
        is_a(Testa1Y,Pred),   
       altri(ref_ex(_,Testa1,_,_,_,_,_,_),N1), 
         is_a(Testa1,Testa), 
        Testa1 \= Testa1Y;
        altri(ref_ex(_,Testa1Y,_,_,_,_,_,_),N1), 
        is_a(Testa1Y,Pred), 
        proposto(ref_ex(_,Testa1,_,_,_,_,_,_)),
         is_a(Testa1,Testa),  
        Testa1 \= Testa1Y),
       assert(esterno(SnX)).

/*  RISOLVI   UN    ESTERNO
con un pronome deittico    */ 
risolvi_uno_deit(NumFrase,ListaArgs,Gen,SnX,L4) :-
       back_state(NumFrase,FrasePrec,[continua, cont_analyze]),
       Ant=[prin,sec,altri],
       find_antecedent(NumFrase, SnX, Gen, ListaArgs, Ant, L4), 
       !.


risolvi_uno_deit(NumFrase,ListaArgs,Gen,SnX,L4) :-
       FrasePrec is NumFrase - 1,
       stato(FrasePrec,Stato),
       (Stato = cambia, Ant=[prop]; Stato=retaining, Ant=[prop1,sec,altri,prin]),
       find_antecedent(NumFrase, SnX, Gen, ListaArgs, Ant, L4), 
       !.
risolvi_uno_deit(NumFrase,ListaArgs,Gen,SnX,L4) :-
       FrasePrec is NumFrase - 1,
       stato(FrasePrec,Stato),
       (Stato = shifting, Ant=[sec,altri]; Stato = continua, Ant=[sec,altri,prin]),
       find_antecedent(NumFrase, SnX, Gen, ListaArgs, Ant, L4), 
       !.

risolvi_uno_deit(NumFrase,ListaArgs,Gen,SnX,L4) :-
       back_state(NumFrase,FrasePrec,[resume, cont_analyze]),
       find_antecedent(NumFrase, SnX, Gen, ListaArgs, [prin], L4), 
       !.

risolvi_uno_deic(NumFrase,ListaArgomenti,SnX,L4) :-  
       back_state(NumFrase,FrasePrec,[resume, cambia]),
       on(ref_ex(SnX,Testa,Tab,Pers,Gen,_,Cat,F/R)/Px,ListaArgomenti),
       matcha(NumFrase,
         ref_ex(SnX,Testa,Tab,_,Gen,_,Cat,F/R),proposto,Testa1) ,
       append([deic(SnX,Testa1)],ListaArgomenti,L3),
       modifica_testa_deic(L3,L4),
       !.

risolvi_uno_deic(NumFrase,ListaArgomenti,SnX,L4) :-  
       back_state(NumFrase,FrasePrec,[shifting, continua]),
       on(ref_ex(SnX,Testa,Tab,Pers,Gen,_,Cat,F/R)/Px,ListaArgomenti),
       matcha(NumFrase,ref_ex(SnX,Testa,Tab,_,Gen,_,Cat,F/R),principale,Testa1),
       append([deic(SnX,Testa1)],ListaArgomenti,L3),
       modifica_testa_deic(L3,L4),
       !.

risolvi_uno_deitt(NumFrase,ListaArgs,SnX,L4) :-
       back_state(NumFrase,FrasePrec,[cambia, retaining, continua, cont_analyze]),
       find_anteced(NumFrase, SnX, ListaArgs, [sec, altri, prin], L4), 
       !.

risolvi_uno_deitt(NumFrase,ListaArgs,SnX,L4) :-
       back_state(NumFrase,FrasePrec,shifting),
       find_anteced(NumFrase, SnX, ListaArgs, [sec, altri], L4), 
       !.


/* RISOLVI UNO
si deve risolvere un argomento esterno nello stato
   di continua o retaining o shifting 
si deve risolvere un argomento esterno nello stato di cambiamento
   non ci si riferisce all'argomento principale ma alla
   lista di argomenti della frase precedente 
stato cambia si deve risolvere un pronome con ruolo = tema_bound 
   il pronome controlla un argomento legato */

risolvi_uno(NumFrase,ListaArgs,SnX,L4) :-
       on(ref_ex(SnX, T, Ta, P,G,N,C,F/R)/Px,ListaArgs),
       T=others,
       assert(indefinite(SnX)), 
       append([est(SnX,indefinite)],ListaArgs,L3),
%       append([ref_ex(SnX,T,Ta,P,G,N,C,F/R)/Px],L3,L33),
       modifica_testa1(L3,L4).

risolvi_uno(NumFrase,ListaArgs,SnX,L4) :-
       back_state(NumFrase,FrasePrec,[cambia, retaining]),
       find_anteced(NumFrase, SnX, ListaArgs, [prop, prin, sec, altri], L4), 
       !.

risolvi_uno(NumFrase,ListaArgs,SnX,L4) :-
       back_state(NumFrase,FrasePrec,cambia),
       on(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)/Px,ListaArgs),
       nodo(NN)::sogg/_::controllore::SnX,
       nodo(NN)::pred::Pred,
       ( 
        (proposto(ref_ex(SnX,Testa1,_,_,_,_,_,_))
         ;
         altri(ref_ex(SnX,Testa1,_,_,_,_,_,_),FrasePrec),
         is_a(Testa1,Pred)
         )
        ;
        Num=sing,
        (R=tema_bound;R=theme_bound),
        infer_antecedent(NumFrase, SnX, ListaArgs, ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R), [prop, altri], L4) 
        ;
        Num=plur,
        (R=tema_bound;R=theme_bound),
        infer_antecedent(NumFrase, SnX, ListaArgs, ref_ex(SnX,Testa,Tab,Pers,Gen,_,Cat,F/R), [prop, altri], L4) 
        ;
        Num=plur,
        infer_antecedent(NumFrase, SnX, ListaArgs, ref_ex(SnX,Testa,Tab,Pers,Gen,_,Cat,F/R), [prop, altri], L4) 
       ),      
       !.


risolvi_uno(NumFrase,ListaArgs,SnX,L4) :-
       1<NumFrase,
       back_state(NumFrase,FrasePrec,continua),
       on(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)/Px,ListaArgs),
      (
       (matcha(NumFrase,
         ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R),principale,Testa1),   
          Testa1\=indefinite
          )
         ;
       Num=plur,
       infer_split_ante(Testa1, Ids)
        ;
       Num=sing,
       principale(ref_ex(_,Test,_,P,G,Nu,C,F1/R1)),G\=Gen,
       fact(_,name, [Testa1, Id], 1, Temp, Loc), Testa1\=Test,
       topic(_,secondary,Id)
          ),
       nl,
       (findall(Testa1, on(ref_ex(S,Testa1,Tab1,Pers1,Gen1,Num1,Cat1,F1/R1)/_, ListaArgs), Teste),
        Teste=[],
       append([est(SnX,Testa1)],ListaArgs,L3),
       modifica_testa1(L3,L4)
        ;
        on(ref_ex(S,Testa1,Tab1,Pers1,Gen1,Num1,Cat1,F1/R1)/Punt, ListaArgs),
        100<Punt,
        matcha(NumFrase,
         ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R),secondario,Testa1), 
       append([est(SnX,Testa1)],ListaArgs,L3),
       modifica_testa1(L3,L4)),
       !.

risolvi_uno(NumFrase,ListaArgs,SnX,L4) :-
       1<NumFrase,
       back_state(NumFrase,FrasePrec,resume),
       find_anteced(NumFrase, SnX, ListaArgs, [prop, prin, sec], L4), 
       !.

risolvi_uno(NumFrase,ListaArgs,SnX,L4) :-
       find_anteced(NumFrase, SnX, ListaArgs, [prop, sec, altri, prin], L4), 
       !.

risolvi_uno(NumFrase,ListaArgs,SnX,L4) :-
       recover_ref(SnX, Ref_ex),
       Ref_ex=ref_ex(SnX, T, Ta, P,G,N,C,F/R),
       try_agreement(NumFrase, ref_ex(SnX,T,Ta,P,G,N,C,F/R)/Px, [prop, prin, sec, altri], Testa1), 
       argsdisj(ListaArgs, Testa1),
       append([est(SnX,Testa1)],ListaArgs,L3),
       append([ref_ex(SnX,T,Ta,P,G,N,C,F/R)/15],L3,L33),
       modifica_testa1(L33,L4).

risolvi_uno(NumFrase,ListaArgs,SnX,L4) :-
       on(ref_ex(SnX,Testa,Tab,Pers,Gen,Num,Cat,F/R)/Px,ListaArgs),
       assert(indefinite(SnX)), 
       append([est(SnX,indefinite)],ListaArgs,L3),
       append([ref_ex(SnX,T,Ta,P,G,N,C,F/R)/Px],L3,L33),
       modifica_testa1(L33,L4).

find_relat(SnX/NoFr, Testa, Idx, Temp, Loc):-
   (Testa=fratello;Testa=sorella;Testa=brother;Testa=sister),
   main_or_expect(NoFr, Idj),
   in(_, Idj, Idy),
   (fact(_, Testa, [_:Idy], 1, _, _)
    ;
    fact(_, relat,[Testa,Idy,Idy],1,_, _)),
   in(_, Idx, Idy),
   Idx\=Idj,
   ind(_, Idx),
   fact(_, name, [Test, Idx], 1, _, _), 
   (
    (fact(_, Testa,[nil:Idx],1,_,_)
    ;  
    fact(_, isa,[_:Idx, class:Testa],1,_,_))
    ; 
    Idy\=Idx, 
   asserisci(NoFr,SnX,fact(relat,[Testa,Idx,Idy],1,Temp, Loc)),
   asserisci(NoFr,SnX,fact(Testa,[nil:Idx],1,Temp, Loc))
   ), !.

check_dm_poss(Testa, Idy, Id):-
   nonvar(Idy),
   once(proprieta_poss(Card2, Idy, Pro, Prop, Idz)),
   extract_facts_poss(Testa, Idy, Id, Prop). 

extract_facts_poss(Testa, Idy, Id, Prop):-
   fact(_, poss, [Props, Idy, Id], 1, _, _),
   (list(Props),
     on(Prop, Props)
     ;
     Props=Prop),
   fact(_, isa,[ind:Id,class:Testa],1,_,_),
   !.

extract_facts_poss(Testa, Idy, Id, Prop):-
   fact(_, has, [_:Idy, _:Id], 1, _, _),
   fact(_, isa,[ind:Id,class:Testa],1,_,_),
   !.

/* 2  non fratelli un set di case incluso in un set precedente e si ricava la cardinalita dai possessori */

find_dm_poss(SnX/NoFr,Mods,Testa,F/Role,Idy,Num,Card2,Temp,Loc,Id):-
   nonvar(Idy),
   once(proprieta_poss(Card2, Idy, Pro, Prop, Idz)),
   (
     fact(_, poss, [Prop, Idy, Idd], 1, _, _)
     ->
     fail, !;
     true),
    referente(SnX,Mods,Idx,Testa,Num1,Card3),
    !,
    testcard3(Card3),
    (Num=plur, T=set; T=ind),
    creatert(NoFr,T,Mods,SnX,Testa,Card2,Quant,Num,Id,Temp, Loc),
    asserisci(NoFr, SnX, in(Id,Idx)),
     asserisci(NoFr,SnX,fact(isa,[ind:Id,class:Testa],1,Temp, Loc)),
     individua_controllato(SnX, Id, Temp, Loc),
   !.

/* 3 anche fratelli gia' presenti */

find_dm_poss(SnX/NoFr,Mods,Testa,F/Role,Idy,Num,Card2,Temp,Loc,Id):-
   referente(SnX,Mods,Id,Testa,Num,Card2),
   individua_controllato(SnX, Id, Temp, Loc),
   asserisci(NoFr,SnX,fact(isa,[ind:Id, class:Testa],1,Temp, Loc)),
   !.

find_dm_poss(SnX/NoFr,Mods,Testa,F/Role,Idy,Num,Card2,Temp,Loc,Id):-
   nonvar(Idy),
   once(proprieta_poss(Card2, Idy, Pro, Prop, Idz)),
    (Num=plur, T=set; T=ind),
    creatert(NoFr,T,Mods,SnX,Testa,Card2,Quant,Num,Id,Temp, Loc),
   !.

/* 1 argomenti definiti non fratelli 1 i porcellini possiedono gia' una casa */

oldarg(SnX/NoFr,Testa,Feats,Mods,Id,Temp, Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
   nonvar(Cat), 
   Mods\=[], 
   notmembro(relazionale,Cat), 
   notmembro(relat,Cat),
   define_poss_rel(Mods, SnX, Num, Part, Card0, Idy, Card2),
   (
     check_dm_poss(Testa, Idy, Id)
     ;
    find_dm_poss(SnX/NoFr,Mods,Testa,F/Role,Idy,Num,Card2,Temp,Loc,Id) 
   ),
   class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
   !. 

/* 4 Definito plurale con cardinalit dal referente, incluso in o uguale a un set precedente non fratelli */
oldarg(SnX/NoFr,Testa,Feats,Mods,Id,Temp,Loc):-  
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
   nonvar(Cat),
   nonvar(Num),
   Num=plur,
   Card0=nil, 
   notmembro(relazionale,Cat), 
   notmembro(relat,Cat), 
   trova_card(SnX, Num, Part, _, _, Card),
   referente(SnX,Mods,Idx,Testa,plur,Card1),
   (
   testcard1(Card, Card1),
   creatert(NoFr,set,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
   class_props_in(NoFr, SnX, Cat, Id, fact, isa, Idx, Testa, 1, Temp, Loc)
   ;
   nonvar(Card1), Id=Idx
   ),
   !.

/* 5 */
oldarg(SnX/NoFr,man,Feats,Mods,Idx,Temp, Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
   nodo(N1)::F/Role::indice::SnX,
   nodo(N1)::F/Role::spec::mod::that,
   fact(_,relat,[Prop, Id, Id],1,_,_),  
   trova_card(SnX, Num, Part, _, Card0, Card),
   creatert(NoFr,ind,Mods,SnX,Testa,Card,Quant,Num,Idx,Temp, Loc),
   class_props_in(NoFr, SnX, Cat, Idx, fact, isa, Id, Prop, 1, Temp, Loc),
   !.

/* 6 */
oldarg(SnX/NoFr,corpse,Feats,Mods,Idx,Temp, Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
   nodo(N1)::F/Role::indice::SnX,
   nodo(N1)::F/Role::spec::mod::that,
   trova_card(SnX, Num, Part, _, Card0, Card),
   creatert(NoFr,ind,Mods,SnX,Testa,Card,Quant,Num,Idx,Temp, Loc),
   class_props(NoFr, SnX, Cat, Idx, fact, isa, Testa, 1, Temp, Loc),
   !.

/* 7 Definito plurale non asserito nel DM incluso in set precedente */
oldarg(SnX/NoFr,Testa,Feats,Mods,Id,Temp, Loc):-  
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
   nonvar(Cat),
   notmembro(relazionale,Cat), 
   notmembro(relat,Cat), 
   trova_card(SnX, Num, Part, _, Card0, Card),
   nonvar(Card),
   \+ ref(nil),
    recover_description(Testa, Pred),
   referente(SnX,[],Idx,Pred,Num,Card1),
   !,
   (Num=plur,
    testcard2(Card, Card1),
    referente(SnX,[],Ids,Testa,Num,Card),
    var(Ids),
    build_ref_set(Mods, SnX, Idx, Testa, Num, Ids),
    creatert(NoFr,set,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
    (on(Idz, Ids),
    asserisci(NoFr, SnX, in(Idz, Id)),
    on(Idy, Ids), Idz\=Idy,
    asserisci(NoFr, SnX, in(Idy, Id)),
    asserisci(NoFr, SnX, in(Id, Idx))
    ;
    asserisci(NoFr, SnX, in(Id, Idx))
    )   
   ;
   Num=sing,
    build_ref_set(Mods, SnX, Idx, Testa, _, Ids),
    Ids=[Id],
    atomic(Id)
    ;
    (Card=Card1;Card1=any), 
    Id=Idx),
   (F/Role=sogg/poss,
    (nogen_member(relazionale,Ca)
     ;nogen_member(relat,Cat)), 
    asserisci(NoFr,SnX,fact(relat,[P,Id,nil],1,Temp, Loc))
    ;
    F/Role\=sogg/poss
    ), !.

/*   Definito con Cat member relational e possessore espresso */
oldarg(SnX/NoFr,Testa,Feats,Mods,Idx,Temp, Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
    nonvar(Cat),
    Def\=def0,
    Mods\=[],
    on(_-_/poss, Mods),
    (nogen_member(relazionale,Cat)
     ;nogen_member(relat,Cat)), 
   \+ ref(nil),
   referente(SnX,Mods,Idx,Testa,Num,Card),
   !.

/* 8  Definito con Cat member relational */
oldarg(SnX/NoFr,Testa,Feats,Mods,Idx,Temp, Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
   nonvar(Cat),
   Def\=def0,
    (nogen_member(relazionale,Cat)
     ;nogen_member(relat,Cat)), 
   define_poss_rel(Mods, SnX, Num, Part, Card0, Id, Card2),
   nonvar(Id),
   (
   Num=plur, in(_,Id,Idy), Idz=Idy
   ; 
   Num=sing, Idz=Id
   ),
   (
   (Testa\=fratello,Testa\=sorella,Testa\=brother,Testa\=sister),
   Num=sing,
   creatert(NoFr,ind,Mods,SnX,Testa,Card1,Quant,Num,Idx,Temp, Loc),
   class_props(NoFr, SnX, Cat, Idx, fact, isa, Testa, 1, Temp, Loc),
   asserisci(NoFr,SnX,fact(relat,[Testa,Idz,Idx],1,Temp, Loc))
   ;
   (Testa\=fratello,Testa\=sorella,Testa\=brother,Testa\=sister),
   Num=plur,
   card(_,Idy, Ca),
   Card1 is Ca - 1,
   creatert(NoFr,set,Mods,SnX,Testa,Card1,Quant,Num,Idx,Temp, Loc),
   class_props_in(NoFr, SnX, Cat, Idx, fact, isa, Idy, Testa, 1, Temp, Loc),
   asserisci(NoFr,SnX,fact(Testa,[nil:Idy],1,Temp, Loc))
   ;
   Num=sing,
   in(_,Id,Idy),
   fact(_, name, [Test, Idj], 1, _, _),
   referente(SnX,Mods, Idj, Test, Num, Card),
   \+ main_or_expect(NoFr, Idj),
   in(_, Idj, Idy),
   Idx=Idj,
   (fact(_, relat,[Testa,Idj,_],1,_,_)
    ;
   asserisci(NoFr,SnX,fact(isa,[ind:Idj,class:Testa],1,Temp, Loc)),
   Idj\=Idy,
   asserisci(NoFr,SnX,fact(relat,[Testa,Idj,Idy],1,Temp, Loc)),
   asserisci(NoFr,SnX,fact(relat,[Testa,Idj,Id],1,Temp, Loc))
   )
   ;
   Num=plur,
   in(_,Id,Idy),
   creatert(NoFr,ind,Mods,SnX,Testa,Card,Quant,Num,Idx,Temp, Loc),
   class_props_in(NoFr,SnX,Cat,Idx,fact,isa,Idy, Testa, 1, Temp, Loc),
   asserisci(NoFr,SnX,fact(relat,[Testa,Id,Idy],1,Temp, Loc)),
   asserisci(NoFr,SnX,fact(Testa,[nil:Idy],1,Temp, Loc))
   ;
   nonvar(Id),
   creatert(NoFr,ind,Mods,SnX,Testa,Card,Quant,Num,Idj,Temp, Loc),
   Idx=Idj,
   (fact(_, relat,[Testa,Idj,_],1,_,_)
    ;
   asserisci(NoFr,SnX,fact(isa,[ind:Idj,class:Testa],1,Temp, Loc)),
   asserisci(NoFr,SnX,fact(relat,[Testa,Idj,Id],1,Temp, Loc))
   )
   ),!.

/* non esiste il referente fratello singolare bisogna inferirlo
   cerco il fatto fratello attraverso il main poi cerco una entita'
   singolare che sia inclusa nello stesso set */

oldarg(SnX/NoFr,Testa,Feats,Mods,Idx,Temp, Loc):-
   Feats=[Def,Part,Card0,Class,sing,Cat,F/Role],
    nonvar(Cat),
    find_relat(SnX/NoFr, Testa, Idx, Temp, Loc),
   !.

oldarg(SnX/NoFr,Testa,Feats,Mods,Idx,Temp, Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
    nonvar(Cat),
    Def\=def0,
    (nogen_member(relazionale,Cat)
     ;nogen_member(relat,Cat)), 
   \+ ref(nil),
   referente(SnX,Mods,Idx,Testa,Num,Card),
   !.

/* 11    */
oldarg(SnX/NoFr,Testa,Feats,Mods,Idx,Temp,Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
   nonvar(Cat),
   Def\=def0,
   (nogen_member(relazionale,Cat)
     ;nogen_member(relat,Cat)), 
   trova_card(SnX, Num, Part, _, Card0, Card),
   creater(NoFr,Mods,SnX,Testa,Card,Quant,Num,Idx,Temp, Loc),
   class_props(NoFr, SnX, Cat, Idx, fact, isa, Testa, 1, Temp, Loc),
   (
    relazione_suoce(NoFr, SnX, Idx, Temp, Loc)
    ;
   (NoFr=1, Id=Idx;
    1<NoFr,
    main_or_expect(NoFr, Id)),
    nonvar(Id), Id\=Idx,
    asserisci(NoFr,SnX,fact(relat,[Testa,Id,Idx],1,Temp, Loc))
     ;
   (Role1=tema_bound;Role1=theme_bound),
    F/Role=sogg/Role1,
    (class(_,Id),
    fact(_,isa,[ind:Id,class:Testa],1,Te,Lo),
    gen_sym(id, Idy),
    asserisci(NoFr, SnX, in(Idx, Id))
    ;
    ind(_,Id))
    ;
   (Role1=tema_bound;Role1=theme_bound),
    F/Role\=sogg/Role1,
    nodo(N)::ncomp/prop::pred::Pred,
    fact(_,isa,[ind:Id,class:Testa],1,Te,Lo),
   (on(Nod-_/poss, Mods),
    trova_poss_rel(Nod,SnX,Num,Idy,Card0, Card2),
    nonvar(Idy), Idy\=Idx,
    asserisci(NoFr,SnX,fact(relat,[Pred,Idy,Idx],1,Temp, Loc))
    ;
   (ind(_,Id);
    class(_,Id), Idy\=Idx,
   creatert(NoFr,ind,Mods,SnX,Testa,Card,Quant,Num,Idy,Temp, Loc),
   class_props_in(NoFr, SnX, Cat, Idy, fact, isa, Id, Testa, 1, Temp, Loc),
   asserisci(NoFr,SnX,fact(relat,[Pred,Idy,Idx],1,Temp, Loc))))
   ;
   (Role1=tema_bound;Role1=theme_bound),
    F/Role\=sogg/Role1,
    notnodop(N, ncomp/prop, pred)
    ), !.

/* 9 */
oldarg1(SnX/NoFr,Testa,Feats,Mods,Idx,Temp,Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
   nonvar(Cat),
   Def\=def0,
   nogen_member(istituzione,Cat), 
    trova_card(SnX, Num, Part, _, Card0, Card),
    (genre(legal),ClassSpec=set, 
     (Card=1,Cardin='>10'
         ;
      Cardin=Card)
    ;
     genre(narrative), ClassSpec=class),
    creatert(NoFr,ClassSpec,Mods,SnX,Testa,Cardin,Quant,Num,Idx,Temp, Loc),
    class_props(NoFr, SnX, Cat, Idx, fact, isa, Testa, 1, Temp, Loc),!.

/* 10 */
oldarg1(SnX/NoFr,Testa,Feats,Mods,Idx,Temp,Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
   nonvar(Cat),
   Def\=def0,
   Testa\=seguito,
   nogen_member(hum_set,Cat), 
   creatert(NoFr,set,Mods,SnX,Testa,'>100',Quant,Num,Idx,Temp, Loc),
   class_props(NoFr, SnX, Cat, Idx, fact, isa, Testa, 1, Temp, Loc),
   (
   fact(_,inst_of,[ind:Idy,class:MClass],1,Te,Lo),
   (MClass=militare; nogen_member(military,MClass); nogen_member(mil,MClass)),
   nodo(N0)::F/Role::indice::SnX,
   nodo(N0)::aspetto::Asp,
   nodo(N0)::pred::Pred,
   Pred=dimettere,
   fact(_,role,[P, Idy,Id],1,Tem,Loo),
   asserisci(NoFr, SnX, in(Idy, Idx)),
   asserisci(NoFr,SnX,fact(role,[P,Idy,Id],0,Temp, Loc))
   ;
   MClass\=militare, MClass\=mil).
   
/* 12  */
oldarg1(SnX/NoFr,Testa,Feats,Mods,Id,Temp, Loc):-
    Feats=[Def,Part,Card0,Class,Num,Cat,F/R],
     (Role=tema_bound;Role=theme_bound),
    (F/R=sogg/Role;F/R=ncomp/prop),
     nonvar(Num), 
    (Num=sing,   
    (Testa=questo; Testa=questa; Testa=this; Testa=that),
     noton(_-sogg/nil, Mods)
    ;
     Num=sing,
     (Role=tema_bound;Role=theme_bound),
     nodo(N)::_/Role::antecedente::An,
     topic(NoFr,_,Id),
    (generic_head(Testa, _),
    restrizioni(NoFr, Mods, SnX, Id, Temp, Loc)
    ;
    (generic_head(Testa, _), fail
     ;
    creatert(NoFr,ind,Mods,SnX, Testa,Card,Quant,Num,Idx,Temp, Loc),
    asserisci(NoFr, SnX, fact(role, [Testa, Idx, Id], 1, Temp, Loc)),
    class_props(NoFr, SnX, Cat, Idx, fact, isa, Testa, 1, Temp, Loc),
    asserisci(NoFr, SnX, fact(Testa,[nil:Id], 1, Temp, Loc))
    ))
   ;
   (Testa=nome;Testa=name),
     topic(NoFr,_,Id),
   fact(_,name,[_,Idy],1,T,L),
   (fact(_,isa,[_:Idy,_:_],1,Ta,La),Idz=Idy
     ;
    in(_,Idy,Idz)),   
   nodo(N)::ncomp/prop::sogg/R::antecedente::esterno,
   nodo(N)::ncomp/prop::sogg/R::indice::I,
   confer_topic(NoFr, _, Id, I, _),
   fact(_,isa,[_:Id,_:Pred],1,Ta,La), 
   asserisci(NoFr,SnX,in(Idz,Id)),
   asserisci(NoFr, SnX, fact(Pred,[nil:Idz], 1, Temp, Loc))
   ),   
   !.

oldarg1(SnX/_,Testa,Feats,Mods, Id, _, _):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
   trova_card(SnX, Num, Part, _, Card0, Card),
   \+ ref(nil),
   referente(SnX,Mods,Id,Testa,Num,Card),
   !.

oldarg1(SnX/NoFr,Testa,Feats,Mods,Id,Temp, Loc):-  
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
   infer_induce_prop(Testa,Testa1,Cat),
   (Testa1=Testa, Ind=Id,
       (Num=sing, referente_sing(SnX,Id,sing,Card);
        Num=plur, referente_plur(SnX,Id,plur,Card))
     ;
     Testa1=Testa,
       Num=sing, 
       referente_plur(SnX,Id,plur,Card),
     creatert(NoFr,Type,Mods,SnX,Testa1,Card,Quant,Num,Ind,Temp, Loc),
     class_props(NoFr, SnX, Cat, Ind, fact, isa, Testa1, 1, Temp, Loc),
     asserisci(NoFr, SnX, in(Ind, Id))
     ;
     Testa1\=Testa,
     creatert(NoFr,Type,Mods,SnX,Testa1,Card,Quant,Num,Ind,Temp, Loc),
     class_props(NoFr, SnX, Cat, Ind, fact, isa, Testa1, 1, Temp, Loc),
     asserisci(NoFr, SnX, in(Ind, Id))
      ),    
         !.   

/* 14 Definito plurale in inizio testo */

oldarg1(SnX/NoFr,Testa,Feats,Mods,Id,Temp, Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
   nonvar(Num), Num=plur,
   Def\=def0,
   trova_card(SnX, plur, Part, _, Card0, Card),
   frase_corrente(NoFr,_),NoFr=1,
   (var(Card), Card1=5; 
    \+ integer(Card), Quant=Card;
    nonvar(Card), Card1=Card),
   creatert(NoFr,set,Mods,SnX,Testa,Card1,Quant,plur,Id,Temp, Loc),
   class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
   !.

oldarg1(SnX/NoFr,Testa,Feats,Mods,Id,Temp, Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
    nonvar(Cat),
   nonvar(Num), Num=plur,
   Def\=def0,
   trova_card(SnX, plur, Part, _, Card0, Card),
   (nogen_member(ind, Cat), nogen_member(mil,Cat);nogen_member(militare,Cat)) ,
   fact(_,inst_of, [ind:Id, class:Testa], 1, _, _),
   set(_,Id),
   card(_,Id,C),
   !.

oldarg1(SnX/NoFr,Testa,Feats,Mods,Id,Temp, Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
   nonvar(Cat),
   nonvar(Num), Num=plur,
   Def\=def0,
   trova_card(SnX, plur, Part, _, Card0, Card),
   (nogen_member(umano, Cat); nogen_member(social,Cat); nogen_member(sociale,Cat); nogen_member(role,Cat)),
   creatert(NoFr,set,Mods,SnX,Testa,Card,Quant,plur,Id,Temp, Loc),
   class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
   creatert(NoFr,class,Mods,SnX, person,Card,Quant,Num,Idx,Temp, Loc),
   class_props(NoFr, SnX, Cat, Idx, fact, isa, person, 1, Temp, Loc),
   asserisci(NoFr, SnX, fact(role, [Testa, Id, Idx], 1, Temp, Loc)),
   !.

oldarg1(SnX/NoFr,Testa,Feats,Mods,Id,Temp, Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
   nonvar(Cat),
   nonvar(Num), Num=sing,
   trova_card(SnX, sing, Part, _, Card0, Card),
   (nogen_member(ind, Cat), nogen_member(mil,Cat);nogen_member(militare,Cat)) ,
   fact(_,inst_of, [ind:Idx, class:militare], 1, _, _),
   set(_,Idx),
   card(_,Idx,C),
    creatert(NoFr,class,Mods,SnX,Testa,Card,Quant,sing,Id,Temp, Loc),
    class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
  (on(oggetto,Cat), 
   asserisci(NoFr,SnX,fact(part_of,[Testa,Id,Idx],1,Temp, Loc))
   ;
   noton(oggetto,Cat)),
   !.

/* 15 Definito singolare o nome proprio, gi asserito tra i fatti pi recenti  */
oldarg1(SnX/NoFr,Testa,Feats,Mods,Id,Temp, Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
   nonvar(Cat),
   define_poss_rel(Mods, SnX, Num, Part, Card0, Id, Card2),
  (nonvar(Id),
   nogen_member(body_part,Cat),
   referente(SnX,[],Id,T,Num1,Card2),
   gen_sym(id, Idx),
   class_props(NoFr, SnX, Cat, Idx, fact, isa, Testa, 1, Temp, Loc),
   asserisci(NoFr,SnX,fact(part_of,[Testa,Idx,Id],1,Temp, Loc))
   ;
   \+ ref(nil),
   referente(SnX,Mods,Id,Testa,Num1,Card2),
   individua_controllato(SnX, Id, Temp, Loc)
   ),
   !.

/* 17 Definito singolare o nome proprio, gi asserito tra i fatti pi recenti  */
oldarg1(SnX/NoFr,Testa,Feats,Mods,Idx,Temp, Loc):-  
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
         nonvar(Cat),
         nogen_member(evento,Cat),
         nodo(N0)::fcomp/R::F/Role::indice::SnX,
         nodo(N0)::cat::SemCat, 
         (SemCat=presuppositivo;SemCat=soggettivo),
         PrecNoFr is NoFr - 1,
         topic(PrecNoFr,_,Id1),
         ind(_,Id1),
         ind(_,Id2), Id1\=Id2,
          (sit(Id, Pred, [R1:Id1, R2:Id2], P, T, L)
           ;
           fact(Id, Pred, [R1:Id1, R2:Id2], P, T, L)),
         gen_sym(id, Idx),
         class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
         asserisci(NoFr,SnX,fact(isa,[ind:Idx,class:Testa],1,Temp, Loc)),
         !. 
  
/* 18 Definito singolare incluso in un scenario setting per mezzo della main location */
oldarg1(SnX/NoFr,Testa,Feats,Mods,Id,Temp, Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
         nonvar(Cat),
   (current_main_loc(NoFr, luogo, LocInfo),
    arg(1, LocInfo, Ind),
    arg(2, LocInfo, Pred),
    infer_mereology(Testa,Pred)
    ;
    PreFr is NoFr - 1,
    current_main_loc(PreFr, luogo, LocInfo),
    arg(1, LocInfo, Ind),
    arg(2, LocInfo, Pred),
    infer_mereology(Testa,Pred)
   ),
    trova_card(SnX, Num, Part, _, Card0, Card),
    (    
    (nogen_member(sociale,Cat)
     ;
     nogen_member(social,Cat)
     ;
      nogen_member(role,Cat)),
    creatert(NoFr,ind,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
    class_props(NoFr, SnX, [social_role], Id, fact, isa, Testa, 1, Temp, Loc),
    asserisci(NoFr, SnX, fact(role, [Testa,Ind,Id], 1, Temp, Loc))
    ;
    referente(SnX,Mods,Idx,Pred,Num1,Card2),
    creatert(NoFr,ind,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
    class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
    asserisci(NoFr, SnX, fact(part_of, [Pred,Id,Idx], 1, Temp, Loc))),
    !.   

oldarg1(SnX/NoFr,Testa,Feats,Mods,Ind,Temp, Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
         nonvar(Cat),
   (current_main_loc(NoFr, luogo, LocInfo),
    arg(1, LocInfo, Ind),
    arg(2, LocInfo, Pred),
    Testa=Pred
    ;
    PreFr is NoFr - 1,
    current_main_loc(PreFr, luogo, LocInfo),
    arg(1, LocInfo, Ind),
    arg(2, LocInfo, Pred),
    Testa=Pred
   ),
    asserisci(NoFr, SnX, ind(Ind)), 
    class_props(NoFr, SnX, Cat, Ind, fact, isa, Testa, 1, Temp, Loc),
    !.   

/* 19 per i nomi attivita si cerca il ruolo a cui si riferiscono */
oldarg1(SnX/NoFr,Testa,Feats,Mods,Id,Temp, Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
         nonvar(Cat),
         nogen_member(attivita,Cat),
         current_main_loc(NoFr, luogo, LocInfo),
         arg(1, LocInfo, Ind),
         arg(2, LocInfo, Pred),
         nodo(N0)::indice::SnX,
         nodo(N0)::_/locativo::pred::Pred,   
         PrecNoFr is NoFr - 1,
         topic(PrecNoFr,_,Id1),
         ind(_,Id1),
         fact(_,Rel,[R1:_, prop:Infon],1,_,_),  
         fact(Infon,role,[Prop,Id1,Idx],1,_,_),  
         trova_card(SnX,Num,Part, Quant, Card0,Card),
         creatert(NoFr,ind,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
         class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
         asserisci(NoFr,SnX,fact(isa,[ind:Idx,class:Testa],1,Temp, Loc)),
         !.   

/* 20  */
oldarg1(SnX/NoFr,Testa,Feats,Mods,Id,Temp, Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
         nonvar(Cat),
         nogen_member(attivita,Cat),
         current_main_loc(NoFr, luogo, LocInfo),
         arg(1, LocInfo, Ind),
         arg(2, LocInfo, Pred),
         nodo(N0)::indice::SnX,
         nodo(N0)::_/locativo::pred::Pred1,   
         fact(_,isa,[arg:Id1, arg:Pred1],1,_,_),  
         fact(_,_,[arg:Id2, specif:Id1],1,_,_),  
         fact(_,name,[Pred, Id1],1,_,_),  
         PrecNoFr is NoFr - 1,
         topic(PrecNoFr,_,Idy),
         ind(_,Idy),
         fact(_,Rel,[R1:_, prop:Infon],1,_,_),  
         fact(Infon,role,[Prop,Idy,Idx],1,_,_),  
         trova_card(SnX,Num,Part, Quant, Card0,Card),
         creater(NoFr,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
         class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
         asserisci(NoFr,SnX,fact(isa,[ind:Idx,class:Testa],1,Temp, Loc)),
         !.   

/* 21 
oldarg1(SnX/NoFr,Testa,Feats,Mods,Id,Temp, Loc):-
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
         nonvar(Cat),
         nogen_member(attivita,Cat),
         ind(_,Idy),
         fact(_,inst_of,[ind:Ant, class:Infon],1,_,_),
         on(attivita, Infon),  
         (fact(_,role,[Prop,Idy,Idx],1,_,_), 
          Ant=Idx
          ;  
          fact(_,isa,[ind:Idx,class:Pro],1,_,_),
          Ant=Idx),   
         PrecNoFr is NoFr - 1,
         topic(PrecNoFr,_,Idy),
         ind(_,Idy),
         trova_card(SnX,Num,Part, Quant, Card0,Card),
         creater(NoFr,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
         class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
         asserisci(NoFr,SnX,fact(isa,[ind:Idx,class:Testa],1,Temp, Loc)),
         !.   
*/
/* 22  */
oldarg1(SnX/NoFr,Testa,Feats,Mods,Id,Temp, Loc):-  
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
         nodo(N0)::fcomp/R::F/Role::indice::SnX,
         nodo(N0)::cat::presuppositivo, 
         trova_card(SnX,Num,Part, Quant, Card0,Card),
         creater(NoFr,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
         class_props(NoFr, SnX, Cat, Id, sit, isa, Testa, 1, Temp, Loc),
         !.   

oldarg1(SnX/NoFr,Testa,Feats,Mods,Id,Temp, Loc):-  
    Feats=[Def,Part,Card,Class,Num,Cat,F/Role],
    (Mods=[], 
     define_card(Card, Type)
     ;
     Mods\=[], 
     define_card(Card, Type)),
     (Num=plur,
     creatert(NoFr,set,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
     class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc)
     ;
     (Num=sing;Num=nil),
      Class\= +me,
      assert_common(NoFr,Type,Cat,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc)),
         !.   

oldarg1(SnX/NoFr,Testa,Feats,Mods,Id,Temp, Loc):-  
   Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
         trova_card(SnX, Num, Part, Quant, Card0, Card),
         creater(NoFr,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
         class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc),
         !.   

/* 13 si entra attraverso il genre(legal) */
oldarg1(SnX/NoFr,Testa,Feats,Mods,Id,Temp, Loc):-  
        genre(legal),
        Feats=[Def,Part,Card0,Class,Num,Cat,F/Role],
        trova_card(SnX, Num, Part, _, Card0, Card),
        info(NoFr, Node, FunRole,View, Intens, Change, Rel, 
         VerbCat, Verb, TempRel, DiscRel, DiscDom, SubjConsc),
        (Intens=nonfactive,
        creater(NoFr,Mods,SnX,Testa,Card,exist,Num,Id,Temp, Loc),
         class_props(NoFr, SnX, Cat, Id, sit, isa, Testa, 1, Temp, Loc)
         ;
        (on(umano, Cat); on(hum, Cat); on(sociale, Cat); on(social, Cat)),        
        creater(NoFr,Mods,SnX,Testa,Card,exist,Num,Id,Temp, Loc),
        class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc)
         ;
        creater(NoFr,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
        class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, Temp, Loc)
        ),!.   

infer_induce_prop(Testa,Testa1,Cat):-
   recover_recent_concepts(AllConc),
   on(Id-Testa1, AllConc),
  (is_ax(Testa1,Testa)
    ;
    (fact(_,isa,[_:Id, class:Propp],1,_,_);
     fact(_,inst_of,[_:Id, class:Propp],1,_,_)
     ), 
    (is_list(Propp),
     on(CC,Propp), CC=Testa1
     ;
     atomic(Propp), 
     CC=Propp, CC=Testa1),
      nogen_member(CC,Cat)),
   !.

assert_common(NoFr,Type,Cat,Mods,SnX,Testas,Card,Quant,Num,Id,Temp, Loc):-
     list(Testas),
     reverse(Testas, [Testa,Surn]),
     recover_description(Testas, Preds),
     creatert(NoFr,Type,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
     default_properties(NoFr, SnX, Cat, Preds, Id, Temp, Loc),
     asserisci(NoFr, SnX, fact(inst_of,[ind:Id, class:Testa], 1, univ, univ)),
     asserisci(NoFr, SnX, fact(isa,[ind:Id, class:Testa], 1, univ, univ)),
     asserisci(NoFr, SnX, fact(isa,[ind:Id, class:Preds], 1, univ, univ)),
     creatert(NoFr,class,Mods,SnX,Surn,Card,Quant,Num,Idy,Temp, Loc),
     asserisci(NoFr, SnX, fact(isa,[ind:Idy, class:Surn], 1, univ, univ)),
     asserisci(NoFr,SnX,fact(of,[arg:Idy, specif:Id],1,univ, univ)),
     !.

referente(SnX, Mods, Id, Pred, Num,Card) :-
    atomic(Pred),nonvar(Pred),
    rcs(Pred,Id),nonvar(Id),
    !.
referente(SnX, Mods, Id, Preds, Num,Card) :-
    list(Preds),
    rcs(Preds,Id),nonvar(Id),
    !.

referente(SnX, Mods, Id, Preds, Num,Card) :-
    list(Preds),
    referentes(SnX,Mods,Id,Preds,Num,Card),
    !.
referente(SnX, Mods, Id, Preds, Num,Card) :-
    list(Preds),
    on(Top,Preds),
    rcs(Top,Id),nonvar(Id),
    !.

referente(SnX, Mods, Id, Preds, Num,Card) :-
    list(Preds),
    on(Top,Preds),
    referentes(SnX,Mods,Id,Top,Num,Card),
    !.

find_plur_noun(Pred, PPred):-
    n(Pred, PPred,_),!.
find_plur_noun(Pred, PPred):-
    npro(Pred, PPred,_),!.
find_plur_noun(Pred, PPred):-
    new_n(Pred, PPred,_),!.

coreferens(SnX, NoFr, Pred, Num, Mods, Id):-
    \+ list(Pred),atomic(Pred),nonvar(Pred),
    rcs(Pred,Id),nonvar(Id),
    !.
coreferens(SnX, NoFr, Preds, Num, Mods, Id):-
    list(Preds),
    (on(Top,Preds),
     spy_lower(Pred, LowL, 1)
    ;
    reverse(Preds,RevP),
    on(Top,RevP)),    
    rcs(Top,Id),nonvar(Id)
    ;
    rcs(Preds,Id),nonvar(Id),
    !.

coreferens(SnX, NoFr, Preds, Num, Mods, Id):-
    list(Preds),
    (on(Top,Preds),
     spy_lower(Pred, LowL, 1)
    ;
    reverse(Preds,RevP),
    on(Top,RevP)),    
    referente(SnX,Mods,Id,Top,Num,Card),
    !.

coreferens(SnX, NoFr, Preds, Num, Mods, Id):-
    list(Preds),
    recover_description(Preds,Top),
    referente(SnX,Mods,Id,Top,Num,Card),
    !.

c_referente(SnX, Mods, Id, Pred, Num,Card) :-
    \+ list(Pred),atomic(Pred),nonvar(Pred),
    rcs(Pred,Id),nonvar(Id),
    !.
c_referente(SnX, Mods, Id, Preds, Num,Card) :-
    list(Preds),
    (on(Top,Preds),
     spy_lower(Pred, LowL, 1)
    ;
    reverse(Preds,RevP),
    on(Top,RevP)),    
    rcs(Top,Id),nonvar(Id),
    !.

c_referente(SnX, Mods, Id, PredRef, Num,Card) :-
    PredRef=..[Pref,Preds],
    (Pref=and;Pref=or),
    list(Preds),
    on(Top,Preds),
    c_referentes(SnX,Mods,Id,Top,Num,Card),
    !.


c_referente(SnX, Mods, Id, Preds, Num,Card) :-
    list(Preds),
    on(Top,Preds),
    c_referentes(SnX,Mods,Id,Top,Num,Card),
    !.

c_referentes(SnX, Mods, Id, Testa, Num,Card) :-
  genre(legal),
  abstr_head(Testa),
  (recover_restr(Mods, Restrs)
    ;
   recov_head(SnX, Id)),
  on(RHead, Restrs),
  proprieta(Id,RHead),
  refer(Id,Num,Card), !.

c_referentes(SnX, [], Id, Testa, Num,Card) :-
  generic_head(Testa, _),
  setof(Idp,proprieta(Idp,Testa),
        Pps),
  on(Id, Pps),
  referente_x(SnX,Id,Num,Card).


recov_head(SnX, Id):-
   nodo(N)::M::F/R::indice::SnX,
   nodo(N)::pred::P,
   proprieta(Id, P).

referentes(SnX, Mods, Id, Testa, Num,Card) :-
  genre(legal),
  abstr_head(Testa),
  (recover_restr(Mods, Restrs)
    ;
   recov_head(SnX, Id)),
  on(RHead, Restrs),
  proprieta(Id,RHead),
  refer(Id,Num,Card), !.

referentes(SnX, [], Id, Testa, Num,Card) :-
  generic_head(Testa, _),
  setof(Idp,proprieta(Idp,Testa),
        Pps),
  on(Id, Pps),
  referente_x(SnX,Id,Num,Card).
  
referentes(SnX, Mods, Idp, Testa, Num, Card) :-
  bagof(Id, piu_recente(Id), Ids),
  togli_doppi(Ids, SortId),
  length(SortId,L),
  (50 < L,
   first_fifties(SortId, 1, FirstConcepts)
   ;   
   L =< 50,
   FirstConcepts=SortId),
  (on(Idp, FirstConcepts),
   find_prop(SnX, Mods, Idp, Testa, Num, Card)
   ;
   find_not_rec_prop(SnX, FirstConcepts, Testa, Num, Card, Idp)).

referentes(SnX, Mods, Id, Testa, Num,Card) :-
  !,
  assert(ref(nil)),
  fail,!.

refer(Id,_,_) :-
  class(_,Id).  

refer(Id,plur,_) :-
  set(_,Id),
  card(_,Id,Card).

refer(Id,sing,_) :-
  ind(_,Id).

find_prop(SnX, Mods, Idp, Testa, Num, Card):-
  !,
  proprieta(Idp,Testa),
  restrict(Mods, SnX, Idp, Testa, Num, Card), !.

find_prop(SnX, Mods, Idp, Testa, Num, Card):-
  !,
  proprieta(Idp,Testa),
  !,
  referente_x(SnX,Idp,Num,Card),
  restrict(Mods, SnX, Idp, Testa, Num, Card).

recover_intersezione(Pros,Restrs,Ps):-
    recover_alldescriptions(Pros,Prop1),
    recover_alldescriptions(Restrs,Prop2),
    appiattisci(Prop1,P1),
    appiattisci(Prop2,P2),
    intersezione(P1,P2,Ps),
    !.

recover_alldescriptions([],[]):-!.
recover_alldescriptions([Pro|Pros],[Prop|Props]):-
    recover_descriptions(Pro,Prop),
    recover_alldescriptions(Pros,Props),!.

/* un general noun utilizzato senza restrizioni richiede un accordo di numero con il generic noun a cui si riferisce */
restrict([], SnX, Ind, Testa, Num, Card) :- 
    !,
    (genre(legal),
     (generic_head(Testa, _),
      (Num=sing, Card1=any
       ; 
       Num=plur, (var(Card)
                  ;integer(Card), 1<Card)
       ),
      referente_x(SnX,Ind,Num,Card1)
      ;
      (generic_head(Testa, _), fail
       ;
      referente_x(SnX,Ind,Num,Card))
     )      
    ;
    \+ genre(legal)).

restrict([_-adj/temporale], SnX, Ind, Testa, Num, Card) :-!.
restrict([_-sogg/poss], SnX, Ind, Testa, Num, Card) :-!.
restrict(Mods, SnX, Ind, Testa, plur, -part) :-!.
restrict(Mods, SnX, Ind, Testa, Num, Card) :-
   setof(P, proprieta(Ind, P), PP),
   remove(Testa, PP, Pros),
   (Pros\=[],
    (
     recover_restr(Mods, Restrs),
     Restrs\=[],
     recover_intersezione(Pros,Restrs,Ps), 
      (Ps \= [], 
       (Restrs=Ps,
        recover_locs(Loc, Temp, NoFr),
        on(Pred, Ps),
        nodo(N)::pred::Pred,
        restrizioni(NoFr, N, SnX, Ind, Temp, Loc)
       ;
        Restrs\=Ps 
        )
       ;
       Ps=[], 
      /* 
       a questo punto la Testa possiede degli attributi correnti e anche     
       delle propriet nel DM che non si intersecano, vogliamo che fallisca
       nel caso in cui si tratti di un generic noun e non esiste nessuna   
       proprieta' inferibile nel contesto */ 
     (infer_synon(Ind, Num, Restrs, Prop),
      referente_x(SnX,Ind,Num,Card),
      recover_locs(Loc, Temp, NoFr),
      restrizioni(NoFr, Mods, SnX, Ind, Temp, Loc)
      ;
      (frase_corrente(NoFr,_),
       1<NoFr,
       risolto(NoFr, Sn, Anaf, TestaA), 
       (Role=tema_bound;Role=theme_bound),
       nodo(Node)::_/Role::indice::Sn,
       Sn\=SnX, TestaA\=Testa
       ;
       on(_-sogg/Role, Mods),
       (Role=tema_bound;Role=theme_bound)
       ;
       on(Node-adjs, Mods),
       (nodo(Node)::ncomp/theme::pred::P1;
        nodo(Node)::nome_mod::pred::P1)
      ),
      (generic_head(Testa, _), fail
       ;
      referente_x(SnX,Ind,Num,Card),
      recover_locs(Loc, Temp, NoFr),
      restrizioni(NoFr, Mods, SnX, Ind, Temp, Loc))
       ) /* chiude infer */
      ) /* chiude Ps */
     ;
     nonvar(Restrs),
     Restrs=[]) /* chiude Restrs */
    ;
    (Mods\=[]; Pros=[]),
    (frase_corrente(NoFr,_),
    1<NoFr,
    (Role=tema_bound;Role=theme_bound),
    risolto(NoFr, Sn, Anaf, TestaA), 
       nodo(Node)::_/Role::indice::Sn, 
       Sn\=SnX, TestaA\=Testa
    ;
    (Role=tema_bound;Role=theme_bound),
    on(_-sogg/Role, Mods)),
    (generic_head(Testa, _), fail
     ;
    referente_x(SnX,Ind,Num,Card),
    recover_locs(Loc, Temp, NoFr),
    restrizioni(NoFr, Mods, SnX, Ind, Temp, Loc))).

infer_synon(_, _, [], []):- !.
infer_synon(_, _, [], Pros):- !.
% infer_synon(_, _, Pros, []):- !.
infer_synon(Ind, Num, [Mods|Ms], [Props|Ps]):- 
    (
     (is_a(Mods, Props)
      ;
     deriv(Mods, Props)
      ;
     infer_rel(Ind, Num, Mods, Props))
     ;
    (Ms\=[], Ps\=[],
    infer_synon(Ind, Num, Ms, Ps)
     ;
     Ms=[], Ps\=[],
    infer_synon(Ind, Num, [Mods], Ps)
     ;
     Ms\=[], Ps=[],
    infer_synon(Ind, Num, Ms, Props)     
    )).

/* esiste un insieme nel DM e si deve creare un sottoinsieme proprio che viene individuato da una propriet predicata dell'insieme di base ma non presente nel DM. Si cerca nel WK e si operano inferenze per costituire il nuovo insieme */

build_ref_set(Mods, SnX, Ind, Testa, Num, Inds):-
   setof(P, proprieta(Ind, P), PP),
   remove(Testa, PP, Pros),
   Pros\=[],
   recover_restr(Mods, Restrs),
   Restrs\=[],
   intersezione(Pros,Restrs,Ps), 
   Ps=[], 
   infer_set_ref(Ind, Num, Restrs, Inds).

infer_set_ref(Ind, Num, Restr, Inds):- 
   on(Trig, Restr),
   infer_trig(Trig, Props),
   extra_wk(Ind, Props, Num, Inds).

extra_wk(Ind, [], Num, []).

extra_wk(Ind, [Prop|Props], plur, [Id|Ids]):-
   inf_process(Ind, plur, [Prop], Id),
   extra_wk(Ind, Props, plur, Ids).

infer_rel(Ind, Num, Trig, Inds)
   :-
   !,
   infer_trig(Trig, Props),
   inf_process(Ind, Num, Props, Inds),
  (Inds=[Ind],
    Num=sing, 
      ind(_,Ind)
    ;
    on(Ind, Inds),
    Num=plur, set(_,Ind)
    ;
    Inds=[Ind],
    Num=plur, \+ atomic(Ind)),
   !.

inf_process(Ind, _, [], _).
inf_process(Ind, Num, [Rels|Props], Id)
   :-
   fact(_, Rel, [_:Ind, _:Id], Pol, _, _),
   fact(_, isa, [_:Id, class:Class], Pol, _, _),
   inf_process(Ind, Num, Props, Id),
    Rels=..[Rel,Class,1].

inf_process(Ind, Num, [Rels|Props], Id)
   :-
   fact(_, Rel, [_:Id, _:Ind], Pol, _, _),
   fact(_, isa, [_:Id, class:Class], Pol, _, _),
   inf_process(Ind, Num, Props, Id),
    Rels=..[Rel,Class,1].

inf_process(Ind, Num, [Rels|Props], Id)
   :-
   fact(_, Rel, [_:Ind, _:Id], 0, _, _),
   fact(_, isa, [_:Id, class:Class], Pol, _, _),
   inf_process(Ind, Num, Props, Id),
    Rels=..[Rel,Class,0].

inf_process(Ind, Num, [Rels|Props], Id)
   :-
   fact(_, Rel, [_:Id, _:Ind], 0, _, _),
   fact(_, isa, [_:Id, class:Class], Pol, _, _),
   inf_process(Ind, Num, Props, Id),
    Rels=..[Rel,Class,0].
    
inf_process(Ind, Num, [Rels|Props], Id)
   :-
   (
     fact(_,Rel, [_:Ind], 1, _, _)
      ->
      fail, !
    ;
    fact(_,Rel, [_:Ind], 0, _, _)
    ),
    inf_process(Ind, Num, Props, Ids),
    Rels=..[Rel,Class,0].

inf_process(Ind, Num, [PropInd|Props], Id)
   :-
   PropInd=..[Prop,Ind, 1],
    fact(_,Prop, [_:Ind], 1, _, _),
    inf_process(Ind, Num, Props, Id).

inf_process(Ind, Num, [Rels|Props], Id)
   :-
    fact(_, Rel, [_:Id, prop:Inf], 0, _, _),
    fact(Inf,Rel1, [prop:Inf1], 1, _, _),
    fact(Inf1,Rel2, [_:Id], 1, _, _),
    inclus_in(Id,Ind),
    inf_process(Ind, Num, Props, Id),
    Rels=..[Rel,Rel1,(Rel2,1),0].

inf_process(Ind, Num, [Rels|Props], Id)
   :-
    fact(Inf, Rel, [propint:Inf1, _:Id], 0, _, _),
    fact(Inf1,Rel1, [_:Id], 1, _, _),
    inclus_in(Id,Ind),
    inf_process(Ind, Num, Props, Id),
    Rels=..[Rel,_,(Rel1,1),0].
inf_process(Ind, Num, [Rels|Props], Id)
   :-
    fact(Inf, Rel, [propadj:Inf1, _:Id], 0, _, _),
    fact(Inf1,Rel1, [_:Id], 1, _, _),
    inclus_in(Id,Ind),
    inf_process(Ind, Num, Props, Id),
    Rels=..[Rel,_,(Rel1,1),0].
/*
infer_trig(scansafatiche, [avere(voglia,(faticare,1), 0), piacere((lavorare,1),0)]).
*/

inclus_in(Id, Ind):-
   nonvar(Id),nonvar(Ind),
   in(_,Id,Idz),
   in(_,Idz,Ind).

inclus_in(Id, Ind):-
   nonvar(Id),nonvar(Ind),
   in(_,Id,Ind).

 
recover_locs(univ, univ, _):-
   genre(legal),!.

recover_locs(Loc, Temp, NoFr):-
         frase_corrente(NoFr,_),
         current_main_loc(NoFr, tempo, TempInfo),
         arg(1, TempInfo, Temp),
         current_main_loc(NoFr, luogo, LocInfo),
         arg(1, LocInfo, Loc).

recover_restr([], []):- !.

recover_restr(Mods, Res):-
   !,
   recover_mods(Mods, Restr),
   recover_adjs(Mods, Restr1),
   recover_preds(Mods, Restr2),
    append(Restr, Restr1, Rest),
    append(Rest, Restr2, Res),!.



recover_mods([N-mods|Mods], Res1):-
     setof(P,
       (nodo(N)::nome_mod::pred::P
       ;
       nodo(N)::mod_r::pred::P
       ;
       nodo(N)::mod_a::pred::P
       ),
       Res),
   (on(P1, Res),
   (P1=specie; P1=tipo; P1=kind; P1=type), 
   remove(P1, Res, Res1)
    ;
    Res1=Res),!.

recover_mods(Mods, []).

recover_adjs([N-adjs|Adjs], Addg):-
     setof(A,
             recover_adj([N-adjs|Adjs], A),
              Res),
     Res=[Addg].

recover_adjs([N-_|Adjs], Addg):-
     setof(A,
             recover_adj([N-adjs|Adjs], A),
              Res),
     Res=[Addg].

recover_adjs(Adjs, []).

recover_adj([N-adjs|Adjs], Res):-
     setof(P1,
             (nodo(N)::nome_mod::pred::P1),
              Res),!.

recover_adj([N-adjs|Adjs], Res):-
     setof(P,
             (nodo(N)::F/R::pred::P;
              nodo(N)::F/R::coordina::F/R::pred::P),
              Res), !.

recover_adj([N-_|Adjs], Res):-
     setof(P1,
             (nodo(N)::nome_mod::pred::P1),
              Res),!.

recover_adj([N-_|Adjs], Res):-
     setof(P,
             (nodo(N)::F/R::pred::P;
              nodo(N)::F/R::coordina::F/R::pred::P),
              Res), !.

recover_preds([N-F/Role|Adjs], Res):-
     (Role=tema_bound;Role=theme_bound),
     !,
     setof(P,(nodo(N)::F1/prop::pred::P, F1\=vcomp;
              nodo(N)::vcomp/prop::_/prop::pred::P;
              nodo(N)::_/prop::coordina::_/prop::pred::P),
              Res),!.

recover_preds([N-F/R|Adjs], [FRes|Res]):-
     R\=tema_bound,R\=theme_bound,
     R\=poss,
     !,
     setof(P,(nodo(N)::F/R::pred::P
             ;
              nodo(N)::coordina::F/R::pred::P),
              FRes),
     recover_preds(Adjs, Res),!.

recover_preds(Preds, []).

concept_filter(Testa):-
   Testa\=nil, Testa\=exist, Testa\=ev, Testa\=tloc, Testa\=pr, Testa\=st, Testa\=ev, Testa\=ev, 
   !.

/*
recover_recent_concepts(AllConc):-
  bagof(Id, piu_recente(Id), Ids),
  togli_doppi(Ids, SortId),
  findall(Testa, (on(Idp, SortId),
   (proprieta_sempl(Id,Testa)
   ;
    proprieta_compl(Id,Testa)), concept_filter(Testa)), Concepts),
   appiattisci(Concepts, AConc),
   sort(AConc, AllConc),
   !.
*/
first_fifties([C|AllConc], N, [C|FirstConcepts]):-
  N =< 50,
  N1 is N + 1,
  first_fifties(AllConc, N1, FirstConcepts),
  !.
first_fifties(AllConc, N, []):-
  50 < N,
  !.

match_concepts(AllConc, Mods, Id, Testa, Num, Card):-
  on(Id-Testa1, AllConc),
  (is_ax(Testa1,Testa)
    ;
    (fact(_,isa,[_:Id, class:Propp],1,_,_);
     fact(_,inst_of,[_:Id, class:Propp],1,_,_)
     ),
    (
     (list(Propp),on(Testa,Propp);atomic(Propp), Testa=Propp)
     ;
    list(Testa),on(Propp,Testa))
    ),
   !.

recover_check_recent_concepts(FirstConcepts):-
  recover_recent_concepts(AllConc),
  sort(AllConc,SAllConc),
  length(SAllConc,L),
  (50 < L,
   first_fifties(SAllConc, 1, FirstConcepts),
   assert(recent_concepts(FirstConcepts))
   ;
   L =< 50,
   FirstConcepts=SAllConc),
   !.

%   topps(Typ, N, Testa, Id,_),
%    ;

recover_recent_concepts(AllConc):-
  findall(Id-Testa, (
    (proprieta_sempl(Id,Testa)
    ;
    proprieta_compl(Id,Testa)), 
               concept_filter(Testa)), Concepts),
   appiattisci(Concepts, AConc),
   reverse(AConc, AllConc),
%   sort(AConc, AllConc),
   !.

referentess(SnX, Mods, Id, Testa, Num,Card) :-
  (is_a(Testa1,Testa)
    ;
   is_a(Testa,Testa1)),
  piu_recente(Id),
  proprieta_sempl(Id,Testa1),
   !.

referentess(SnX, Mods, Id, Testa, Num, Card) :-
  once(recent_concepts(AllConc)),
  AllConc\=[],
  !,
  match_concepts(AllConc, Mods, Id, Testa, Num, Card),
   !.

referentess(SnX, Mods, Id, Testa, Num, Card) :-
  recover_check_recent_concepts(AllConc),
  match_concepts(AllConc, Mods, Id, Testa, Num, Card),
   !.

referentess(SnX, Mods, Id, Testa, Num,Card) :-
  !,
  assert(ref(nil)),
  fail,!.

/*
referentes(SnX, Mods, Id, Testa, Num,Card) :-
  infer_most_specific(Testa, AllGen),
  AllGen\=[],
  on(Testa1-Cats,AllGen),
  piu_recente(Id),
  proprieta_sempl(Id,Testa1),
  !.
*/

infer_most_specific(Testa, AllGen):-
  recover_recent_concepts(AllConc),
  findall(Testa1-Gen, (on(Testa1, AllConc), Testa1\=pPro,
            s_is_axx(Testa1,Testa, Gen)), AllGen),
  !.

find_not_rec_prop(SnX, SortId, Testa, Num, Card, Id) :-
   !,
   (nonvar(Testa),
    generic_head(Testa, _), fail
     ;
   (proprieta_sempl(Id,Testa)
   ;
    proprieta_compl(Id,Testa)),
   noton(Id, SortId),
   referente_x(SnX,Id,Num,Card)).

find_not_rec_prop(SnX, SortId, Testa, Num, Card, Id) :- !.

refer_propr(Id, Testa, Num, Card) :-
  (piu_recente(Id),
  proprieta_compl(Id,Testa);
  proprieta_compl(Id,Testa) ), !.


referen_sing(Id, Testa, sing, 1, Idx) :-
  piu_recente(Id),
  proprieta_compl(Id,Testa),
  referen_x(Id,sing,1,Idx), !.

referen_plur(Id, Testa, plur, Cd, Idx) :-
  piu_recente(Id),
  proprieta_sempl(Id,Testa),
  referen_x(Id,plur,Cd,Idx),!.

referente_x(SnX,Id,nil,Card) :-
   genre(legal),
   referente_sing(SnX,Id,sing,Card),!.
referente_x(SnX,Id,nil,Card) :-
   genre(legal),
   referente_plur(SnX,Id,plur,Card),!.

referente_x(SnX,Id,sing,Card) :-
   \+ genre(legal),
   referente_sing(SnX,Id,sing,Card),!.

referente_x(SnX,Id,plur,Card) :-
   \+ genre(legal),
   referente_plur(SnX,Id,plur,Card),!.

referente_x(SnX,Id,Num,Card) :-
    genre(legal),
    (var(Card), 
     (Num=sing, Card=1; Num=plur)
     ;
     nonvar(Card)),
    (Num=sing,referente_sing(SnX,Id,sing,Card) 
     ;
     referente_plur(SnX,Id,plur,Card1)),!.

referente_sing(SnX,Id,sing,Card1) :-
  class(_,Id),
  card(_,Id,Card),
  nogen_member(Card,[some,every]),
  (individua_antecedente(IdSn, Ind, Card, Card0),
            (nonvar(Card0), Card1 = Card0;
             var(Card0), Card1=5)
   ;
   Card1=1), !.  

referente_sing(SnX,Id,sing,1) :-
  ind(_,Id), !.

referente_sing(SnX,Id,sing,Card) :-
  genre(legal),
  (Card=any;nonvar(Card)),
  class(_,Id), !.

referente_sing(SnX,Id,sing,any) :-
  genre(legal),
  ind(_,Id), !.

referente_sing(SnX,Id,sing,1) :-
  ent(_,Id),
  fact(_,_,Args,1,_,_),
  on(Role:Id, Args),
  (Role\=ind, Role\=arg),
  frase_corrente(NoFr,_),
  notind(Id),
  asserisci(NoFr, SnX, ind(Id)), !.

referente_sing(SnX,Id,sing,1) :-
  in(_, Id, Idy),
  (class(_, Idy),
    fail, !
    ;
   set(_, Idy)), !.

notind(Id):-
   setof(Id, ind(_,Id), Ids),
   Ids=[],!.

notcard(Id):-
   setof(Id, card(_,Id,_), Ids),
   Ids=[],!.

referen_x(Id,sing,1,Idx) :-
  set(_,Id),
  card(_,Id,Card1),
  nonvar(Card1),
  1<Card1, Idx=Id.

referen_x(Id,plur,Cd,Idx) :-
  set(_,Id),
  card(_,Id,Card1),
  nonvar(Card1),
  1<Card1, Idx=Id.

referente_plur(SnX,Id,plur,Card1) :-
  class(_,Id),
  card(_,Id,Card),
  nogen_member(Card,[some,every]),
  Card1 = 3.  

referente_plur(SnX,Id,plur,Card) :-
  set(_,Id),
  card(_,Id,Card).

referente_plur(SnX,Id,plur,Card) :-
  genre(legal),
  set(_,Id),
  card(_,Id,Card1), Card= -part.

referente_plur(SnX,Id,plur,Card) :-
  genre(legal),
  class(_,Id),
  (var(Card); integer(Card), 1<Card).

referente_plur(SnX,Id,plur,Card) :-
  ent(_,Id),
  frase_corrente(NoFr,_),
  card(_,_,Card),
  asserisci(NoFr, SnX, set(Id)),
  asserisci(NoFr, SnX, card(Id,Card)).

infer_mereology(Testa,Pred) :-
   included(Testa,Pred).

infer_mereology(Testa,Pred) :-
   included(Testa,NewPred),
   infer_mereology(NewPred,Pred).


has_prop(Ind, Pred) :-
   proprieta(Ind,Pred),!.

/*
has_prop(Ind, Pred) :-
   in(_,Ind, Id),
   has_prop(Id, Pred).
*/
has_prop(Ind, Pred) :-
   nogen_member(P, Pred),
   has_prop(Id, P),
   in(_,Id, Ind),!.

/*******
ho gi cercato propriet semplici e complesse
cerco una propriet ereditata da una pi generale
prendo l'indice di quella generale
prop_heredit(Id,Props):-
  var(Props),
  !,
  proprieta_sempl(Id,Propp),
  in(_,Id,Ind),
  proprieta(Ind,Props).

prop_heredit(Id,Props):-
  var(Id),
  !,
  proprieta_sempl(Id,Props),
  in(_,Ind,Id),
  proprieta(Ind,Props).
********/

proprieta(Id,Propp) :-
    rcs(Propp,Id),!.
    
/*
proprieta(Id,Propp) :-
(nonvar(Id);nonvar(Propp)),
(
 proprieta_compl(Id,Propp)
  ;
 proprieta_sempl(Id,Propp)
%  ;
% prop_heredit(Id,Propp)
).
*/

proprieta_sempl(Id,Propp) :-
  (
    (fact(_,Propp,[nil:Id],1,_,_);
     fact(_,Propp,[ind:Id],1,_,_);
     fact(_,Id,[arg:_, arg:Propp],_,_,_), Id\=isa)
    ;
    (sit(_,Propp,[nil:Id],1,_,_);
     sit(_,Propp,[ind:Id],1,_,_);
     sit(_,Id,[arg:_, arg:Propp],_,_,_))
     ;
    (
     fact(_,isa,[arg:Id, arg:Propp],_,_,_)
     ;
     fact(_,isa,[_:Id, class:Propp],1,_,_)
     ;
     sit(_,isa,[_:Id, class:Propp],1,_,_))
/*     ;
   relazione ereditaria - provvisorio solo un livello
     in(_,Id,Idx),
     (fact(_,isa,[_:Idx, class:Propp],1,_,_)
      ; 
      sit(_,isa,[_:Idx, class:Propp],1,_,_)) */
    ).  

/* nel genere legale, una propriet generica pu essere utilizzata per riprendere propriet che questa sussume; nel genere letterario questo non avviene: un uomo viene introdotto nel mondo e non si tratter mai dello stesso uomo che gi esisteva precedentemente 
proprieta_sempl(Id,Propp) :-
     genre(legal),
     fact(_,inst_of,[_:Id, class:Propp],1,_,_),
     (fact(_,name,[Prop,Id],1,_,_)
      ;
      fact(_,isa,[_:Id, class:Prop],1,_,_)).
*/

/* se la testa corrente  un nome generico si verifica se nel mondo esiste una propriet pi specifica che ne condivida la propriet di default */
infer_prop_sempl(Id,Propp) :-
     generic_head(Propp, Dprop),
     fact(_,inst_of,[_:Id, class:Dprop],1,_,_),
     (fact(_,name,[Prop,Id],1,_,_)
      ;
      fact(_,isa,[_:Id, class:Prop],1,_,_)), 
      Prop\=exist, Prop\=Propp,!.

infer_prop_def(Id,Propp) :-
     (atomic(Propp),spy_lower(Propp,LowP,1);LowP=Propp),
     (fact(_,name,[Propp,Id],1,_,_)
      ;
      fact(_,isa,[_:Id, class:Propp],1,_,_)
      ;
      fact(_,name,[LowP,Id],1,_,_)
      ;
      fact(_,isa,[_:Id, class:LowP],1,_,_)),
     (set(_,Id); ind(_,Id)), 
       !.

infer_prop_class(Id,Propp) :-
     (atomic(Propp),spy_lower(Propp,LowP,1);LowP=Propp),
     (fact(_,name,[Propp,Id],1,_,_)
      ;
      fact(_,isa,[_:Id, class:Propp],1,_,_)
      ;
      fact(_,name,[LowP,Id],1,_,_)
      ;
      fact(_,isa,[_:Id, class:LowP],1,_,_)),
     (set(_,Id); ind(_,Id);class(_,Id);ent(_,Id)), 
       !.

proprieta_spec(Id,Propp) :-
     (atomic(Propp),spy_lower(Propp,LowP,1);LowP=Propp),
     (fact(_,name,[Propp,Id],1,_,_)
      ;
      fact(_,isa,[_:Id, class:Propp],1,_,_)
      ;
      fact(_,name,[LowP,Id],1,_,_)
      ;
      fact(_,isa,[_:Id, class:LowP],1,_,_)),
       !.

proprieta_poss(1,Id,Prop,Propp,Idx):-
  proprieta_spec(Id,Propp).  

/*
proprieta_poss(1,Id,Prop,Propp,Idx) :-
  in(_,Idy,Id), Idy\=Idx,
  proprieta_spec(Idy,Propp).  
*/

proprieta_poss(Card,Id,Prop,Props,Idx) :-
   !,
  integer(Card),
  1<Card,
  (in(_,Id,Idx),
   proprieta_compl(Idx,Propp)
   ;
   proprieta_compl(Id,Propp)),  
   (var(Prop);nonvar(Prop),Prop\=Propp),
  Card1 is Card - 1,
  proprieta_poss(Card1,Id,Prop,Propp1,Idx),
  Propp\=Propp1,
  (list(Propp1),
   (on(Propp, Propp1),
    Props=Propp1
    ;
    append([Propp], Propp1, Props))
   ;
  append([Propp], [Propp1], Props)).  

proprieta_compl(Id,Propp) :-
  fact(_,name,[Propp,Id],1,_,_).  

proprieta_compl(Id,Propp) :-
  fact(_,name,[Prop,Id],1,_,_),
  in(_,Id,Idx),
  (fact(_,Propp,[ind:Idx],1,_,_);
   fact(_,Propp,[arg:Idx],1,_,_)).

proprieta_compl(Id,Propp) :-
  fact(_,name,[Prop,Id],1,_,_),
  fact(_,surname,[Propp:Id],1,_,_).

proprieta_compl(Id,Propp) :-
  fact(_,cause,[Propp:Idx,arg:Id],1,_,_),  
  fact(_,isa,[_:Id, class:Propp],1,_,_).  

/*
proprieta_compl(Idx,Propp) :-
  fact(_,poss,[Propp,Id,Idx],1,_,_),  
  (fact(_,isa,[_:Id, class:Propp],1,_,_)
    ;
     fact(_,name,[PropP,Id],1,_,_)).  
*/
proprieta_compl(Id,Propp) :-
  fact(_,relat,[Propp,Id,Idx],1,_,_),  
  fact(_,Propp,[nil:Id],1,_,_).  

proprieta_compl(Id,Propp) :-
  fact(_,role,[Propp,Id,Idx],1,_,_),  
  fact(_,isa,[_:Id, class:Propp],1,_,_).  

proprieta_compl(Id,Propp) :-
  fact(_,relat,[Propp,Id,Idx],1,_,_),  
  fact(_,isa,[_:Id, class:Propp],1,_,_).  

proprieta_compl(Id,Propp) :-
  fact(_,relat,[Propp,Id,Idx],1,_,_).  

proprieta_compl(Id,Propp) :-
  fact(_,role,[Propp,Id,Idx],1,_,_).  

proprieta_compl(Idy,Propp) :-
  fact(_, isa, [_:Idy, _:Pro], 1, _, _),
  (P=of;P=for;P=with;P=in;P=has),
  fact(_, P, [_:Id, Role:Idy], 1, _, _),
  fact(_, P, [_:Id, Role:Idw], 1, _, _),
  Idw\=Idy,
  fact(_, isa, [_:Idw, _:Propp], 1, _, _).

proprieta_compl(Idy,Propp) :-
  fact(_, isa, [_:Idy, _:Propp], 1, _, _),
  (P=of;P=for;P=with;P=in;P=has),
  fact(_, P, [_:Id, Role:Idy], 1, _, _).

proprieta_compl(Id,Propp) :-
  nonvar(Id),
  proprieta_sempl(Id,_),
  in(_, Id, Idx),
  proprieta_sempl(Idx,Propp).

proprieta_compl(Id,Propp) :-
  nonvar(Id),
  proprieta_sempl(Id,_),
  fact(_, P, [_:_, _:Id, prop:Infon], 1, _, _),
  fact(Infon, Props, [arg:Idx], 1, _, _),
  (list(Props), on(Propp, Props); Propp=Props).

proprieta_compl(Id,Propp) :-
  nonvar(Id),
  proprieta_sempl(Id,_),
  fact(_, P, [arg:Idx, _:Id], 1, _, _),
  proprieta_sempl(Idx,Propp).

proprieta_compl(Idy,Propp) :-
  nonvar(Propp),
  fact(_, P, [_:_, _:Id, prop:Infon], 1, _, _),
  fact(Infon, Props, [arg:Idx], 1, _, _),
  (list(Props), on(Propp, Props); Propp=Props),
  fact(_, isa, [_:Idy, class:Propp], 1, _, _).


proprieta_rec(Id,Propp) :-
  piu_recente(Id),
  in(_,Id,Idx),
  (
  fact(_,isa,[ind:Idx, class:Propp],1,_,_)
  ; 
  sit(_,isa,[ind:Idx, class:Propp],1,_,_)).  

proprieta_rec(Id,Propp) :-
  proprieta_compl(Id,Propp),
  (in(_,Id,Idx)
   ;
   true).

proprieta_rec_rel(Id,Propp,Prop) :-
  piu_recente(Id),
  in(_,Id,Idx),
  (
  fact(_,isa,[ind:Idx, class:Prop],1,_,_)
  ; 
  sit(_,isa,[ind:Idx, class:Prop],1,_,_)).  

class_props_d(NoFr, SnX, Cat, Id, SitFac, name, D, Testa, Pol, Temp, Loc)
    :-
    (D=0;D='0'),
    class_props(NoFr, SnX, Cat, Id, SitFac, name, Testa, Pol, Temp, Loc).

class_props_d(NoFr, SnX, Cat, Id, SitFac, ind, '+', Testa, Pol, Temp, Loc)
    :-
    class_props(NoFr, SnX, Cat, Id, SitFac, isa, Testa, Pol, Temp, Loc).

class_props_d(NoFr, SnX, Cat, Id, SitFac, class, D, Testa, Pol, Temp, Loc)
    :-
    (D=0;D='0'),
    class_props(NoFr, SnX, Cat, Id, SitFac, isa, Testa, Pol, Temp, Loc).

class_props(NoFr, SnX, Cat, Id, SitFac, isa, Testa, Pol, Temp, Loc) :-
            \+ interp(compl),
            nonvar(Testa),
            (var(Temp), Temp=univ; nonvar(Temp)),
            (var(Loc), Loc=univ; nonvar(Loc)),
            default_properties(NoFr, SnX, Cat, Pred, Id, Temp, Loc),
            SitFacts=..[SitFac,isa,[ind:Id,class:Testa],Pol,Temp, Loc],
            asserisci(NoFr,SnX,SitFacts).

class_props(NoFr, SnX, Cat, Id, SitFac, name, Testa, Pol, Temp, Loc) :-
            \+ interp(compl),
            nonvar(Testa),
            (var(Temp), Temp=univ; nonvar(Temp)),
            (var(Loc), Loc=univ; nonvar(Loc)),
            default_properties(NoFr, SnX, Cat, Pred, Id, Temp, Loc),
            SitFacts=..[SitFac,name,[Testa, Id],Pol,Temp, Loc],
            asserisci(NoFr,SnX,SitFacts).

class_props(NoFr, SnX, Cat, Id, SitFac, isa, Testa, Pol, Temp, Loc) :-
            nonvar(Testa),
            default_properties(NoFr, SnX, Cat, Pred, Id, Temp, Loc),
            SitFacts=..[SitFac,isa,[ind:Id,class:Testa],Pol,Temp, Loc],
            asserisci(NoFr,SnX,SitFacts).

class_props(NoFr, SnX, Cat, Id, SitFac, name, Testa, Pol, Temp, Loc) :-
            nonvar(Testa),
            default_properties(NoFr, SnX, Cat, Pred, Id, Temp, Loc),
            SitFacts=..[SitFac,name,[Testa, Id],Pol,Temp, Loc],
            asserisci(NoFr,SnX,SitFacts).

class_props_in(NoFr, SnX, Cat, Idx, SitFac, isa, Id, Testa, Pol, Temp, Loc) 
        :-
            nonvar(Testa),
        default_properties(NoFr, SnX, Cat, Pred, Idx, Temp, Loc),
        asserisci(NoFr, SnX, in(Id,Idx)),
            SitFacts1=..[SitFac,isa,[ind:Id,class:Testa],Pol,Temp, Loc],
        asserisci(NoFr,SnX,SitFacts1),
            SitFacts2=..[SitFac,isa,[ind:Idx,class:Testa],Pol,Temp, Loc],
        asserisci(NoFr,SnX,SitFacts2).

piu_recente(Id) :-
  frase_corrente(N,_),
  N1 is N - 1, 
  piu_recente_x(N1,Id).

piu_recente_x(N, Id) :-
  1=<N,
  topic(N,_,Id),
  nonvar(Id)
  ;
  1=<N,
  N1 is N - 1,
  piu_recente_x(N1,Id).

testcard1(Card, Card1):-
    integer(Card),
   (Card1=any
    ;
   (Card < 5,
    Card < Card1
    ;
    Card \= 5,
    nonvar(Card1))),
    !.

testcard1(Card, Card1):-
    \+ integer(Card),
    nonvar(Card1),
    integer(Card1),
    3 < Card1,!.

testcard2(Card, Card1):-
    integer(Card),
    nonvar(Card1),
   (Card1=any
    ;
    Card < Card1),
    !.

testcard2(Card, Card1):-
    \+ integer(Card),
    nonvar(Card1),
    integer(Card1),
    3 < Card1,!.

testcard3(Card):-
    nonvar(Card),
    integer(Card),
     1<Card,
    !.
testcard3(Card):-
    nonvar(Card),
    \+ integer(Card),
    !.

/* outside */
trova_card(_, Num, _, some, _, some) :-
   var(Num),
   !.
trova_card(Ind,sing,Part,Part,Cd,Part) :-
         Part\=nil,
         !. 
trova_card(Ind,sing,Part,Part,Cd,Part) :-
         nonvar(Cd),
         Cd=nil,
         Part\=nil,
         !. 
trova_card(Ind,plur,Part,Part,Cd,Part) :-
         nonvar(Cd),
         Cd=nil,
         Part\=nil,
         !. 
trova_card(Ind,nil,_,_,_,Card) :-
         main_or_expect(NoFr, Id),
         card(_,Id,Card), 
         integer(Card).
trova_card(Ind,nil,_,some,_,some).

trova_card(Ind,sing,_,_,nil,1).
trova_card(Ind,sing,_,_,Cd,Card):-
         nonvar(Cd),
         converti_card(Cd,Part,Card),
         !. 
trova_card(Ind,elder,_,_,_,1).
trova_card(Ind,others,_,_,_,_).
trova_card(Ind,some,_,some,_,_).
trova_card(Ind,plur,Part,Testa,Cd,Card1) :-
         Part\=nil,
         nonvar(Cd),
         converti_card(Cd,Part,Card1),
         !. 
trova_card(Ind,plur,Part,Testa,Cd,Card1) :-
         nonvar(Cd),
         converti_card(Cd,Part,Card1),
         !. 
trova_card(Ind,plur,Part,Testa,Cd,Card1) :-
%         var(Cd),
         nodo(N0)::F/Role::indice::Ind,
         nodo(N0)::F/Role::spec::quant::Q,
         converti_part(Part,Q,Card1),
         !. 
trova_card(Ind,Num,Part,Testa,Cd,Card1) :-
         var(Cd),
         converti_part(_,Part,Card1),
         Part\= -part, Part\= +part,
         !. 
trova_card(Ind,plur,Part,Part,Cd,Part) :-
         nonvar(Cd),
         Cd=nil,
         Part\=nil,
         !. 
trova_card(_Ind,plur,_,_,_,5).

converti_part(-part,nothing,not_all).
converti_part(-part,no,not_all).
converti_part(-part,all,all).
converti_part(-part,_,every).
converti_part(+part,many,many).
converti_part(+part,few,few).
converti_part(+part,few,a_few).
converti_part(+part,much,a_lot).
converti_part(+part,any,any).
converti_part(+part,little,little).
converti_part(+part,_,some).
converti_card(two,_,2).
converti_card(three,_,3).
converti_card(3,_,3).
converti_card(2,_,2).
converti_card(1,_,1).
converti_card(Num,_,C1):-
                stringof(List,Num),
                on('_',List),
                on(N,List), integer(N),
                on(Int,List), intens(Int,L), L=[],
                 I=0, 
                 !,
                 (incr_card(I,C1)
                  ;
                 N0>=1,
                 I2 is I + N0, 
                 (incr_card(I2, C1)
                   ;
                  I3 is N0 + 1,
                  incr_card(I3, C1))).

converti_card(Num,Int,N):-
     var(Int),
     nm(Num,_,N).

converti_card(Num,Int,Num):-
     var(Int),
     nm(N,_,Num).

converti_card(Num,nil,Int):-
     nm(Num,_,Int).

converti_card(Num,nil,Int):-
     nm(Int,_,Num).

converti_card(Num,Int,INum):-
     nonvar(Int), Int\=nil,
     nm(N,_,Num),
     concat(Int,'_',INu),
     concat(INu,N,INum).

converti_card(Num,Int,INum):-
     nonvar(Int), Int\=nil,
     spot_date(Num, Feats-Lemma),
     concat(Int,'_',INu),
     concat(INu,Lemma,INum).

converti_card(Num,Int,INum):-
     nonvar(Int), Int=nil,
     spot_date(Num, Feats-Lemma),
     Feats\=[],
     on(type=Type, Feats),
     nonvar(Type),
     concat(Num,Type,INum).

converti_card(Num,Int,Num):-
     nonvar(Num), Num\=nil.

incr_card(I, C1) :-
   I1 is I + 1,
   C1 is I1 + 1.

/* 
   verify_card(Card0, Card, Part, Num, NCard),

Card0=quella in input; 
Card=quella in uscita da trova_card che nel caso di un plurale privo di Card in input diventa automaticamente =5;
Part=nil o se diverso da nil anche Card0 lo sar;
Num e NCard 
*/

verify_card(Card0, Card, Part, Num, NCard):-
   nonvar(Card0),
   nonvar(Part),
   nonvar(Num),
   ver_card(Card0, Card, Part, Num, NCard).

ver_card(nil, Card, nil, plur, NCard):-!.
ver_card(nil, Card, Part, sing, Card):-!.
ver_card(Card0, Card, Part, Num, Card):-
   Card0\=nil, nonvar(Card).


check_restrizioni(Mods, SnX, Ind, Loc, Temp, Prop):-
   on(N-adjs, Mods),
   restrizioni_a(NoFr, N, SnX, Ind, Loc, Temp, Prop). 

restriz_sit(SnX, Ind, Temp, Loc):-
  nodo(N)::indice::SnX,
  nodo(N)::mods::nodo(N1),
       (nodo(N1)::nome_mod::pred::P
       ;
       nodo(N1)::mod_r::pred::P
       ;
       nodo(N1)::mod_a::pred::P
       ),
  (proprieta_sempl(Ind,P)
   ->
   fail, !;
   true),
  frase_corrente(NoFr,_),
   asserisci(
      NoFr, SnX, sit(P, [nil:Ind], 1, Temp, Loc)).

restrizioni(NoFr, [], SnX, Ind, Temp, Loc) :- !.

restrizioni(NoFr, [Mod|Mods], SnX, Ind, Temp, Loc) :-
   \+ atomic(Mod),
   (
    Mod=N-mods,
    restrizioni_m(NoFr, N, SnX, Ind, Temp, Loc)
    ; 
    Mod=N-adjs,
    restrizioni_a(NoFr, N, SnX, Ind, Loc, Temp, _)
    ; 
    Mod=N1-F/R, R\=tema_bound, R\=theme_bound, R\=poss,
    restrizioni_a(NoFr, N1, SnX, Ind, Loc, Temp, _)
    ;
    (Role=tema_bound;Role=theme_bound),
    nodo(N)::F/Role::indice::SnX,
    (F=sogg;F=ogg),
    restrizioni_r(NoFr, N, SnX, Ind, Temp, Loc)
    ),
    restrizioni(NoFr, Mods, SnX, Ind, Temp, Loc).

restrizioni(NoFr, N, SnX, Ind, Temp, Loc) :-
    N\=[L],
   setof(N1-Type,
  (
   nodo(N)::Type::nodo(N1), Type\=spec
   ;
   nodo(N)::_/Type::nodo(N1)), Mods),
   (remove(N1-mods, Mods, Adjs),
    restrizioni_m(NoFr, N1, SnX, Ind, Temp, Loc),
    (Adjs\=[],
     restrizioni(NoFr, Adjs, SnX, Ind, Temp, Loc)
     ;
     Adjs=[])
    ; 
    remove(N1-adjs, Mods, Mods),
    restrizioni_a(NoFr, N1, SnX, Ind, Loc, Temp, _),
    (Mods\=[],
     restrizioni(NoFr, Adjs, SnX, Ind, Temp, Loc)
     ;
     Mods=[])
    ;
    (Role=tema_bound;Role=theme_bound),
    nodo(N2)::F/Role::indice::SnX, 
    (F=sogg;F=ogg),
    restrizioni_r(NoFr, N, SnX, Ind, Temp, Loc),
    restrizioni_a(NoFr, N, _, Ind, Loc, Temp, _)
    ; 
    on(N1-F/R, Mods),R\=tema_bound,R\=theme_bound, R\=poss,
    restrizioni_a(NoFr, N1, SnX, Ind, Loc, Temp, _)
    ).

restrizioni(_, _,_,_,_,_).

restriz(NoFr, [], SnX, Ind, Temp, Loc) :- !.

restriz(NoFr, Mods, SnX, Ind, Temp, Loc) :-
   (list(Mods),on(N-_,Mods);atomic(Mods),N=Mods),
   restrizioni_m(NoFr, N, SnX, Ind, Temp, Loc),
   !.
restriz(_, _, _, _, _, _) :- !.

restrizioni_m(NoFr, N, SnX, Ind, Temp, Loc) :-
   findall_mod_restriz(N,Res),
   (nodo(N1)::nome_mod::cat::Cat,
    nogen_member(surname,Cat),
    Res=[P1],
    (proprieta_sempl(Ind,P1)
      ->
     fail, !;
     true),
   asserisci(NoFr, SnX, fact(surname, [P1,Ind], 1, Temp, Loc))
  ;
  asseriscilistares(NoFr, Type, N, _, Res, SnX, Ind, Temp, Loc)
  ).

restrizioni_m(NoFr, N, SnX, Ind, Temp, Loc) :-
         nodo(N0)::_/theme::nodo(N),
  nodo(N)::pred::Pp,
  nodo(N)::indice::SnY,
  (fact(_,name,[Pp,_],1,_,_)
    ->
    fail,!;
    true),
    recover_descriptions(Pp, Pred),
  creatert(NoFr, ind, N1, SnX, Pred, _, _, _, Idx, Temp, Loc),
  asserisci(NoFr, SnY, fact(name, [Pred, Idx], 1, Temp, Loc)),
 !.
restrizioni_m(_, _, _, _, _, _). 

asseriscilistares(NoFr, Type, N, _, [], SnX, Ind, Temp, Loc):-!.
asseriscilistares(NoFr, Type, N, _, [P-Type|Res], SnX, Ind, Temp, Loc):-
  asserisci_lista_res(NoFr, Type, N, _, [P], SnX, Ind, Temp, Loc),
asseriscilistares(NoFr, T, N, _, Res, SnX, Ind, Temp, Loc),!.

findall_mod_restriz(N,SortRes):-
   findall(P-Type,
           (findmodrestriz(N, P, Type), P\=exist,P\=pPro), Res),
   sort(Res, SortRes).

findmodrestriz(N, P, Type):-
       nodo(N)::adj/_::pred::P, Type=adj.
findmodrestriz(N, P, Type):-
       nodo(N)::nome_mod::pred::P, Type=mod.
findmodrestriz(N, P, Type):-
       nodo(N)::mod_r::pred::P, Type=mod.
findmodrestriz(N, P, Type):-
       nodo(N)::mod_a::pred::P, Type=mod.
findmodrestriz(N, P, Type):-
       nodo(N)::mod_r::coordina::coord::pred::P, Type=mod.
findmodrestriz(N, P, Type):-
       nodo(N)::mod_a::coordina::coord::pred::P, Type=mod.
findmodrestriz(N, P, Type):-
       nodo(N)::Mod::pred::P, Type=mod.
findmodrestriz(N, P, Type):-
       nodo(M)::mods::pred::P, Type=mod.


restrizioni_a(NoFr, N, SnX, Ind, Loc, Temp, Res) :-
  setof(P,((nodo(N)::sub/esplicativa::nodo(N2);
           nodo(N)::sub/comparativa::nodo(N2);
           nodo(N)::sub/compar::nodo(N2)),
                          nodo(N2)::pred::P),Res),
  (nodo(N2)::cat::Cat,
  nogen_member(evento,Cat),
  asserisci_lista_res(NoFr, isa, N, Cat, Res, SnX, Ind, Temp, Loc);
  asserisci_lista_ruoli(NoFr, Res, SnX, Ind, Loc, Temp, Id)),!.

restrizioni_a(NoFr, N, SnX, Ind, Loc, Temp, Res) :-
   setof(P,(
          (nodo(N)::adj/materia::nodo(N2);
           nodo(N)::adj/matter::nodo(N2);
           nodo(N)::adj/emotivo::nodo(N2)),
                          nodo(N2)::pred::P),Res),
   asserisci_lista_res(NoFr, mod, N, _, Res, SnX, Ind, Temp, Loc),
   restrizioni(NoFr, N2, SnX, Ind, Temp, Loc),!.

restrizioni_a(NoFr, N, SnX, Ind, Loc, Temp, Res) :-
   setof(N2,(nodo(N)::adj/causale::nodo(N2), Sogg=ogg;
             nodo(N)::obl/causa::nodo(N2), Sogg=ogg;
             nodo(N)::adj/causale::coordina::ogg/causale::nodo(N2), 
                Sogg=ogg),
         Ns),
   coordina_cause(Sogg, Ns, NoFr, N, SnX, Ind, Temp, Loc).

restrizioni_a(NoFr, N, SnX, Ind, Loc, Temp, Pred) :-
         nodo(N0)::_/theme::nodo(N),
  nodo(N)::pred::Pp,
  nodo(N)::indice::SnY,
  (fact(_,name,[Pp,_],1,_,_)
    ->
    fail,!;
    true),
    recover_descriptions(Pp, Pred),
  creatert(NoFr, ind, N1, SnX, Pred, _, _, _, Idx, Temp, Loc),
  asserisci(NoFr, SnY, fact(name, [Pred, Idx], 1, Temp, Loc)),
 !.

restrizioni_a(NoFr, N, SnX, Ind, Loc, Temp, Pred) :-
  nodo(N)::F/R::pred::Pred,
  R\=tema_bound,R\=theme_bound,
  select_head_func(F, R, Pred),
  nodo(N)::F/R::indice::SnY,
  nodo(N)::F/R::cat::Cat,
  nodo(N)::F/R::spec::def::D,
  nodo(N)::F/R::tab_ref::Tab,
  nodo(N)::F/R::nodo(N1),
  define_type(D, Tab, Type),
  (
   (1<NoFr,risolto(NoFr, SnY, Pred, Testa)
    ;
    Testa=Pred),
   (fact(_,name,[Testa,Id],1,_,_)
    ; 
    proprieta_sempl(Id,Pred)),
   (
    (fact(_, has, [arg:Ind, R:Id], 1, _, _)
    ;
    fact(_, has, [R:Id, arg:Ind], 1, _, _)
    ;
    fact(_, cause, [R:Id, arg:Ind], 1, _, _)
    )
    ;
    assert_head_func(NoFr, SnY, Id, Ind, F, R, Pol, Temp, Loc) 
    )
   ;
   creatert(NoFr, Type, N1, SnY, Pred, _, _, _, Id, Temp, Loc),  
   class_props_d(NoFr, SnY, Cat, Id, fact, Type, D, Pred, 1, Temp, Loc),
   assert_head_func(NoFr, SnY, Id, Ind, F, R, Pol, Temp, Loc)),
   !.
restrizioni_a(NoFr, N, SnX, Ind, Loc, Temp, Pred) :-
  setof(N2,
         nodo(N)::nadj/theme::coordina::nadj/theme::nodo(N2),
        Ns),
  coord_names(Ns, NoFr, N, SnX, Ind, Loc, Temp, Pred),
  !.
restrizioni_a(_, _, _, _, _, _, _).


coordina_cause(Sogg, [], NoFr, N, SnX, Ind, Temp, Loc):- !.

coordina_cause(Sogg, [N1|Ns], NoFr, N, SnX, Ind, Temp, Loc):-
   nodo(N1)::pred::Pp,
   \+ proprieta_compl(Id,Pp),
   (proprieta_sempl(Id1, Pp),
   (Sogg=sogg, Restr=[Pp:Id1, arg:Ind]
    ;
    Restr=[arg:Ind, Pp:Id1]),
    asserisci(NoFr, SnX, fact(cause,Restr, 1, Temp, Loc))   
    ;
    build_ref(NoFr,N1,SnX,Pp,Id1,Temp, Loc),
   (Sogg=sogg, Restr=[Pp:Id1, arg:Ind]
    ;
    Restr=[arg:Ind, Pp:Id1]),
   asserisci(NoFr, SnX, fact(cause,Restr, 1, Temp, Loc)),      
   asserisci(NoFr, SnX, fact(isa,[arg:Id1, class:Pp], 1, Temp, Loc))
   ),
   coordina_cause(Sogg, Ns, NoFr, N, SnX, Ind, Temp, Loc).


restriz_agg(NoFr, N, sub/compar,SnX, Ind, Temp, Loc) :-
  nodo(N)::sub/compar::nodo(N2),
  frase_corrente(NoFr,_),
  1<NoFr,risolto(NoFr,SnX,_,_), 
  (Role=tema_bound;Role=theme_bound),
  nodo(N2)::adjs::adj/Role::pred::Pred,
  proprieta_sempl(Id,Pred),
  restr_pred(NoFr, N2,SnX, Id, sogg/Role, Temp, Loc),
  !.

restriz_agg(NoFr, N, adj/materia, SnX, Ind, Temp, Loc) :-
  nodo(N)::adjs::nodo(N1),
  nodo(N1)::adj/materia::sogg/nil::controllore::SnX,
  nodo(N1)::adj/materia::nodo(N2),
  (nodo(N2)::ogg/materia::cat::Cat,
   nogen_member(nquant,Cat),
   nodo(N2)::ogg/materia::ogg/theme::pred::P;
   nodo(N2)::pred::P),
  (
    (proprieta_sempl(Ind,P)
      ->
     fail, !;
     true),
   asserisci(NoFr, SnX, fact(P, [materia:Ind], 1, Temp, Loc))),
   restrizioni(NoFr, N2, SnX, Ind, Temp, Loc),!.

restriz_agg(NoFr, N, adj/emotivo, SnX, Ind, Temp, Loc) :-
  nodo(N)::adjs::adj/emotivo::pred::P,
    (proprieta_sempl(Ind,P)
      ->
     fail, !;
     true),
   asserisci(NoFr, SnX, fact(P, [ind:Ind], 1, Temp, Loc)),
  !.

restriz_agg(NoFr, N, adj/materia, SnX, Ind, Temp, Loc) :-
  setof(P,
          (nodo(N)::adjs::adj/materia::pred::P;
           nodo(N)::adjs::adj/materia::coordina::ogg/materia::pred::P),
        Pps),
  (on(Pp, Pps),
    (proprieta_sempl(Ind,P)
      ->
     fail, !;
     true),
   asserisci(NoFr, SnX, fact(isa,[ind:Ind, class:Pp], 1, Temp, Loc)),      
   restrizioni(NoFr, N2, SnX, Ind, Temp, Loc)),!.

restriz_agg(NoFr, N, sub/_, SnX, Ind, Temp, Loc) :-
  nodo(N)::adjs::adj::nodo(N1),
  setof(P,((nodo(N1)::sub/esplicativa::nodo(N2);
           nodo(N1)::sub/comparativa::nodo(N2);
           nodo(N1)::sub/compar::nodo(N2)),
                          nodo(N2)::pred::P),Res),
  (nodo(N2)::mods::nome_mod::pred::Tes,
   (Tes=specie; Tes=tipo; Tes=kind; Tes=type),
    on(Testa, Res),
    restrizioni(NoFr, N2, SnX, Ind, Temp, Loc)
   ;
   nodo(N2)::cat::Cat,
   asserisci_lista_res(NoFr, isa, N, Cat, Res, SnX, Ind, Temp, Loc),
   restrizioni(NoFr, N2, SnX, Ind, Temp, Loc)),!.

restriz_agg(_, _, _, _, _, _, _).

asserisci_proprieta_relazioni(IdGov,Pred,NoFr,Id):-
   stringof(MWord,Pred),
   reverse(MWord,['_',s, '-'|Word]),
   reverse(Word,RevWord),
   stringof(RevWord,Lex),
   get_id_mod(NoFr, Lex, [], NewRefs, SnY, Id, NewR),
   asserisci(NoFr, SnY, fact(of, [arg:IdGov, specif:Id], 1,univ, univ)),
    !.

asserisci_proprieta_relazioni(IdGov,LowW,NoFr,IdGov):-
    jj(LowW),
   (proprieta_sempl(IdGov,LowW)
     ;
     asserisci(NoFr, SnY, fact(LowW, [nil:IdGov], 1,univ, univ))),
    !.
asserisci_proprieta_relazioni(IdGov,LowW,NoFr,IdGov):-
    r(LowW),
   (proprieta_sempl(IdGov,LowW)
     ;
     asserisci(NoFr, SnY, fact(LowW, [nil:IdGov], 1,univ, univ))),
    !.
asserisci_proprieta_relazioni(IdGov,Pred,NoFr,Id):-
   spy_lower(Pred, LowL, 1),   
   get_id_mod(NoFr, Pred, [], NewRefs, SnY, Id, NewR),
   asserisci(NoFr, SnY, fact(of, [arg:IdGov, specif:Id], 1,univ, univ)),
    !.
asserisci_proprieta_relazioni(IdGov,Pred,NoFr,Id):-
   get_id_mod(NoFr, Pred, [], NewRefs, SnY, Id, NewR),
   (proprieta_sempl(Idx,Pred)
     ;
    asserisci(NoFr, SnY, fact(of, [arg:IdGov, specif:Id], 1,univ, univ))),
    !.

coord_names([], NoFr, N, SnX, Ind, Loc, Temp, Pred) :- !.

coord_names(Ns, NoFr, N, SnX, Ind, Loc, Temp, Pred) :-
  remove(N1,Ns,Ns1),
  nodo(N1)::pred::Pp,
  nodo(N1)::indice::SnY,
  (fact(_,name,[Pp,_],1,_,_)
    ->
    fail,!;
    true),
    recover_descriptions(Pp, Pred),
   shassert_names(NoFr,[umano],[],SnX,Pred,Card,Quant,Num,Idx,Temp, Loc),
%  creatert(NoFr, ind, N1, SnX, Pp, _, _, _, Idx, Temp, Loc),
  asserisci(NoFr, SnY, fact(name, [Pp, Idx], 1, Temp, Loc)),
  asserisci(NoFr,SnX, in(Idx,Ind)),
  coord_names(Ns1, NoFr, N, SnX, Ind, Loc, Temp, Pred).

define_type(D, Tab, Type) :-
  (on(-class, Tab), Type=name
    ;
   on(+class, Tab), D='0', Type=class 
    ;
   on(+class, Tab), Type=ind).

assert_head_func(NoFr, SnY, Id, Ind, F, R, Pol, Temp, Loc):-
  (F=ogg,
   asserisci(NoFr,SnY,fact(has,[arg:Ind,R:Id],1,Temp, Loc))
   ;
   F=sogg,
   asserisci(NoFr,SnY,fact(has,[R:Id,arg:Ind],1,Temp, Loc))
   ;
   F=ogg2,
   asserisci(NoFr,SnY,fact(exper,[R:Id,arg:Ind],1,Temp, Loc))
   ;
   F=obl, (R=causale;R=causer),
   asserisci(NoFr,SnY,fact(cause,[R:Id,arg:Ind],1,Temp, Loc))
   ),!.

select_head_func(F, R, P):-
  (F=sogg;F=ogg;F=obl;F=ogg2), 
%   R\=poss,
   P\=vbl, 
   P\=pPro. 

restrizioni_r(NoFr, N, SnX, Ind, Temp, Loc) :-
   restr_pred(NoFr, N, SnX, Ind, Temp, Loc).

restrizioni_r(_, _, _, _, _, _).


restr_predic(NoFr, SnX, Ind, F/Role, Temp, Loc) :-
   (Role=tema_bound;Role=theme_bound),
   nodo(N1)::F/Role::indice::SnX,
   restr_pred(NoFr, N1, SnX, Ind, Temp, Loc).


restr_predic(_, _, _, _, _, _).

restr_pred(NoFr, N, SnX, Ind, Temp, Loc) :-
  (nodo(N)::Fun/prop::nodo(N1);
   nodo(N)::Fun/materia::nodo(N1);
   nodo(N)::Fun/matter::nodo(N1);
  nodo(N)::Fun/modale::ogg/_::nodo(N1);
  nodo(N2)::coordina::nodo(N),
  nodo(N)::_/prop::nodo(N1) ),
  nodo(N1)::indice::SnY,
  nodo(N1)::pred::P,P\=nome,
  (nodo(N)::adjs::nodo(N0),
  nodo(N0)::neg::_, Pol=0; Pol=1),
   (
    on(Fun, [ncomp, pcomp]),
    nodo(N1)::cat::Cat,
    (nogen_member(sociale,Cat)
     ;nogen_member(social,Cat)
     ;nogen_member(role,Cat)),
    (proprieta_sempl(Ind,P)
      ->
     fail, !;
     true),
    creatert(NoFr, ind, N1, SnX, P, _, _, _, Id, Temp, Loc), 
    asserisci(NoFr, SnX, fact(role, [P,Id,Ind], Pol, Temp, Loc)),
    class_props(NoFr, SnX, Cat, Id, fact, isa, P, 1, Temp, Loc),
    asserisci(NoFr, SnX, fact(P,[nil:Ind], 1, Temp, Loc)),
    check_activity(NoFr, SnX, Id, Pol, Temp, Loc)   
   ;
   (nodo(N1)::cat::Cat,
    nogen_member(attivita,Cat),
    nodo(N1)::spec::def::'+',
    fact(_, name, [_, Ind], 1, _, _),
    fact(_, role, [Role, Ind, Idy], 1, _, _),
    fact(_, inst_of, [ind:Idy, class:Class], 1, _, _),
    nogen_member(attivita, Class),
    asserisci(NoFr, SnX, fact(isa,[ind:Ind, class:P],Pol,Temp, Loc)),
    restrizioni(NoFr, N1, SnY, Ind, Temp, Loc)
    ;
    nodo(N1)::cat::Cat,
    (nogen_member(relazionale,Cat)
     ;nogen_member(relat,Cat)), 
    (proprieta_compl(Ind,P)
      ->
     fail, !;
     true),
    nodo(N)::F1/R1::sogg/poss::indice::Sny,
    1<NoFr,risolto(NoFr, Sny, Anaf, Test),
    (
     fact(_,isa,[_:Idy, class:Test],1,_,_);
     fact(_,name,[Test, Idy],1,_,_)),
    ind(_,Idy), Idy\=Ind,
    asserisci(NoFr,SnX,fact(relat,[P,Ind,Idy],1,Temp, Loc))
    ;
    (proprieta_sempl(Ind,P)
      ->
     fail, !;
     true),
    asserisci(NoFr, SnX, fact(P,[nil:Ind],Pol,Temp, Loc)),
    restrizioni(NoFr, N1, SnY, Ind, Temp, Loc) )
   ),
   !.

restr_pred(NoFr, N, SnX, Ind, Temp, Loc) :-
  nodo(N)::_/prop::pred::nome,
  (Role=tema_bound;Role=theme_bound),
  setof(N2,
        nodo(N)::_/Role::coordina::_/Role::nodo(N2),
        Ns),
  (on(N1, Ns),
   nodo(N1)::pred::Pp,
   nodo(N1)::indice::SnY,
  main_or_expect(NoFr, Ind),
  (fact(_,name,[Pp,_],1,_,_)
   ->
   fail,!;
   true),
  gen_sym(id, Idx),
  asserisci(NoFr, SnY, fact(name, [Pp, Idx], 1, Temp, Loc)),
  asserisci(NoFr,SnX, in(Idx,Ind))),
  !.

restr_pred(NoFr, N, SnX, Ind, Temp, Loc) :-
  nodo(N)::_/prop::nodo(N1),
  nodo(N1)::indice::SnY,
  nodo(N1)::pred::P,P=nome,
  (nodo(N)::adjs::nodo(N0),
  nodo(N0)::neg::_, Pol=0; Pol=1),
  asserisci_infon(ind,+class, Pol, r_pred, NoFr, SnY, P, Ind, Temp, Loc),  
  !.

restr_pred(_, _, _, _, _, _).

check_activity(NoFr, SnX, Id, Pol, Temp, Loc):-   
    ind(_, Id),
    (fact(_, isa, [ind:Id, class:P], 1, _, _)
      ;
     sit(_, isa, [ind:Id, class:P], 1, _, _)),
    fact(_, inst_of, [ind:Id, class:Class], 1, _, _),
    (nogen_member(attivita, Class),
    asserisci(NoFr, SnX, fact(isa,[ind:Id, class:P],Pol,Temp, Loc))
    ;
    notmembro(attivita, Class)).

/***********
poss_restriction(+Mods,-Modd,+NoFr,+SnX,+Ind,+Loc,+Temp,-Card,-Card1)
***********/
poss_restriction([], [], NoFr, SnX, Ind, Loc, Temp, Card, Card1) :- !.

poss_restriction(Mods, Modd, NoFr, SnX, Ind, Loc, Temp, Card, Card1) :-
   remove(N-F/poss, Mods, Modd),
   pos_restr(N-F/poss, NoFr, SnX, Ind, Loc, Temp, Card, Card1).

poss_restriction(Mods, Mods, NoFr, SnX, Ind, Loc, Temp, Card, Card1).
poss_restriction(_, _, _, _, _, _, _, _, _).

pos_restr(N-F/_, NoFr, SnX, Ind, Loc, Temp, Card, Card1) :-
   nodo(N)::F/poss::nodo(N1),
   nodo(N1)::pred::Pred,
 ( nodo(N1)::antecedente::IdSN;
   nodo(N1)::controllore::IdSN),
   individua_antecedente(IdSN, PossInd, Card, Card1),
  (nodo(N0)::vcomp/prop::F/R::indice::SnX
   ;
  (
   proprieta_poss(Card1,PossInd,Prop,Propp,Idx), 
    Prop=Propp;
   proprieta_spec(PossInd,Prop)),
   (fact(_,poss,[Prop,PossInd,Ind],1,Temp, Loc)
    ->
    fail,!;
    true),
   asserisci(NoFr, SnX, fact(poss,[Prop,PossInd,Ind],1,Temp, Loc))
  ;
   proprieta_spec(PossInd,Prop), 
   asserisci(NoFr, SnX, fact(poss,[Prop,PossInd,Ind],1,Temp, Loc)
  )    
  ;
  assegna_nomi(NoFr,PossInd,Ind,Prop,Card1,Temp, Loc)),
  !.
pos_restr(N-ncomp/_, NoFr, SnX, Ind, Loc, Temp, Card, Card1) :-
   nodo(N)::ncomp/possess::nodo(N1),
   nodo(N1)::pred::Pred,
   nodo(N1)::indice::SnY,
   nodo(N1)::cat::Cat,
   nodo(N1)::num::Num,
   nodo(N1)::spec::def::Def,
   (Def='0',Def1=def0,Class= - class;Def1='+def',Class = +class),
   trova_card(SnY, Num, Part, Quant, Card0, Card2),
   crea_arg(arg(SnY/NoFr,Pred,Def1,Part,Card0,Class,Num,Cat,ncomp/possess), Id, Temp, Loc), 
  asserisci(NoFr, SnX, fact(poss,[Pred,Id,Ind],1,Temp, Loc)),
  !.
pos_restr(_, _, _, _, _, _, _, _).

assegna_nomi(NoFr,PossInd,Ind,Prop,Card1,Temp, Loc) :-
    (1<Card1;Card1=1),  
  (proprieta_poss(Card1,PossInd,Prop,Propp,Idx),
            Prop1=Propp,
            (var(Idx), PossId=PossInd
             ;
             nonvar(Idx), PossId=Idx)
   ;
   proprieta(PossInd,Prop),Prop1=Prop, PossId=PossInd),
  asserisci(NoFr, SnX, 
    fact(poss,[Prop1,PossId,Ind],1,Temp, Loc)),   
   (Card0 is Card1 - 1, Card0=0
    ;
    Card0 is Card1 - 1,
   assegna_nomi(NoFr,PossInd,Ind,Propp,Card0,Temp, Loc)).

trova_poss_rel(N, SnX, Num, PossInd, Card, Card1) :-
  !,
  nodo(N)::F/R::nodo(N1),
  trova_poss_ind(N1, PossInd, Card, Card1).

trova_poss_rel(_,_, _, _, _, _).

trova_poss_ind(N1, PossInd, Card, Card1) :-
  nodo(N1)::antecedente::IdSN,
  individua_antecedente(IdSN, PossInd, Card, Card1),
  !.

trova_poss_ind(N1, PossInd, Card, Card1) :-
  nodo(N1)::indice::IdSN,
  individua_antecedente(IdSN, PossInd, Card, Card1),
  !.

trova_poss_ind(N1, Idy, Card, Card1) :-
  nodo(N1)::pred::Pred,
  (fact(_, poss, [Pred, Idy, Id], 1, _, _)
   ;
   proprieta_poss(Card, Idy, Pro, Pred, Idz)),
  !.

define_poss_rel([], _, _, _, _, _, _):-!.

define_poss_rel(Mods, SnX, Num, Part, Card0, Idy, Card2):-
   (on(N-_/poss, Mods)
    ;on(N-sogg/_, Mods)), 
   trova_card(SnX, Num, Part, _, Card0, Card),
   verify_card(Card0, Card, Part, Num, Card2),
   trova_poss_rel(N,SnX,Num,Idy,Card0, Card2),
   !.

coordinati(Type, Class, NoFr, SnX, Ind, Pred, Idx, Temp, Loc) :-
   nodo(N)::Fun/Role::indice::SnX,
   nodo(_)::coordina::nodo(N),
   nodo(N)::Fun/Role::indice::SnY,
   SnX \= SnY,
   nodo(N1)::indice::SnY,
   nodo(N1)::pred::Pred,
   coord_assert_prop(Type, Class, [], NoFr, SnX, Ind, Loc, Temp, SnY, Pred, Fun/Role, Idx).
  
coordinati(Type, Class, NoFr, SnX, Ind, Pred, Idx, Temp, Loc) :-
   nodo(N)::Fun/Role::indice::SnX,
   nodo(N)::Fun/Role::coordina::nodo(N1),
   nodo(N1)::_/Role::indice::SnY,
   SnX \= SnY,
   nodo(N2)::indice::SnY,
   nodo(N2)::pred::Pred,
   (nonvar(Ind),
   coord_assert_prop(Type, Class, [], NoFr, SnX, Ind, Loc, Temp, SnY, Pred, Fun/Role, Idx)
    ;
    var(Ind),
   coord_assert_pr(Type, Class, [], NoFr, SnX, Loc, Temp, SnY, Pred, Ind, Idx)).

coordinati(_, _, _, _, _, _, _, _, _) .

/* si asserisce il secondo congiunto con creater_coo, e si cerca  il terzo 
coordinati2 asserisce il set che puo' variare da 2 a 3 */
coord_assert_prop(Type, Class, N, NoFr, SnX, Ind, Loc, Temp, SnY, Pred, _, Idx) :-
   \+ genre(legal),
   (\+ proprieta_sempl(Id,Pred),
   creater_coo(NoFr, ind, N, SnY, Pred, 1, _, _, Idy, Temp, Loc),
   coordinati2(Type, Class, NoFr, SnY, SnX, Idx, Pred, Loc, Temp),
   asserisci(NoFr, SnY, fact(isa, [ind:Idy, class:Pred], 1, Temp, Loc)),
   asserta(rcs(Pred,Idy)),
   asserisci(NoFr, SnY, in(Idy,Idx)),
   asserisci(NoFr, SnX, in(Ind,Idx))
   ;
   proprieta_sempl(Id, Pred),
%   creater_coo(NoFr, ind, N, SnY, Pred, 1, _, _, Idy, Temp, Loc),
   coordinati2(Type, Class, NoFr, SnY, SnX, Idx, Pred, Loc, Temp),
%   asserisci_infon(Type, Class, 1, Idy, NoFr, SnY, Pred, Idx, Temp, Loc),
   asserisci(NoFr, SnY, in(Id,Idx)),
   asserisci(NoFr, SnX, in(Ind,Idx))
   ;
   proprieta_sempl(Id, Pred),
   creater_coo(NoFr, ind, N, SnY, Pred, 1, _, _, Idy, Temp, Loc),
   creater_coo(NoFr, set, N, SnX, Pred, 2, _, _, Idx, Temp, Loc),
%   asserisci_infon(Type, Class, 1, Idy, NoFr, SnY, Pred, Idx, Temp, Loc),
   asserisci(NoFr, SnY, in(Idy,Idx)),
   asserisci(NoFr, SnY, in(Ind,Idx))),
   !.

coord_assert_prop(Type, Class, N, NoFr, SnX, Ind, Loc, Temp, SnY, Pred, _, Idx) :-
   genre(legal),
   !,
    (proprieta_sempl(Id,Pred)
      ->
     fail, !;
     true),
   creater_coo(NoFr, ind, N, SnY, Pred, 1, _, _, Idy, Temp, Loc),
   coordinati2(Type, Class, NoFr, SnY, SnX, Idx, Pred, Loc, Temp),
   asserisci_infon(Type, Class, 1, _, NoFr, SnY, Pred, Idx, Temp, Loc),
   asserisci(NoFr, SnX, in(Ind,Idx)),
   !.

coord_assert_pr(Type, Class, N, NoFr, SnX, Loc, Temp, SnY, Pred, Ind, Idx) :-
   \+ genre(legal),
   (\+ proprieta_sempl(Id,Pred),
   creater_coo(NoFr, ind, N, SnY, Pred, 1, _, _, Idy, Temp, Loc),
   coordinati2(Type, Class, NoFr, SnY, SnX, Idx, Pred, Loc, Temp),
%   asserisci_infon(Type, Class, 1, _, NoFr, SnY, Pred, Idx, Temp, Loc),
   asserisci(NoFr, SnX, in(Ind,Idx))
   ;
   proprieta_sempl(Id, Pred),
%   creater_coo(NoFr, ind, N, SnY, Pred, 1, _, _, Idy, Temp, Loc),
   coordinati2(Type, Class, NoFr, SnY, SnX, Ind, Pred, Loc, Temp),
%   asserisci_infon(Type, Class, 1, _, NoFr, SnY, Pred, Ind, Temp, Loc),
   creater_coo(NoFr, set, N, SnX, Pred, 2, _, _, Idx, Temp, Loc)),
   asserisci(NoFr, SnX, in(Id,Idx)),
   !.

coord_assert_pr(Type, Class, N, NoFr, SnX, Loc, Temp, SnY, Pred, Idx, Idx) :-
   genre(legal),
   !,
    (proprieta_sempl(Id,Pred)
      ->
     fail, !;
     true),
   creater_coo(NoFr, ind, N, SnY, Pred, 1, _, _, Idy, Temp, Loc),
%   asserisci_infon(Type, Class, 1, _, NoFr, SnY, Pred, Idy, Temp, Loc),
   coordinati2(Type, Class, NoFr, SnY, SnX, Idx, Pred, Loc, Temp),
   asserisci(NoFr, SnX, in(Idy,Idx)),
   !.

/* costruisce il set con creater_coo e asserisce il terzo e l'inclusione */
coordinati2(Type, Class, NoFr, SnY, SnX, Idx, P, Loc, Temp) :-
   nodo(N)::Fun/Role::indice::SnX,
   nodo(N)::Fun/Role::coordina::nodo(N1),
   nodo(N1)::_/Role::indice::SnW,
   SnW \= SnY,
   SnW \= SnX,
   nodo(N1)::_/Role::pred::Pred,
   Pred\=P,
   !,
    (proprieta_sempl(Id,Pred)
      ->
     fail, !;
     true),
   getindexcoord(SnX,SnZ),
   creater_coo(NoFr, set, [], SnZ, Pred, 3, _, _, Idx, Temp, Loc),
   asserisci_infon(Type, Class, 1, _, NoFr, SnW, Pred, Idx, Temp, Loc),
   !.

coordinati2(Type, Class, NoFr, SnY, SnX, Idx, P, Loc, Temp) :-
   nodo(N)::Fun/Role::indice::SnX,
   nodo(_)::coordina::nodo(N),
   nodo(N)::Fun/Role::indice::SnW,
   SnW \= SnY,
   SnW \= SnX,
   nodo(N1)::indice::SnW,
   nodo(N1)::pred::Pred,
   Pred\=P,
    (proprieta_sempl(Id,Pred)
      ->
     fail, !;
     true),
   getindexcoord(SnX,SnZ),
   creater_coo(NoFr, set, [], SnZ, Pred, 3, _, _, Idx, Temp, Loc),
   asserisci_infon(Type, Class, 1, _, NoFr, SnW, Pred, Idx, Temp, Loc),
   !.

coordinati2(Type, Class, NoFr, SnY, SnX, Idx, P, Loc, Temp) :-
   getindexcoord(SnX,SnZ),
   creater_coo(NoFr, set, N, SnZ, Pred, 2, _, _, Idx, Temp, Loc),
   !.

getindexcoord(SnX,SnZ):-
   nodo(N)::Fun/Role::coordina::testa::coordinante,
   nodo(N)::Fun/Role::coordina::Fun/Role::indice::SnX,
   nodo(N)::Fun/Role::indice::SnZ,
   !.
asserisci_infon(Type, Class, Pol, Idx, NoFr, SnX, Pred, Ind, Temp, Loc) :-
 %  (Type=ind;Type=name),
   !,
   nodo(N1)::indice::SnX,
   nodo(N1)::spec::def::Def,
   notnodop(N1, spec, part),
   (var(Idx), gen_sym(id, Idx),
   asserisci(NoFr, SnX, ind(Idx)) 
     ;
    nonvar(Idx)),
   asserisci(NoFr, SnX, in(Idx,Ind)),
   (Def= '0', nonvar(Class), Class = -class,
   asserisci(NoFr, SnX, fact(name, [Pred, Idx], Pol, univ, univ))
    ;
   asserisci(NoFr,SnX,fact(isa,[ind:Idx,class:Pred],Pol,Temp, Loc)),
   asserisci( NoFr, SnX, fact(isa, [ind:Ind, class:Pred], Pol, Temp, Loc))
   ).
   
asserisci_infon(_, _, Pol, _, NoFr, SnX, Pred, Ind, Temp, Loc) :-
   asserisci( NoFr, SnX, fact(isa, [ind:Ind, class:Pred], Pol, Temp, Loc)).

individua_controllato(IdSn, Ind, Temp, Loc):-
   catena(IdSn, IdSn2, F/Role, N),
   !,
   restr_pred(N, IdSn2, Ind, F/Role, Temp, Loc).
individua_controllato(_, _, _, _).

catena(IdController, IdControllee, FuncRole, NodoControllato) :-
   (
   nodo(N)::controllore::IdController
   ;     
   nodo(N)::antecedente::IdController
   ),    
   nodo(N)::indice::CurControllee,
   nodo(N)::pred::Pred,  
   (
   Pred=pPro
   ;
   Pred=pro
   ),
   nodo(CurControlleeNode)::CurFuncRole::indice::CurControllee,
   catena1(
      CurFuncRole, CurControllee, CurControlleeNode, 
      FuncRole, IdControllee, NodoControllato).

/************
catena1(+CurrentControlleeFuncRole, +CurrentControllee, 
   +CurrentControlleeNode, -ControlleeFuncRole,-Controllee,-ControlleeNode)   
*************/
catena1(
   sogg/Role, Controllee, ControlleeNode, 
   sogg/Role, Controllee, ControlleeNode)
   :-
   (Role=tema_bound;Role=theme_bound),!.

catena1(
   topic, Controller, _, 
   FuncRole, Controllee, ControlleeNode)
   :-
   catena(Controller, Controllee, FuncRole, ControlleeNode).


/******************
individua_antecedente(IdentSintagma, IdentIndividuo)
*******************/

individua_antecedente(IdSn, Ind, Card, Card1) :-
   nodo(N)::indice::IdSn,
   nodo(N)::pred::Pred,
   frase_corrente(NoFr, _),  
   1<NoFr,risolto(NoFr,_,Pred,PredAntec),
   has_prop(Ind, PredAntec),
   main_or_expect(NoFr, Ind),
   match_card(Ind, Card, Card1),
   !.

individua_antecedente(IdSn, Ind, Card, Card1) :-
   nodo(N)::indice::IdSn,
   nodo(N)::pred::Pred,  
   proprieta_rec(Ind,Pred),
   has_prop(Ind, PredAntec),
%   main_or_expect(NoFr, Ind),
   match_card(Ind, Card, Card1),
   !.

individua_antecedente(IdSn, Ind, Card, Card1) :-
   segui_catena_di_controllo(IdSn, IdSn1),
   nodo(N1)::indice::IdSn1,
   nodo(N1)::pred::Pred,  
   frase_corrente(NoFr, _),
   1<NoFr,
   risolto(NoFr,_,Pred,PredAntec),
   ( main_or_expect(NoFr, Ind);
    proprieta_rec(Ind,PredAntec);
    has_prop(Ind, PredAntec)),
   match_card(Ind, Card, Card1),
   !.

individua_antecedente(IdSn, Ind, Card, Card1) :-
   segui_catena_di_controllo(IdSn, IdSn1),
   nodo(N1)::indice::IdSn1,
   nodo(N1)::pred::Pred,  
   proprieta_rec(Ind,Pred),
   has_prop(Ind, PredAntec),
%   main_or_expect(NoFr, Ind),
   match_card(Ind, Card, Card1),
   !.

match_card(Ind, nil, Card1):-
   integer(Card1),
   (card(_,Ind,Car)
    ;
    card(_,Ind,Card1)),!.

match_card(Ind, Card, Card1):-
   (var(Card);Card=nil),
   card(_,Ind,Card1),!.

match_card(Ind, Card, Card1):-
     nonvar(Card), Card=some,
     card(_,Ind,Card1),!.

match_card(Ind, Card, Card1):-
     integer(Card),
     card(_,Ind,Card),!.

match_card(Ind, Card, Card1):-
     integer(Card1),
     card(_,Ind,Card1),!.

match_card(Ind, Card, Card1):-
     integer(Card),
     in(_,Ind,Ind1),
     card(_,Ind1,Card), Card1=1,
     !.

match_card(Ind, nil, Card1):-
   ind(_,Ind), Card1=1,
   !.

match_card(Ind, 1, Card1):-
   ind(_,Ind),
   !.

asserisci_lista_res(NoFr, Type, N, Cat, [],_,_,_,_).
asserisci_lista_res(NoFr, isa, N, Cat, [Rel|Altre], SnX, Ind, Temp, Loc) :-
   class_props(NoFr, SnX, Cat, Id, fact, isa, Rel, 1, Temp, Loc),
   asserisci_lista_res(NoFr, mod, N, Cat, Altre, SnX, Ind, Temp, Loc),!.

asserisci_lista_res(NoFr, mod, N, Cat, [Rel|Altre], SnX, Ind, Temp, Loc) :-
   (Type=isa, 
   class_props(NoFr, SnX, Cat, Id, fact, isa, Rel, 1, Temp, Loc)
   ;
   rcs(Rel,Id),nonvar(Id)
   ;
   (Rel=specie; Rel=tipo; Rel=kind; Rel=type) 
   ;
    (proprieta_sempl(Id,Rel)
      ->
     fail, !;
     true),
   asserisci(NoFr, SnX, fact(Rel, [ind:Ind], 1, Temp, Loc)),
   asserta(rcs(Rel,Ind))
   ),
   asserisci_lista_res(NoFr, mod, N, Cat, Altre, SnX, Ind, Temp, Loc),!.

asserisci_lista_res(NoFr, Type, N, Cat, [Rel|Altre], SnX, Ind, Temp, Loc) :-
    recover_description(Rel, Pred),
    Pred\=Rel,
    asserisci_lista_res(NoFr, mod, N, Cat, Pred, SnX, Ind, Temp, Loc),
    asserisci_lista_res(NoFr, adj, N, Cat, Altre, SnX, Ind, Temp, Loc),!.

asserisci_lista_res(NoFr, Type, N, Cat, [Rel|Altre], SnX, Ind, Temp, Loc) :-
   asserisci_proprieta_relazioni(Ind,Rel,NoFr,Id),nonvar(Id),
   asserta(rcs(Rel,Id)),
   asserisci_lista_res(NoFr, adj, N, Cat, Altre, SnX, Ind, Temp, Loc),!.

asserisci_lista_ruoli(NoFr,[],_,_,_,_,_):-!.
asserisci_lista_ruoli(NoFr,[Rel|Altre], SnX, Ind, Loc, Temp, Id) :-
   creatert(NoFr, ind, _, SnX, Rel, _, _, _, Id, Temp, Loc),
   class_props(NoFr, SnX, Cat, Id, fact, isa, Rel, 1, Temp, Loc),
   asserisci(NoFr, SnX, fact(role, [Rel,Ind,Id], 1, Temp, Loc)),
   asserisci_lista_ruoli(NoFr,Altre, SnX, Ind, Loc, Temp, Id),!.

read_model :-
    abolish(entities_of_the_world/1),
    abolish(discourse_structures/1),
    dynamic(entities_of_the_world/1),
    dynamic(discourse_structures/1),
    consult(conv).

sh_write_world(Text,Text-SSents) :-
   sh_assert_entities_relevance(Ents),
   sh_sorted_entities(Ents, SortedEnts),
   write_riass_sh(Text,SortedEnts, Sents),
   append([SortedEnts],[Sents], SSents).


write_riass_sh(T,SortedEnts, SEnts):-
   select_alltopics(SortedEnts, Ents),
   nl,nl,
   write('############'),
   write('   400 WORDS SUMMARY   '),
   writenl('############'),
   append([1],Ents,NEnts),
   sort(NEnts,Nents),
   writeriass(T,Nents,0, SEnts).

write_riass(T,SortedEnts, SEnts):-
   select_alltopics(SortedEnts, Ents),
   nl,nl,
   write('############'),
   write('   400 WORDS SUMMARY   '),
   writenl('############'),
   append([1],Ents,NEnts),
   sort(NEnts,Nents),
   writeriass(T,Nents,0, SEnts).

select_alltopics([Score-Ent1, Scor-Ent2, Sco-Ent3|SortedEnts], Ents):-
    select_topics([Score-Ent1, Scor-Ent2, Sco-Ent3], Sents),
    appiattisci(Sents, Ents),
    !.
select_topics([], []):-!.
select_topics([Score-Ent|SortedEnts], [Ents|All]):-
   atomic(Ent),
   findall(N, 
            topps(Top, N, Ent, Ind,_), Ents),
   select_topics(SortedEnts, All),
    !.

select_topics([Score-Ents|SortedEnts], AllEnts):-
   list(Ents),
   remove(Ent, Ents, Entss),
   select_topics([Score-Ent, Score-Entss|SortedEnts], AllEnts),
    !.

writeriass(T,[],N, []):-!.
writeriass(T,[0|Ents],N, SEnts):-
   writeriass(T,Ents,N, SEnts).
writeriass(T,[I|Ents],N, [Frase|SEnts]):-
   N =< 400,
   crea_sym(T,I,Sym),
   fp(Sym, Frase),
   length(Frase, L),
   L1 is L - 1,
   scrivi_riass(Frase),
   Nn is N + L1,
   writeriass(T,Ents,Nn, SEnts).

writeriass(T,[I|Ents],N, [Frase|SEnts]):-
   I=1,
   crea_sym(T,1,Sym),
   fp(Sym, Frase),
   scrivi_riass(Frase),
   stringof(Num, Sym),
   reverse(Num, [Nu|_]),
   pname(Nn, Nu),
   writenriass(T,Nn,Ents,Nn, SEnts).

writeriass(T,Ents,Nn, []).

writenriass(T,L,[I|Ents],N, [Frase|SEnts]):-
   N =< 400,
   crea_sym(T,I,Sym),
   fp(Sym, Frase),
   length(Frase, Le),
   scrivi_riass(Frase),
   L1 is Le - 1,
   Nn is N + L1,
   writenriass(T,Ll,Ents,Nn, SEnts).
writenriass(T,L,Ents,Nn, []).

writenriass(T,L,[],N, []):-!.
writenriass(T,L,[L|Ents],N, [Frase|SEnts]):-
   N =< 400,
   Ll is L + 1,
   crea_sym(T,Ll,Sym),
   fp(Sym, Frase),
   length(Frase, Le),
   scrivi_riass(Frase),
   L1 is Le - 1,
   Nn is N + L1,
   writenriass(T,Ll,Ents,Nn, SEnts).

pwritenriass(L,[],N):-!.
pwritenriass(L,[L|Ents],N):-
   N =< 400,
   Ll is L + 1,
   check_sym(L,Sym),
   fp(Sym, Frase),
   length(Frase, Le),
   scrivi_riass(Frase),
   L1 is Le - 1,
   Nn is N + L1,
   pwritenriass(L1,Ents,Nn).

pwritenriass(L,[I|Ents],N):-
   N =< 400,
   check_sym(I,Sym),
   fp(Sym, Frase),
   length(Frase, Le),
   scrivi_riass(Frase),
   L1 is Le - 1,
   Nn is N + L1,
   pwritenriass(L1,Ents,Nn).
pwritenriass(L,Ents,[]).

pwriteriass([],N):-!.
pwriteriass([0|Ents],N):-
   pwriteriass(Ents,N).
pwriteriass([I|Ents],N):-
   N =< 400,
   check_sym(I,Sym),
   fp(Sym, Frase),
   length(Frase, L),
   L1 is L - 1,
   scrivi_riass(Frase),
   Nn is N + L1,
   pwriteriass(Ents,Nn).

pwriteriass([I|Ents],N):-
   I=1,
   fp(I, Frase),
   scrivi_riass(Frase),
   Nn is N + 1,
   pwritenriass(Nn,Ents,Nn).

pwriteriass(Ents,[]).

crea_sym(T,L,Sym):-
   mcon(T, '_', Sy),
   mcon(Sy, L, Sym),
   !.

scrivi_riass(Frase):-
    concat_atom(Frase,' ',Atomo),
    writenl('user', Atomo).

sh_assert_entities_relevance(Ents):-
   findall(Ent-Top-Ind, 
            topps(Top, N, Ent, Ind,_), Ents).

sh_sorted_entities(Ents, NSortedEnts):-
   sort(Ents, SortInds, [2], 1),
   score_sorted_ents(SortInds, SortedEnts),
   summ_up_unders(SortedEnts, NSortedEnts). 

score_sorted_ents(SortInds, SortScoreInds):-
   score_sortedents(SortInds, Ent, 0, ScoreInds),
   sort(ScoreInds, SortScores),
   reverse(SortScores, SortScoreInds),
   !.

score_sortedents([], Ent, Score, []):-!.
score_sortedents([Ent-Top-I|SortInds], Ent, Score, SortScoreInds):-
    (Top=main, Sco=3; Top=second, Sco=2),
    Score1 is Score + Sco,
   score_sortedents(SortInds, Ent, Score1, SortScoreInds),
   !.

score_sortedents([Ent-Top-I|SortInds], Ent1, Score, [Score-Ent1|SortScoreInds]):-
   score_sortedents([Ent-Top-I|SortInds], Ent, 0, SortScoreInds),
   !.

p_assert_entities_relevance(Ents):-
   findall(Ind-Type-NoFr, 
               confer_topic(NoFr, Type, Ind, _, PropNode), Ents).

p_write_world(Text,Core) :-
   p_assert_entities_relevance(Ents),
   p_sorted_entities(Ents, SortedEnts),
   pwrite_riass(SortedEnts, Sents),
   !.
p_write_world(Text,Core) :-
   !.
   
pwrite_riass(SortedEnts, Ents):-
   find_all_top_sents(SortedEnts, 0, Ents),
   dangling_sentences(Ents, Entss),
   nl,nl,
   write('############'),
   write('   400 WORDS SUMMARY   '),
   writenl(_,'############'),
   append([1],Entss,NEnts),
   sort(NEnts,Nents),
   (Nents=[0|Rest];Rest=Nents),
   pwriteriass(Rest,1).

p_sorted_entities([], []):-!.
p_sorted_entities(Ents, SortedEnts):-
   sort(Ents, SortInds, [2], 1),
   p_sorted_ents(SortInds, SortedEnts). 

p_sorted_ents(SortInds, SortScoreInds):-
   p_sortedents(SortInds, Ent, 0, ScoreInds),
   sort(ScoreInds, SortScores),
   reverse(SortScores, SortScoreInds),
   !.

p_sortedents([], Ent, Score, []):-!.
p_sortedents([nil-Top-I|SortInds], Ent, Score, SortScoreInds):-
    p_sortedents(SortInds, Ent, Score, SortScoreInds),
   !.
p_sortedents([Ent-Top-I|SortInds], Ent, Score, SortScoreInds):-
    in_topic_score(Ent, Top, Sco),
    Score1 is Score + Sco,
    p_sortedents(SortInds, Ent, Score1, SortScoreInds),
   !.

p_sortedents([Ent-Top-I|SortInds], Ent1, Score, [Score-Ent1|SortScoreInds]):-
   p_sortedents([Ent-Top-I|SortInds], Ent, 0, SortScoreInds),
   !.

in_topic_score(Ind, Top, TotalScore) :-
   findall(
      Score,
      ind_topic_score(Ind, Top, Score),
      AllScores
   ),
   sommatoria(AllScores,TotalScore,_).

ind_topic_score(Ind, Top, Score) :-
   topic_score(Top, Score).

ind_topic_score(Ind, Top, Score) :-
   in(_, Ind, Set),
   cardinality(Ind, CardInd),
   cardinality(Set, CardSet),
   entity_relevance(Type, Set, Relevance),
   Score is Relevance*CardInd/CardSet.


write_model(Text,Core) :-
   write_world,
   nl,nl.
%   pwrite_charac,
%   p_write_world(Text,Core).

write_disc :-
   findall(NoFr-NoCl-At-Topics-SimpMainRel-TempRel-DiscRel-Point, disc_struc(At, NoFr-NoCl, Topics, SimpMainRel, Tint, TempRel, DiscRel, Strc, SimplDiscDom, Point), Ds),
   writedss(Ds).

writedss([]):- !.

writedss([NoFr-NoCl-At-Topics-SimpMainRel-TempRel-DiscRel-Strc|Dss]):-
   Dss=[],
   writeq(ds(At, NoFr-NoCl, Topics, SimpMainRel, TempRel, DiscRel, Strc)),
   writedss(Dss),
   !.

writedss([NoFr-NoCl-At-Topics-SimpMainRel-TempRel-DiscRel-Strc|Dss]):-
   Dss\=[],
   writeq(ds(At, NoFr-NoCl, Topics, SimpMainRel, TempRel, DiscRel, Strc)),
   write(','),
   nl,
   writedss(Dss),
   !.

write_world :-
   abolish(entity_relevance/3),
   assert(entity_relevance(nil,nil,nil)),
   assert_entities_relevance,
   sorted_entities(SortedEnts),
   write_sets(SortedEnts),
   write_individuals(SortedEnts),
   write_class(SortedEnts).

assert_entities_relevance :-
   entity(Type, Ind),
   individual_relevance_score(Ind, Score),
   assert(entity_relevance(Type, Ind, Score)),
   fail.
assert_entities_relevance.

entity(set, Ind) :-
   set(_,Ind).

entity(ind, Ind) :-
   ind(_,Ind).

entity(ind, Ind) :-
   ent(_,Ind).
 
entity(ind, Ind) :-
   loc(_,Ind,_).

entity(class, Ind) :-
%   genre(legal),
   class(_,Ind).
 
/*
overlap(A,B).
finished_by(A,B).
before(A,B).
after(A,B).
contains(A,B).
started_by(A,B).
during(A,B).
*/

write_class([]) :- !.

write_class(Entities) :-
   remove(Score-Ind-class, Entities, []),
   nonvar(Ind),
   class(Infon, Ind),
   entity_write(class, Score, Ind),
   write_class(SortedEnts).

write_class(Entities) :-
   remove(Score-Ind-class, Entities, SortedEnts),
   nonvar(Ind),
   SortedEnts\=[],
   class(Infon, Ind),
   entity_write(class, Score, Ind),
%   writenl(','),
   write_class(SortedEnts).

write_class(_).

/*
write_class :-
   class(_,Set),
   Set\=nil,
   write('entity('), 
   write('class'),
   write(','),
   write(Set),
   write(','),
   write(Score),
   write(','),
   write('facts'),
   write('('),
   writenl('['),
   find_facts(set, Ind),
   fail.
write_class.
*/

write_sets([]) :- !.

write_sets(Entities) :-
   remove(Score-Ind-set, Entities, []),
   nonvar(Ind),
   set(Infon, Ind),
   entity_write(set, Score, Ind),
   write_sets(SortedEnts).

write_sets(Entities) :-
   remove(Score-Ind-set, Entities, SortedEnts),
   nonvar(Ind),
   SortedEnts\=[],
   set(Infon, Set),
   entity_write(set, Score, Ind),
%   writenl(','),
   write_sets(SortedEnts).

write_sets(_).

entity_write(Type, Score, nil):-!.
entity_write(Type, Score, Ind):-
   write('entity('), 
   write(Type),
   write(','),
   write(Ind),
   write(','),
   write(Score),
   write(','),
   write('facts'),
   write('('),
   write('['),nl,
   find_facts(Type, Ind).
   
write_individuals([]) :- !.

write_individuals(Entities) :-
   remove(Score-Ind-ind, Entities, []),
   nonvar(Ind),
   entity_write(ind, Score, Ind),
   write_individuals(SortedEnts).

write_individuals(Entities) :-
   remove(Score-Ind-ind, Entities, SortedEnts),
   nonvar(Ind),
   SortedEnts\=[],
   entity_write(ind, Score, Ind),
%   writenl(','),
   write_individuals(SortedEnts).

write_individuals(_).

removenil(Facts, Nfacts):-
   remove_all(0-nil-_, Facts, Nfact),
   remove_all(nil-nil-_, Nfact, Nfacts).
removenil(Facts, Nfacts):-
   remove_all(0-nil-_, Facts, Nfact).
removenil(Facts, Nfacts):-
   remove_all(nil-nil-_, Nfact, Nfacts).

removenil(Facts, Facts):-!.

find_facts(ind, Ind) :-
   findall(Fact, ind_in_infon(Ind, Fact), Factss),
   sort(Factss,Facts),
   write_facts(Facts).

find_facts(set, Ind) :-
   findall(Fact, set_in_infon(Ind, Fact), Factss),
   sort(Factss,Facts),
   write_facts(Facts).

find_facts(class, Ind) :-
   findall(Fact, set_in_infon(Ind, Fact), Factss),
   sort(Factss,Facts),
   write_facts(Facts).

write_facts([]) :-!.

write_facts([Fact|Facts]) :-
   Facts=[],
   writeq(Fact),
   write(']'),
   write(')'),
   write(')'),
   write(.),nl.
   
write_facts([Fact|Facts]) :-
   Facts\=[],
   writeq(Fact),
   write(,),nl,
   write_facts(Facts).

sorted_entities(SortedScoreInds) :-
   findall(
      Relev-Indiv-Type,
      entity_relevance(Type, Indiv, Relev),
      ScoreInds
   ),
   removenil(ScoreInds, NScoreInds),
   sort(NScoreInds, SortScoreInds, [2], 1), 
   togli_doppi(SortScoreInds, SortedScoreInds).

call_fact_in(Ind,Infon):-
   fact(Infon, Rel, Args, Pol, Temp, Loc),
   ind_on(Ind, Args).
call_sit_in(Ind,Infon):-
   sit(Infon, Rel, Args, Pol, Temp, Loc),
   ind_on(Ind, Args).

ind_in_infon(Ind, in(Infon,Ind,Set)) :-
   in(Infon,Ind,Set).

ind_in_infon(Ind, fact(Infon, coincide, Args, Pol, Temp, Loc)) :-
   call_fact_in(Ind,Id),
   fact(Infon, coincide, Args, Pol, Temp, Loc),
   ind_on(Id, Args).

ind_in_infon(Ind, sit(Infon, coincide, Args, Pol, Temp, Loc)) :-
   call_sit_in(Ind,Id),
   sit(Infon, coincide, Args, Pol, Temp, Loc),
   ind_on(Id, Args).

ind_in_infon(Ind, fact(Infon2, Re, Args2, Po, Te, Lo)) :-
   fact(Infon, Rel, Args, Pol, Temp, Loc),
   ind_on(Ind, Args),
   fact(infon1, R, Args1, P, T, L),
   on(prop:Infon2,Args1),
   fact(Infon2, Re, Args2, Po, Te, Lo),
   ind_on(Rel, Args1).

ind_in_infon(Ind, fact(Infon, Rel, Args, Pol, Temp, Loc)) :-
   fact(Infon, Rel, Args, Pol, Temp, Loc),
   ind_on(Ind, Args).

ind_in_infon(Ind, sit(Infon, Rel, Args, Pol, Temp, Loc)) :-
   sit(Infon, Rel, Args, Pol, Temp, Loc),
   ind_on(Ind, Args).

ind_in_infon(Ind, fact(Infon2, Rel2, Args2, Pol2, Temp2, Loc2)) :-
   fact(Infon, Rel, Args, Pol, Temp, Loc),
   ind_on(Ind, Args),
   fact(Infon1, Rel1, Args1, Pol1, Temp1, Loc1),
   on(prop:Infon2,Args1),
   ind_on(Infon, Args1),
   fact(Infon2, Rel2, Args2, Pol2, Temp2, Loc2).

ind_in_infon(Ind, fact(Infon1, Rel1, Args1, Pol1, Temp1, Loc1)) :-
   fact(Infon, Rel, Args, Pol, Temp, Loc),
   ind_on(Ind, Args),
   fact(Infon1, Rel1, Args1, Pol1, Temp1, Loc1),
   on(prop:Infon2,Args1),
   ind_on(Infon, Args1).

ind_in_infon(Ind, sit(Infon, Rel, Args, Pol, Temp, Loc)) :-
   sit(Infon, Rel, Args, Pol, Temp, Loc),
   ind_on(Ind, Args).


ind_in_infon(Ind, fact(Infon, Rel, Arg, 1, Temp, Loc)) :-
   loc(Infon,Ind,Facts),
   Facts=[arg:Rel, arg:Arg],
   (Rel=main_tloc, 
    (Arg=tes(_);Arg=tr(_);Arg\=tr(_),Arg\=tes(_)), 
     Temp=Arg,!
    ;
    Rel\=main_tloc,Temp=univ),!.

ind_in_infon(Ind, fact(*, Rel, NewArgs, Pol, Temp, Loc)) :-
   in(_,Ind,Set),
   fact(Infon, Rel, Args, Pol, Temp, Loc),
   ind_on(Set, Args),
   replace_ind(Set, Ind, Args, NewArgs).

ind_in_infon(Ind, sit(*(Infon), Rel, NewArgs, Pol, Temp, Loc)) :-
   in(_,Ind,Set),
   sit(Infon, Rel, Args, Pol, Temp, Loc),
   ind_on(Set, Args),
   replace_ind(Set, Ind, Args, NewArgs).



set_in_infon(Set1, in(Infon,Set1,Set2)) :-
   in(Infon,Set1,Set2).

set_in_infon(Set, card(Infon, Set, Card)) :-
   card(Infon, Set, Card).

set_in_infon(Ind, fact(Infon1, R, Args1, P, T, L)) :-
   fact(Infon, Rel, Args, Pol, Temp, Loc),
   ind_on(Ind, Args),
   fact(Infon1, R, Args1, P, T, L),
   Args1=[A],
   ind_on(Rel, Args1).
   
set_in_infon(Ind, fact(Infon2, Re, Args2, Po, Te, Lo)) :-
   fact(Infon, Rel, Args, Pol, Temp, Loc),
   ind_on(Ind, Args),
   fact(infon1, R, Args1, P, T, L),
   on(prop:Infon2,Args1),
   fact(Infon2, Re, Args2, Po, Te, Lo),
   ind_on(Rel, Args1).

set_in_infon(Set, fact(Infon, Rel, Args, Pol, Temp, Loc)) :-
   fact(Infon, Rel, Args, Pol, Temp, Loc),
   ind_on(Set, Args).

set_in_infon(Set, sit(Infon, Rel, Args, Pol, Temp, Loc)) :-
   sit(Infon, Rel, Args, Pol, Temp, Loc),
   ind_on(Set, Args).

set_in_infon(Set, fact(*, Rel, NewArgs, Pol, Temp, Loc)) :-
   in(_,Set,Set1),
   fact(Infon, Rel, Args, Pol, Temp, Loc),
   ind_on(Set1, Args),
   replace_ind(Set1, Set, Args, NewArgs).

set_in_infon(Set, sit(*(Infon), Rel, NewArgs, Pol, Temp, Loc)) :-
   in(_,Set,Set1),
   sit(Infon, Rel, Args, Pol, Temp, Loc),
   ind_on(Set1, Args),
   replace_ind(Set1, Set, Args, NewArgs).
   
replace_any(_, _, [], []):-
   !.

replace_any(El, El1, [El|List], [El1|RepList]):-
   !,
   replace_any(El, El1,List,RepList).

replace_any(El, El1, [El2|List], [El2|RepList]):-
   replace_any(El, El1,List,RepList).


individual_relevance_score(Ind, TotalScore) :-
   findall(
      Score,
      individual_score(Ind, _, Score),
      AllScores
   ),
   sommatoria(AllScores,TotalScore,_).

individual_score(Ind, NoFr, Score) :-
   prop_relevance(Ind, NoFr, TopicType, PropRelevance),
   relevance_score(PropRelevance, TopicType, Score).  

individual_score(Ind, NoFr, Score) :-
   in(_, Ind, Set),
   cardinality(Ind, CardInd),
   cardinality(Set, CardSet),
   entity_relevance(Type, Set, Relevance),
   Score is Relevance*CardInd/CardSet.

cardinality(Ind, 1) :-
   ind(_, Ind),
   !.
cardinality(Set, Card) :-
   set(_, Set),
   card(_, Set, Card),
   integer(Card),
   !.
cardinality(_, 10).

/*
prop_relevance(Ind, NoFr, Type, Relevance) :-
   confer_topic(NoFr, Type, Ind, _, PropNode),
   info(NoFr, PropNode, _, _, _, _, Relevance, _, _, _, _, _, _).
*/
prop_relevance(Ind, NoFr, Type, undefined) :-
   confer_topic(NoFr, Type, Ind, _, _).
   


%relevance_score(_, undefined, 0) :-!.
relevance_score(foreground, TopicType, Score) :-
   !,
   topic_score(TopicType, Score1),
   Score is Score1*2.

relevance_score(_, TopicType, Score) :-
   topic_score(TopicType, Score).


ind_on(Ind, Args) :-
   nonvar(Ind),
   once(nogen_member(Ind, Args)).
 
ind_on(Ind, Args) :-
   nonvar(Ind),
   once(nogen_member(_:Ind, Args)).
 
/*
:-replace_ind(a, b, [p:a,f],K)
*/

replace_ind(Ind1, Ind2, [Ind | Inds1], Inds2) :-
   atomic(Ind),
   !,
   replace_any(Ind1, Ind2, [Ind | Inds1], Inds2).

replace_ind(Ind1, Ind2, Inds1, Inds2) :-
   replace_any(Role:Ind1, Role:Ind2, Inds1, Inds2).

save_model :-
   new(File, 'Save data file', 'Model Name'),
   tsave(File, ['conv']),
   concat(File, '.txt', NFile),
   tsave(NFile, ['Model']).

remove_valenz(Valenz,Ruolo):-
     list(Valenz), remove(obj-Ruolo, Valenz, Valenza),!.

remove_valenz(Valenz,Ruolo):-
     Valenz=obj-Ruolo,!.

maximise_functions(Valenzes, Valenzz):-
   reffunctions(Args),
   evaluate_subcats(Args, Valenzes, Subs),
   sort(Subs, Sub),
   reorder_subs(Sub, Valen),
   reverse(Valen, Valenz),
   s_estrai_valenz_list(Valenz,Valenzz),
   !.


modality(may, possible).
modality(cannot, must).
modality(will, know).
modality(would, possible).
modality('wouldn-t_', believe).
modality(could, believe).
modality(can, know).
modality('can-t_', know).
modality('couldn-t_', believe).
modality('won-t_', know).
modality(might, possible).
modality(ought, believe).
modality(must, must).
modality('mustn-t_', must).
modality(should, believe).
modality('shouldn-t_', believe).
modality(shall, believe).
modality('shan-t_', believe).
modality(has_to, must).
modality(had_to, must).
modality(wish, desire).
modality(want, desire).
modality(like, desire).
modality(desire, desire).

modality(Modal,believe).

relassert_performatives(NoFr, Infon, TimeId, LocId):-
  Infon=..[Con,Main],
  list(Main),
  Main=[A|Rest],
  list_relassert_performative(NoFr, Main, TimeId, LocId),
  !.

relassert_performatives(NoFr, Infon, TimeId, LocId):-
  relassert_performative(NoFr, Infon, TimeId, LocId),
  !.

relassert_performatives(NoFr, Infon, TimeId, LocId):-!.

list_relassert_performative(NoFr, [], TimeId, LocId):-!.
list_relassert_performative(NoFr, [First|Main], TimeId, LocId):-
  relassert_performative(NoFr, First, TimeId, LocId),
  list_relassert_performative(NoFr, Main, TimeId, LocId),
  !.

relassert_performative(NoFr, Infon, TimeId, LocId):-
  Infon=..[I,Q,InfonId,Rel,Main, R, Pol],
  assert_modality(NoFr, Rel, InfonId, LocId, TimeId),
  assert_performative(NoFr, Rel, InfonId, LocId, TimeId),
  !.
relassert_performative(NoFr, Infon, TimeId, LocId).

historylist(NoFr, Tops, Mods, [], [],[], []) :-
   !.

historylist(NoFr, Tops, Mods, Args, NArgs,Inds,Rels) :-
   abolish(frase_corrente/2),
   asserta(frase_corrente(NoFr, File)),
   Args\=[],
   Tops=[Main-F0, Second-F1, Pot-F2, Ante],
   analyze_history(Ante, NoFr, Mods, [Main, Second, Pot], [main,secondary,potential], Args, Args1, Inds),
   extract_mproperties(NoFr, Mods, Args, NArgs, Rels),
   newdiscorso(NoFr, NArgs),
   !.

analyze_history(Antes, NoFr, Mods, Tops, Type, Args, Args1, [Ind/SnX|Inds]):-
    Antes\=[],
     on(Ante-Top, Antes),
     on(ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role)/P, Args),
     on(Ante,Tops),
    Altro=ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role),
    Tab=[Ref, Def, Part, Card, Pro, Ana, Class],
    Pro = +pro,
    remove(ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role)/P, Args, Args1),
    Top\=nil,
    ( 
    Antes\=[],
     on(Ante-Top, Antes),
     mcoreference(NoFr, Ante, Id),
     bridging_expression(SnX, NoFr, Id, Ante, Altro, Ind)
     ;
     Top=you, Ante=customer,
     mcoreference(NoFr, Ante, Id),
     bridging_expression(SnX, NoFr, Id, Ante, Altro, Ind)
     ;
    (Top=we,
     legalptopic(NoFr, Altro, SnX, Arg),
     asserta(risolto(NoFr, SnX, narrator, Top))
     ;
      F\=sogg, F\=ogg, F\=subj, F\=obj,
      risolvi_pronomi_interni(Altro, Args1, Ante),
      legalptopic(NoFr, Altro, SnX, Arg),
      asserta(risolto(NoFr, SnX, Ante, Top))
      ;
      (F=sogg; F=ogg; F=subj; F=obj),
     legalptopic(NoFr, Altro, SnX, Arg),
     asserta(risolto(NoFr, SnX, indefinite, Top))),
     history_crea_arg(Arg, Mods, Ind)),
    recover_type(NoFr, SnX, Top, NType),
    shasserisci_topic(NoFr, NType, Ind, SnX),
    analyze_history(Antes, NoFr, Mods, Tops, Typ, Args1, Args2, Inds),
    !.

analyze_history(Antes, NoFr, Mods, [Top|Tops], [Type|Typ], Args, Args1, [Ind/SnX|Inds]):-
     Top\=nil, 
     Args\=[],
     on(ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role)/P, Args),
    Altro=ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role),
    Tab=[Ref, Def, Part, Card, Pro, Ana, Class],
    Pro = +pro,
    remove(ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role)/P, Args, Args1),
    Top\=nil,
    ( 
    Antes\=[],
     on(Ante-Top, Antes),
     mcoreference(NoFr, Ante, Id),
     bridging_expression(SnX, NoFr, Id, Ante, Altro, Ind)
     ;
     Top=you, Ante=customer,
     mcoreference(NoFr, Ante, Id),
     bridging_expression(SnX, NoFr, Id, Ante, Altro, Ind)
     ;
    (Top=we,
     legalptopic(NoFr, Altro, SnX, Arg),
     asserta(risolto(NoFr, SnX, narrator, Top))
     ;
      F\=sogg, F\=ogg, F\=subj, F\=obj,
      risolvi_pronomi_interni(Altro, Args1, Ante),
      legalptopic(NoFr, Altro, SnX, Arg),
      asserta(risolto(NoFr, SnX, Ante, Top))
      ;
      (F=sogg; F=ogg; F=subj; F=obj),
     legalptopic(NoFr, Altro, SnX, Arg),
     asserta(risolto(NoFr, SnX, indefinite, Top))),
     history_crea_arg(Arg, Mods, Ind)),
    recover_type(NoFr, SnX, Top, NType),
    shasserisci_topic(NoFr, NType, Ind, SnX),
    analyze_history(Antes, NoFr, Mods, Tops, Typ, Args1, Args2, Inds),
    !.

analyze_history(Antes, NoFr, Mods, [Top|Tops], [Type|Typ], Args, Args1, [Ind/SnX|Inds]):-
    remove(ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role)/P, Args, Argss),
    Tab=[Ref, Def, Part, Card, Pro, Ana, Class],
    Def \= -def,
    Top\=nil, 
    (integer(Top), 1000 < Top
     ; \+ integer(Top)),
    mcoreference(NoFr, Top, Ind),
    recover_type(NoFr, SnX, Top, NType),
    shasserisci_topic(NoFr, NType, Ind, SnX),
    analyze_history(Antes, NoFr, Mods, Tops, Typ, Argss, Args1, Inds),
    !.

analyze_history(Antes, NoFr, Mods, Top, Type, Args, Argss, Inds):-
   analhistory(Antes, NoFr, Mods, Args, Inds),
   !.

history_crea_arg([SnX/NoFr,Testa,Def,Part,Card,Class,Num,Cat,F/R],Mods,Ind)
   :-  
    assert_all(NoFr,Cat,Mods,SnX,Testa,Def,Card,Part,Class,Num,Ind),!.

history_crea_arg([SnX/NoFr,Top,Def,Part,Card,Class,Num,Cat,F/R],Mods,Ind)
   :-  
    Def \= -def,
    Top\=nil, 
    (integer(Top), 1000 < Top
     ; \+ integer(Top)),
    mcoreference(NoFr, Top, Id),
    !.

analhistory(Ante, NoFr, Mods, [], []) :-!.
analhistory(Antes, NoFr, Mods, [Altro/P|Altri], [Ind/SnX|Inds]) :-
    Altro=ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role),
    Tab=[Ref, Def, Part, Card, Pro, Ana, Class],
    Pro = +pro,
    ( 
    Antes\=[],
     on(Ante-Top, Antes),
     mcoreference(NoFr, Ante, Id),
     bridging_expression(SnX, NoFr, Id, Ante, Altro, Ind)
     ;
     Top=you, Ante=customer,
     mcoreference(NoFr, Ante, Id),
     bridging_expression(SnX, NoFr, Id, Ante, Altro, Ind)
     ;
    (Top=we,
     legalptopic(NoFr, Altro, SnX, Arg),
     asserta(risolto(NoFr, SnX, narrator, Top))
     ;
      F\=sogg, F\=ogg, F\=subj, F\=obj,
      risolvi_pronomi_interni(Altro, Altri, Ante),
      legalptopic(NoFr, Altro, SnX, Arg),
      asserta(risolto(NoFr, SnX, Ante, Top))
      ;
      (F=sogg; F=ogg; F=subj; F=obj),
     legalptopic(NoFr, Altro, SnX, Arg),
     asserta(risolto(NoFr, SnX, indefinite, Top))),
     history_crea_arg(Arg, Mods, Ind)),
    recover_types(NoFr, SnX, Top, NType),
    shasserisci_topic(NoFr, NType, Ind, SnX),
    analhistory(Ante, NoFr, Mods, Altri, Inds),
    !.

analhistory(Ante, NoFr, Mods, [Altro/P|Altri], [Ind/SnX|Inds]) :-
    Altro=ref_ex(SnX,Top,Tab,_,Gen,Num,Cat,F/Role),
    Tab=[Ref, Def, Part, Card, Pro, Ana, Class],
    Def \= -def,
    Top\=nil, 
    (integer(Top), 1000 < Top
     ; \+ integer(Top)),
    mcoreference(NoFr, Top, Ind),
%    bridging_expression(SnX, NoFr, Id, Top, Altro, Ind),
    recover_types(NoFr, SnX, Top, NType),
    shasserisci_topic(NoFr, NType, Ind, SnX),
    analhistory(Ante, NoFr, Mods, Altri, Inds),
    !.
analhistory(Ante, NoFr, Mods, [Altro/P|Altri], [Ind/SnX|Inds]) :-
   legaltopic(NoFr, Altro, SnX, Arg),
     history_crea_arg(Arg, Mods,Ind),
    recover_type(NoFr, SnX, Top, NType),
   shasserisci_topic(NoFr, NType, Ind, SnX),
   dynamic(ref/1),
   analhistory(Ante, NoFr, Mods, Altri, Inds),
   !.
analhistory(Ante, NoFr, Mods, [Altro/P|Altri], Inds) :-
   analhistory(Ante, NoFr, Mods, Altri, Inds),
   !.
analhistory(_, _, _, _, _).

bridging_expression(SnX, NoFr, Id, Testa, Ref, Ind):-
  recover_recent_concepts(AllConc),
  on(Id-Testa1, AllConc),
  (Testa1=Testa, Ind=Id
  ;
   Testa1\=Testa,
   Ref=ref_ex(SnX,Testa,Tab,_,Gen,Num,Cat,F/Role),
   Tab=[R, Def, Quant, Card, _, _, Class],
   creatert(NoFr,class,Mods,SnX,Testa,Card,Quant,Num,Ind,univ, univ),
   class_props(NoFr, SnX, Cat, Ind, fact, isa, Testa, 1, univ, univ),
   asserisci(NoFr, SnX, in(Ind, Id))
   ),!.

bridging_expression(SnX, NoFr, Id, Testa, Ref, Id).

legaltopic(NF, X, SnX, Arg):-  
   X=..[ref_ex,SnX,Testa,Tab,_,Gen,Num,Cat,F/Role],
   (recover_descriptions(Testa, PredS),
      Testa1=PredS
      ;
      recover_description(Testa, PredS),
      Testa1=PredS),
   Testa \= pPro,
   Tab = [Ref, Def, Part, Card, Pro, _, Class],
   Ref = +ref, Pro = -pro,
   Testa \= vbl,
   F \= nil,
   Role \= misura,
   F/Role \= acomp/prop,
   F/Role \= nadj/theme,
   Role \= comparativa,
   Role \= esplicativa,
   nonvar(Cat),
   Arg=[SnX/NF, Testa1, Def, Part, Card, Class, Num, Cat, F/Role],
   !.
legalptopic(NF, X, SnX, Arg):-  
   X=..[ref_ex,SnX,Testa,Tab,_,Gen,Num,Cat,F/Role],
   (recover_descriptions(Testa, PredS),
      Testa1=PredS
      ;
      recover_description(Testa, PredS),
      Testa1=PredS),
   Testa\=pPro,
   Tab=[Ref, Def, Part, Card, Pro, _, Class],
   Ref = + ref,
   Testa \= vbl,
   F \= nil,
   Role \= misura,
   F/Role \= acomp/prop,
   F/Role \= nadj/theme,
   Role \= comparativa,
   Role \= esplicativa,
   nonvar(Cat),
   Arg=[SnX/NF, Testa1, Def, Part, Card, Class, Num, Cat, F/Role],
   !.

assert_all(NoFr,Cat,Mods,SnX,Testa,Def,Card,Part,Class,Num,Id):-
      shassert_names(NoFr,Cat,Mods,SnX,Testa,Card,Quant,Num,Id,univ, univ),
     !.
assert_all(NoFr,Cat,Mods,SnX,Testa,Def,Card,nil,Class,Num,Id):-
     define_card_num(Def, Card, Num, Type),
     shcreatert(NoFr,Type,Mods,SnX,Testa,Card,Quant,Num,Id,univ, univ),
   shdefault_properties(NoFr, Gen, SnX, Cats, Testa, Id,univ, univ),
   shasserisci(NoFr,SnX,fact(isa,[ind:Id,class:Testa],1,univ,univ)),
%     class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, univ, univ),
     !.
assert_all(NoFr,Cat,Mods,SnX,Testa,Def,Card,Part,Class,Num,Id):-
     Part\=nil,
     define_part_num(Def, Part, Card, Num, Type),
     shcreatert(NoFr,Type,Mods,SnX,Testa,Card,Quant,Num,Id,univ, univ),
   shdefault_properties(NoFr, Gen, SnX, Cats, Testa, Id,univ, univ),
   shasserisci(NoFr,SnX,fact(isa,[ind:Id,class:Testa],1,univ,univ)),
%     class_props(NoFr, SnX, Cat, Id, fact, isa, Testa, 1, univ, univ),
     !.

define_card_num(Def, Card, Num, set):-
     quantif(Card),!.
define_card_num(Def, Card, Num,  ind):-
     \+ zero(Def),!.    
define_card_num(Def, Card, Num,  Type):-
   Card\=nil,
   (Card=1, Type=ind
    ; 
     Num=plur, Type=set).

define_card_num(Def, nil, sing, class):-
     !.
define_card_num(Def, nil, plur, class):-
     !.

define_part_num(Def, Part, Card, Num, Type):-
         (Part= -part; Part= +part),
         converti_part(_,Part,Card),
         define_card_num(Def, Card, Num, Type),
         !.

define_part_num(Def, Part, Card, Num, Type):-
         Part\= -part, Part\= +part,
         converti_part(_,Part,Card),
         define_card_num(Def, Card, Num, Type),
         !.
define_part_num(Def, Part, Card, Num, Type):-
         define_card_num(Def, Card, Num, Type),
         !.
evaluate_properties(Id,Mods,NoFr,SnX,Resto, Ref, [], []):-
    Mods\=[], 
   Ref=ref_ex(SnX,Testa,Tab,_,Gen,Num,Cats,F/Role),
   Tab=[Re, Def, Quant, Card, _, _, Class],
   shcreatert(NoFr,class,[],SnX,Testa,Card,Quant,Num,Ind,univ, univ),
   shdefault_properties(NoFr, Gen,SnX, Cats, Pred, Ind,univ, univ),
   shasserisci(NoFr,SnX,fact(isa,[ind:Ind,class:Testa],1,univ,univ)),
   on(Mod, Mods),
   asserisci_proprieta(Ind,Mod,NoFr,SnY,Resto, NewRefs,NRefs),
   shasserisci(NoFr, SnX, in(Ind, Id)),
    !.
evaluate_properties(Id,Mods,NoFr,SnX,Resto, Ref, Pros, []):-
    Pros\=[], 
    on(Propp, Pros),
    fact(_,Propp,[nil:Id],1,_,_),
   Ref=ref_ex(SnX,Testa,Tab,_,Gen,Num,Cats,F/Role),
   Tab=[Re, Def, Quant, Card, _, _, Class],
   shcreatert(NoFr,class,[],SnX,Testa,Card,Quant,Num,Ind,univ, univ),
   shdefault_properties(NoFr, Gen, SnX, Cats, Pred, Ind,univ, univ),
   shasserisci(NoFr,SnX,fact(isa,[ind:Ind,class:Testa],1,univ,univ)),
   on(Mod, Mods),
   asserisci_proprieta(Ind,Mod,NoFr,SnY,Resto, NewRefs, NRefs),
   shasserisci(NoFr, SnX, in(Ind, Id)),
    !.

evaluate_properties(Id,Mods,NoFr,SnY,Resto, NewRefs, Pros, []):-
    Pros\=[], 
    on(Mod, Mods),
    asserisci_proprieta(Id,Mod,NoFr,SnY,Resto, NewRefs, NRefs),
    !.

evaluate_properties(Id,Mod,NoFr,SnY,Resto, NewRefs, Pros, Ps):-
    Pros\=[], 
    Ps\=[], 
    !.

find_restrict(Mods, Ind, Testa, Pros, Ps, Mod) :-
   setof(P, proprieta(Ind, P), PP),
   length(PP,L),
   (L=1, Mod=Mods
   ;
    1<L, remove(Testa, PP, Pros),
    (Pros=[]
    ;
     Pros\=[],
     intersezione(Pros,Mods,Ps),
     (Ps=[], Mod=Mods;
       Ps\=[], remove(Prop,Ps,Pss), remove(Prop,Mods,Mod))
     )),!.

updateCl(NoCl,PrevNoCl,NewNoCl):-
   (atomic(NoCl),NewNoCl is PrevNoCl + 1
    ;
    is_list(NoCl), length(NoCl,L),
    NewNoCl is PrevNoCl + L
    ;
    NewNoCl is PrevNoCl + 1
    ),
   !.

betterrelsrefs(AllPAS,AllRefs, Rels,WeightedRefs,AllRefss, PAS):-
   AllPAS=[PAS|RestDisc],
   WeightedRefs=[Pro,Top,Refss],
%   checkrefspas(RestDisc,PAS,AllRefs,Refss,AllR),
   convertunifyrefs(Refss,AllRefs,AllRefss),
%   appiattisci(AllR,AllRefss),
   !.
betterrelsrefs(AllPAS,AllRefs,Rels,WeightedRefs,AllRefs, Rels):-
   !.

convertunifyrefs(Refss,AllRefs,AllR):-
   convertunrefs(Refss,All),
   append(All,AllRefs,Alls),
   sort(Alls,AllR),
   !.

convertunrefs([],[]):-!.
convertunrefs([ref_ex(Ind,Pred,Tab,Pers,Gen,Num,Cat,F/Role)/N-_|Refss],[ref_ex(Ind,Pred,Tab,Pers,Gen,Num,Cat,F/Role)/N|AllR]):-
   convertunrefs(Refss,AllR),
   !.

selectpros(Pro):-
   grammw(Pro,K).
   
ntopic_stack(No, Main-F, Sec-F1, Pot-F2, Antes):-
     main(Main, F),
     second(Sec, F1),
     others([Pot-Def-F2|Pots]),
     findall(Ante-Pro, (risolto(No, SnX, Pro, Ante),
                 selectpros(Pro)), Antes).
ntopic_stack(No, nil-F, nil-F1, nil-F2, [nil-nil]):-
     !.

mcoreference(NoFr, Pred, Id):-
    Pred\=[],
    atomic(Pred), \+ Pred=..[P,A],
    spy_lower(Pred, LowW, Pol),
    recover_description(LowW, Top),
    (Pred\=Top,
      referentess(SnX,[],Id,Top,Num,Card)
      ;
      referentess(SnX,[],Id,Pred,Num,Card)),
    !.

mcoreference(NoFr, Pred, Id):-
    Pred\=[],
    list(Pred),
    sspy_lower(Pred, LowW, Pol),
    recover_description(LowW, Top),
    (LowW\=Top,
      referentess(SnX,[],Id,Top,Num,Card)
      ;
      referentess(SnX,[],Id,LowW,Num,Card)),
    !.

is_a(X,Y):- is_ax(X,Y).

is_ax(X,Y):- 
   nonvar(Y), 
   nonvar(X), X=Y.

is_ax(X,Y):- 
   nonvar(Y), 
   atomic(Y),
   spy_lower(Y, LowL, 1),
   nonvar(X), X=LowL.
is_ax(X,Y):- 
   nonvar(X), 
   atomic(X),
   spy_lower(X, LowL, 1),
   nonvar(Y), LowL=Y.

   is_ax(ministro,soc_high).
   is_ax(senatore,soc_high).
   is_ax(autobus,veicolo).
   is_ax(porcellino,pasto).
   is_ax(pasto,porcellino).
   is_ax(pranzo,pasto).
   is_ax(pasto,pranzo).
   is_ax(segretario,soc_low).
   is_ax(commission,council).
   is_ax(capanna,casa).

is_ax(X,Y):- s_is_ax(X,Y).


shasserisci_proprieta_multiw(NoFr,Testa,Ref,SnX,Id):-
   nonvar(Testa), Testa\=[],
   Ref=ref_ex(SnX,Testa1,Tab,_,Gen,Num,Cats,F/Role),
   list(Testa1), Pred=Testa1,
   (Num=sing, Type=ind; Num=plur, Type=class),
   Tab=[Re, Def, Quant, Card, _, _, Class],
   Re = + ref,
   (Card=[], Card1=Quant; Card=nil, Card1=Quant; Card\=[], Card\=nil, Card1=Card),
   shassert_names(NoFr,Cats,[],SnX,Pred,Card1,Quant,Num,Id,Temp, Loc),
   !.

shasserisci_proprieta_multiw(NoFr,Testa,Ref,SnX,Id):-
   nonvar(Testa), Testa\=[],
   Ref=ref_ex(SnX,Testa1,Tab,_,Gen,Num,Cats,F/Role),
   list(Testa), 
   recover_description(Testa, Pred), Pred=Testa1,
   (Num=sing, Type=ind; Num=plur, Type=class),
   Tab=[Re, Def, Quant, Card, _, _, Class],
   Re = + ref,
   (Card=[], Card1=Quant; Card=nil, Card1=Quant; Card\=[], Card\=nil, Card1=Card),
   shassert_names(NoFr,Cats,[],SnX,Testa,Card1,Quant,Num,Id,Temp, Loc),
   !.

shasserisci_proprieta_multiw(NoFr,Testa,Ref,SnX,Id):-
   nonvar(Testa), Testa\=[],
   Ref=ref_ex(SnX,Testas,Tab,_,Gen,Num,Cats,F/Role),
   atomic(Testas),
   recover_description(Testa, Pred), Pred=Testas,
   (Num=sing, Type=ind; Num=plur, Type=class),
   Tab=[Re, Def, Quant, Card, _, _, Class],
   Re = + ref,
   (Card=[], Card1=Quant; Card=nil, Card1=Quant; Card\=[], Card\=nil, Card1=Card),
   shassert_names(NoFr,Cats,[],SnX,Pred,Card1,Quant,Num,Id,Temp, Loc),
   !.

shasserisci_proprieta_multiw(NoFr,Testa,Ref,SnX,Id):-
   nonvar(Testa), Testa\=[],
   Ref=ref_ex(SnX,Testas,Tab,_,Gen,Num,Cats,F/Role),
   atomic(Testas),
   recover_description(Testa, Pred), 
   list(Pred), Pred\=Testas,
   (Num=sing, Type=ind; Num=plur, Type=class),
   Tab=[Re, Def, Quant, Card, _, _, Class],
   Re = + ref,
   (Card=[], Card1=Quant; Card=nil, Card1=Quant; Card\=[], Card\=nil, Card1=Card),
   shassert_names(NoFr,Cats,[],SnX,Pred,Card1,Quant,Num,Id,Temp, Loc),
   !.

shasserisci_proprieta_multiw(NoFr,Testa,Ref,SnX,Id):-
   nonvar(Testa), Testa\=[],
   Ref=ref_ex(SnX,Testa,Tab,_,Gen,Num,Cats,F/Role),
   atomic(Testa),
   recover_description(Testa, Pred), Pred=Testa,
   (Num=sing, Type=ind; Num=plur, Type=class),
   Tab=[Re, Def, Quant, Card, _, _, Class],
   Re = + ref,
   (Card=[], Card1=Quant; Card=nil, Card1=Quant; Card\=[], Card\=nil, Card1=Card),
   shcreatert(NoFr,class,[],SnX,Testa,Card1,Quant,Num,Id,univ, univ),
   shdefault_properties(NoFr, Gen, SnX, Cats, Pred, Id,univ, univ),
   shasserisci(NoFr,SnX,fact(isa,[ind:Id,class:Pred],1,univ,univ)),
   !.

shassert_names(NoFr,Cat,Mods,SnX,[],Card,Quant,Num,Id,Temp, Loc):-!.
shassert_names(NoFr,Cat,Mods,SnX,Testas,Card,Quant,Num,Id,Temp, Loc):-
     list(Testas),
     nogen_member(umano, Cat), \+ nogen_member(plant,Cat),
     reverse(Testas, [Testa,Surn]),
     wn(Testa,Scats),
     (\+ nogen_member(mat,Scats),
      (nogen_member(nmf,Scats), Pred=woman;
      (nogen_member(nmm,Scats);nogen_member(sur,Scats)),
        Pred=man)
       ;
       nogen_member(mat,Scats), Pred=plant
       ),
     recover_description(Testas, Preds),
     shcreatert(NoFr,name,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
     shasserisci(NoFr, SnX, fact(inst_of,[ind:Id, class:Pred], 1, univ, univ)),
     shasserisci(NoFr, SnX, fact(isa,[ind:Id, class:Preds], 1, univ, univ)),
     shasserisci(NoFr,SnX,fact(name,[Testa, Id],1,univ, univ)),
     shasserisci(NoFr,SnX,fact(name,[Surn, Id],1,univ, univ)),
     !.

shassert_names(NoFr,Cat,Mods,SnX,Testas,Card,Quant,Num,Id,Temp, Loc):-
     list(Testas),
     reverse(Testas, [Testa,Surn]),
     recover_description(Testas, Preds),
     shcreatert(NoFr,name,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
     shdefault_properties(NoFr, Gen, SnX, Cat, Pred, Id, Temp, Loc),
     shasserisci(NoFr, SnX, fact(inst_of,[ind:Id, class:Testa], 1, univ, univ)),
     shasserisci(NoFr, SnX, fact(isa,[ind:Id, class:Testa], 1, univ, univ)),
     shasserisci(NoFr, SnX, fact(isa,[ind:Id, class:Preds], 1, univ, univ)),
     shcreatert(NoFr,class,Mods,SnX,Surn,Card,Quant,Num,Idy,Temp, Loc),
     shasserisci(NoFr, SnX, fact(isa,[ind:Idy, class:Surn], 1, univ, univ)),
     shasserisci(NoFr,SnX,fact(of,[arg:Idy, specif:Id],1,univ, univ)),
     !.

shassert_names(NoFr,Cat,Mods,SnX,Testas,Card,Quant,Num,Idx,Temp, Loc):-
     (Testas=.. [and|Teste]
      ;Testas=.. [or|Teste]),
     Teste=[Testae],
     reverse(Testae, [Testa,Surn]),
     shcreater_coo(NoFr,set,[],SnX,Testae,2,Quant,Num,Idx,univ, univ),
     shcreatert(NoFr,class,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
     shasserisci(NoFr, SnX, fact(inst_of,[ind:Id, class:Cat], 1, univ, univ)),
     shasserisci(NoFr, SnX, fact(isa,[ind:Id, class:Testa], 1, univ, univ)),
     shcreatert(NoFr,class,Mods,SnX,Surn,Card,Quant,Num,Idy,Temp, Loc),
     shasserisci(NoFr, SnX, fact(inst_of,[ind:Idy, class:Cat], 1, univ, univ)),
     shasserisci(NoFr, SnX, fact(isa,[ind:Idy, class:Surn], 1, univ, univ)),
     shasserisci(NoFr, SnY, in(Id,Idx)),
     shasserisci(NoFr, SnX, in(Idy,Idx)),
     !.

shassert_names(NoFr,Cat,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc):-
     Testa=[Test],
     shcreatert(NoFr,class,Mods,SnX,Test,Card,Quant,Num,Id,Temp, Loc),
     shclass_props(NoFr, SnX, Cat, Id, fact, isa, Test, 1, Temp, Loc),
     !.

shassert_names(NoFr,Cat,Mods,SnX,[Test|Testa],Card,Quant,Num,Id,Temp, Loc):-
     shcreatert(NoFr,class,Mods,SnX,Test,Card,Quant,Num,Id,Temp, Loc),
     shclass_props(NoFr, SnX, Cat, Id, fact, isa, Test, 1, Temp, Loc),
     shassert_names(NoFr,Cat,Mods,SnX,Testa,Card,Quant,Num,Id,Temp, Loc),
     !.

shclass_props(NoFr, SnX, Cat, Id, SitFac, isa, Testa, Pol, Temp, Loc) :-
            \+ interp(compl),
            nonvar(Testa),
            (var(Temp), Temp=univ; nonvar(Temp)),
            (var(Loc), Loc=univ; nonvar(Loc)),
            shdefault_properties(NoFr, Gen, SnX, Cat, Pred, Id, Temp, Loc),
            SitFacts=..[SitFac,isa,[ind:Id,class:Testa],Pol,Temp, Loc],
            shasserisci(NoFr,SnX,SitFacts).

shclass_props(NoFr, SnX, Cat, Id, SitFac, name, Testa, Pol, Temp, Loc) :-
            \+ interp(compl),
            nonvar(Testa),
            (var(Temp), Temp=univ; nonvar(Temp)),
            (var(Loc), Loc=univ; nonvar(Loc)),
            shdefault_properties(NoFr, Gen, SnX, Cat, Pred, Id, Temp, Loc),
            SitFacts=..[SitFac,name,[Testa, Id],Pol,Temp, Loc],
            shasserisci(NoFr,SnX,SitFacts).

shclass_props(NoFr, SnX, Cat, Id, SitFac, isa, Testa, Pol, Temp, Loc) :-
            nonvar(Testa),
            shdefault_properties(NoFr, Gen, SnX, Cat, Pred, Id, Temp, Loc),
            SitFacts=..[SitFac,isa,[ind:Id,class:Testa],Pol,Temp, Loc],
            shasserisci(NoFr,SnX,SitFacts).

shclass_props(NoFr, SnX, Cat, Id, SitFac, name, Testa, Pol, Temp, Loc) :-
            nonvar(Testa),
            shdefault_properties(NoFr, Gen, SnX, Cat, Pred, Id, Temp, Loc),
            SitFacts=..[SitFac,name,[Testa, Id],Pol,Temp, Loc],
            shasserisci(NoFr,SnX,SitFacts).


shdefault_properties(NoFr, Gen, SnX, Cat, Pred, Ind, Temp, Loc) 
  :-
  nonvar(Ind),
  (
   (var(Gen), Gen=mas
   ;
   nonvar(Gen)),
   (
   nogen_member(hum_set,Cat),
   (gr(english), Pred=coll; gr(italiano), Pred=coll),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   (nogen_member(instit,Cat);nogen_member(istituzione,Cat)),
   (gr(english), Pred=institution; gr(italiano), Pred=istituzione),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(legale,Cat),
   (gr(english), Pred=legal; gr(italiano), Pred=giuridico),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(plant,Cat),
   (gr(english), Pred=plant_life; gr(italiano), Pred=creatura_viv),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(istituzione,Cat),
   (gr(english), Pred=institution; gr(italiano), Pred=istituzione),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(data,Cat),
   (gr(english), Pred=date; gr(italiano), Pred=data),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(sostanza,Cat),
   (gr(english), Pred=substance; gr(italiano), Pred=sostanza),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(ferocious,Cat),
   (gr(english), Pred=ferocious_animal; gr(italiano), Pred=animale_feroce),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(edible,Cat),
   nogen_member(sostanza,Cat),
   (gr(english), Pred=edible_substance; gr(italiano), Pred=sostanza_cibo),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(edible,Cat),
   (gr(english), Pred=edible_animal; gr(italiano), Pred=animale_cibo),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(animato,Cat), notmembro(umano, Cat),
   (gr(english), Pred=animal; gr(italiano), Pred=animale),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
    nogen_member(umano,Cat), Gen=mas,
   (gr(english), Pred=man; gr(italiano), Pred=uomo),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(umano,Cat), Gen=fem,
   (gr(english), Pred=woman; gr(italiano), Pred=donna),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1,univ, univ))
    ;
   nogen_member(luogo,Cat),
   (gr(english), Pred=place; gr(italiano), Pred=luogo),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(descrittivo,Cat),
   (gr(english), Pred=descriptive; gr(italiano), Pred=descrittivo),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1,univ, univ))
    ;
   nogen_member(mil,Cat),
   (gr(english), Pred=military; gr(italiano), Pred=militare),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1,univ, univ))
    ;
   nogen_member(oggetto,Cat),
   (gr(english), Pred=thing; gr(italiano), Pred=cosa),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(astratto,Cat),
   (gr(english), Pred=abstract_state; gr(italiano), Pred=stato_astratto),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Pred], 1, univ, univ))
    ;
   nogen_member(Ct,Cat),
   (nonvar(Pred)
    ;
    var(Pred),
    Pred=Ct),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Ct], 1, univ, univ))
    )
   ;
   Cat=nil,
   nonvar(Pred),
   trova_CatSem(_,Pred,Cats),
   nogen_member(Ct,Cats),
    shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Ct], 1, univ, univ))
   ;
   (nonvar(Pred),
    (Cat\=nil,
     nogen_member(Ct,Cat)
     ;
     Cat=nil,
     attributes(Pred,Ct))
    ;
    var(Pred),
    (atomic(Cat), Cat\=nil, Ct=Cat;is_list(Cat),nogen_member(Ct,Cat)), 
    Pred=Ct),
   shasserisci(NoFr, SnX, fact(inst_of,[ind:Ind, class:Ct], 1, univ, univ))
   ),!.

attributes(Pred,quant):-
   nm(Pred,_,_)
   ;
   nm(_,_,Pred)
   ;
   grammw(Pred,_),
   !.
attributes(Ct,Ct):-
   !.
   
   
shcreater_coo(NoFr, Type, 
                Mods, SnX, Testa, Card, Quant, Num, Ind, Temp, Loc) 
   :-
   gen_sym(id, Ind),
  (Type=ind,
   shasserisci(NoFr, SnX, ind(Ind)), 
   ! ;
   Type=class,
   shasserisci(NoFr, SnX, class(Ind)),
   ! ;
   Type=set,
   shasserisci(NoFr, SnX, set(Ind)),
   shasserisci(NoFr, SnX, card(Ind,Card))
   ),
   !.

shcreatert(NoFr, Type, Mods, SnX, Testa, Card, Quant, Num, Ind, Temp, Loc) 
   :-
%   \+ interp(compl),
   gen_sym(id, Ind),
  (
   (Type=ind;Type=name),
   shasserisci(NoFr, SnX, ind(Ind)), 
   ! ;
   Type=class,
   shasserisci(NoFr, SnX, class(Ind)),
   ! ;
   Type=set,
   shasserisci(NoFr, SnX, set(Ind)),
   shasserisci(NoFr, SnX, card(Ind,Card))
   ).

/***************
asserisci(+NoFr, +SnIndex, +Fact)
== Asserisce fatti relativi a individui. In confer_infon/4 viene tenuta traccia della relazione tra un infon e la frase e nodo proposizionale da cui  stato estratto. 
***************/
shasserisci(NoFr, SnX, Fact) :-
   gen_sym(infon, Id),
   frase_corrente(NoFr,_),
   Fact=..[Pred | Args],
   FactId=..[Pred, Id | Args],
   nonvar(Pred),
   assert(FactId),
   assert(confer_infon(Id, NoFr, SnX, nil, secondary)).

shasserisci_topic(NoFr, Type, Ind, SnX) :-
   nonvar(Ind), var(SnX),
   assert(topic(NoFr, Type, Ind)),
   assert(confer_topic(NoFr, Type, Ind, nil, PropNode)),
   !.
shasserisci_topic(_, _, _, _) .

dmextract_properties(SentNo, AllRef, []):-!.
dmextract_properties(SentNo, AllRef, [Main|Out]):-
    take_main(Main,Clause),
  (Clause=[Neg,
         Pred-Args,
         Mods, 
         Refs,
         OutAdjs]
         ;
   Clause=[Neg,
         Pred-Args,
         Refs,
         OutAdjs],         
         Mods=[]), 
    extract_properties(SentNo, Mods, AllRef, NRefs),
    dmextract_properties(SentNo, AllRef, Out),
   !.
dmextract_properties(SentNo, AllRef, [Main|Out]):-
    dmextract_properties(SentNo, AllRef, Out),
   !.


extract_properties(SentNo, [], NewRefs, NewRefs):-!.
extract_properties(SentNo, [[Ind-Gov-[]|Mods]], NewRefs, NRefs):-
   extract_properties(SentNo, Mods, NewRefs, NRefs),!.
extract_properties(SentNo, [Ind-Gov-[]|Mods], NewRefs, NRefs):-
   extract_properties(SentNo, Mods, NewRefs, NRefs),!.

extract_properties(NoFr, [[Ind-Gov-[of-_-_|Rest]|Mods]], NewRefs, NeRefs):-
   prendi_testas(Func, Rest, Testa, Mod, Resto, Cat),
   get_id_gov(NoFr,NewRefs, Ind, IdGov),
   get_id(NoFr, Testa, Resto, NewRefs, SnY, Id, NRefs),
   shasserisci(NoFr, SnY, fact(of, [arg:IdGov, specif:Id], 1,univ, univ)),
   asserisci_topic_ref_func(NoFr, Gov, Testa, of, Rest, Id, SnY),
   extract_properties(NoFr, [Ind-Gov-Mods], NRefs, NeRefs),!.

extract_properties(NoFr, [Ind-Gov-[of-_-_|Rest]|Mods], NewRefs, NeRefs):-
   prendi_testas(Func, Rest, Testa, Mod, Resto, Cat),
   get_id_gov(NoFr,NewRefs, Ind, IdGov),
   get_id(NoFr, Testa, Resto, NewRefs, SnY, Id, NRefs),
   shasserisci(NoFr, SnY, fact(of, [arg:IdGov, specif:Id], 1,univ, univ)),
   asserisci_topic_ref_func(NoFr, Gov, Testa, of, Rest, Id, SnY),
   extract_properties(NoFr, [Ind-Gov-Mods], NRefs, NeRefs),!.

extract_properties(NoFr, [[Ind-Gov-[Prep-_-_|Rest]|Mods]], NewRefs, NeRefs):-
   prendi_testas(Func, Rest, Testa, Mod, Resto, Cat),
   get_id_gov(NoFr,NewRefs, Ind, IdGov),
   assegnaruolo(Prep, Testa, NewRefs, SnY, Ruolo, NPrep),
   get_id(NoFr, Testa, Resto, NewRefs, SnY, Id, NRefs),
   shasserisci(NoFr, SnY, fact(NPrep, [arg:IdGov, Ruolo:Id], 1,univ, univ)),
   asserisci_topic_ref_func(NoFr, Gov, Testa, Prep, Rest, Id, SnY),
   extract_properties(NoFr, [Ind-Gov-Mods], NRefs, NeRefs),!.

extract_properties(NoFr, [Ind-Gov-[Prep-_-_|Rest]|Mods], NewRefs, NeRefs):-
   prendi_testas(Func, Rest, Testa, Mod, Resto, Cat),
   get_id_gov(NoFr,NewRefs, Ind, IdGov),
   assegnaruolo(Prep, Testa, NewRefs, SnY, Ruolo, NPrep),
   get_id(NoFr, Testa, Resto, NewRefs, SnY, Id, NRefs),
   shasserisci(NoFr, SnY, fact(NPrep, [arg:IdGov, Ruolo:Id], 1,univ, univ)),
   asserisci_topic_ref_func(NoFr, Gov, Testa, Prep, Rest, Id, SnY),
   extract_properties(NoFr, [Ind-Gov-Mods], NRefs, NeRefs),!.

extract_properties(NoFr, [Ind-Gov-[mod-[Prep-_-_|Rest]|Mods]], NewRefs, NeRefs):-
   prendi_testas(Func, Rest, Testa, Mod, Resto, Cat),
   get_id_gov(NoFr,NewRefs, Ind, IdGov),
   assegnaruolo(Prep, Testa, NewRefs, SnY, Ruolo, NPrep),
   get_id(NoFr, Testa, Resto, NewRefs, SnY, Id, NRefs),
   shasserisci(NoFr, SnY, fact(NPrep, [arg:IdGov, Ruolo:Id], 1,univ, univ)),
   asserisci_topic_ref_func(NoFr, Gov, Testa, Prep, Rest, Id, SnY),
   extract_properties(NoFr, [Ind-Gov-Mods], NRefs, NeRefs),!.

extract_properties(NoFr, [Ind-Gov-[obl-[Prep-_-_|Rest]|Mods]], NewRefs, NeRefs):-
   prendi_testas(Func, Rest, Testa, Mod, Resto, Cat),
   get_id_gov(NoFr,NewRefs, Ind, IdGov),
   assegnaruolo(Prep, Testa, NewRefs, SnY, Ruolo, NPrep),
   get_id(NoFr, Testa, Resto, NewRefs, SnY, Id, NRefs),
   shasserisci(NoFr, SnY, fact(NPrep, [arg:IdGov, Ruolo:Id], 1,univ, univ)),
   asserisci_topic_ref_func(NoFr, Gov, Testa, Prep, Rest, Id, SnY),
   extract_properties(NoFr, [Ind-Gov-Mods], NRefs, NeRefs),!.

extract_properties(NoFr, [Ind-Gov-[mod-[obl-[Prep-_-_|Rest]|Mods]]], NewRefs, NeRefs):-
   prendi_testas(Func, Rest, Testa, Mod, Resto, Cat),
   get_id_gov(NoFr,NewRefs, Ind, IdGov),
   assegnaruolo(Prep, Testa, NewRefs, SnY, Ruolo, NPrep),
   get_id(NoFr, Testa, Resto, NewRefs, SnY, Id, NRefs),
   shasserisci(NoFr, SnY, fact(NPrep, [arg:IdGov, Ruolo:Id], 1,univ, univ)),
   asserisci_topic_ref_func(NoFr, Gov, Testa, Prep, Rest, Id, SnY),
   extract_properties(NoFr, [Ind-Gov-Mods], NRefs, NeRefs),!.

extract_properties(NoFr, [[Ind-Gov-Parses|Mods]], NewRefs, NRefs):-
   Parses\=[],
   nogen_member(and-Cong-C, Parses),
   remove(and-Cong-C, Parses, Parse),
   prendi_testas(Func, Parse, Testa, Mod, Resto, Cat),
   get_id_gov(NoFr,NewRefs, Ind, IdGov),
   get_id_pl(NoFr, Testa, Resto, NewRefs, SnY, Id),
   shasserisci(NoFr, SnY, fact(name, [IdGov, Id], 1,univ, univ)),
   shasserisci_topic(NoFr, potential, Id, SnY),
   extract_properties(NoFr, [Ind-Gov-Mods], NewRefs, NRefs),!.

extract_properties(NoFr, [Ind-Gov-Parses|Mods], NewRefs, NRefs):-
   Parses\=[],
   nogen_member(and-Cong-C, Parses),
   remove(and-Cong-C, Parses, Parse),
   prendi_testas(Func, Parse, Testa, Mod, Resto, Cat),
   get_id_gov(NoFr,NewRefs, Ind, IdGov),
   get_id_pl(NoFr, Testa, Resto, NewRefs, SnY, Id),
   shasserisci(NoFr, SnY, fact(name, [IdGov, Id], 1,univ, univ)),
   shasserisci_topic(NoFr, potential, Id, SnY),
   extract_properties(NoFr, [Ind-Gov-Mods], NewRefs, NRefs),!.

extract_properties(NoFr, [Ind-Gov-Parse|Mods], NewRefs, NRefs):-
   Parse\=[],
   Parse=[Testa|Resto],
   atomic(Testa),
   get_id_gov(NoFr,NewRefs, Ind, IdGov),
   spy_lower(Testa, LowW, Pol),
   asserisci_proprieta(IdGov,LowW,NoFr,Ind,Resto, NewRefs, NeRefs),
   append([Ind-Gov-Resto], Mods, Modds),
   extract_properties(NoFr, Modds, NeRefs, NRefs),!.

extract_properties(NoFr, [Ind-Gov-Parse|Mods], NewRefs, NRefs):-
   Parse\=[],
   Parse=[Testa|Resto],
   Testa=T-Cat-_,
   nouncats(Cat),
   get_id_gov(NoFr,NewRefs, Ind, IdGov),
   asserisci_proprieta(IdGov,T,NoFr,Ind,Resto, NewRefs, NeRefs),
   append([Ind-Gov-Resto], Mods, Modds),
   extract_properties(NoFr, Modds, NeRefs, NRefs),!.

extract_properties(SentNo, [[Ind-Gov-Mod|Mods]], NewRefs, NRefs):-
   extract_properties(SentNo, Mods, NewRefs, NRefs),!.
   
extract_properties(NoFr, [Ind-Gov-Mod|Mods], NewRefs, NRefs):-
       Mod\=[], 
     (Fu=obl;Fu=mod;Fu=sn;Fu=subj;Fu=appos),
     remove(Fu-Mo,Mod,Rest),
   extract_properties(SentNo, [Ind-Gov-Rest], NewRefs, NRefs),
   extract_properties(SentNo, [Ind-Gov-Mods], NewRefs, NRefs),!.

extract_properties(SentNo, [Ind-Gov-Mod|Mods], NewRefs, NRefs):-
   extract_properties(SentNo, Mods, NewRefs, NRefs),!.

assegnaruolo(Prep, Testa, NewRefs, SnY, temp, on):-
   nonvar(Prep), Prep=s_,
   nt(Testa),   
   !.
assegnaruolo(Prep, Testa, NewRefs, SnY, poss, has):-
   nonvar(Prep), Prep=s_,!.

assegnaruolo(Prep, T, NewRefs, SnY, Ruolo, Prep):-
   nogen_member(ref_ex(SnY,T,Tab,_,Gen,Num,Cats,F/Role)/P,NewRefs),
   tipo_agg(Ruolo, Prep, CatsPrep),
   nogen_member(C, Cats),
   nogen_member(C, CatsPrep),!.

assegnaruolo(Prep, Testa, NewRefs, SnY, Ruolo, Prep):-
   tipo_agg(Ruolo, Prep, CatsPrep),
   !.

asserisci_topic_ref_func(NoFr, Gov, Testa, Head, Func, Id, SnY):-
   append([Head],Func, Funcs),
   asserisci_ref_func(NoFr, Gov, Testa, Funcs, SnY),
   !.

asserisci_ref_func(NoFr, Gov, Testa, Func, SnY):-
     assign_index(Ind),
     gen_sym(infon, Id),
     gen_sym(id, Inds),
     shasserisci_topic(NoFr, potential, Inds, Ind),
     assert(confer_infon(Id, NoFr, Ind, nil, secondary)),
     append([Gov],Func, Funcs),
     asserta(ref_funcs(mod, Ind, Gov, Funcs)),
    !.

asserisci_topicreffunc(NoFr, Lem, Func, Id, SnX):-
   gen_sym(infon, Infd),
   assert(confer_infon(Infd, NoFr, SnX, nil, secondary)),
   shasserisci_topic(NoFr, potential, Id, SnX),
   append(Func, [Lem], Funcs),
   asserta(ref_funcs(mod, SnX, Lem, Funcs)),
   !.


nwrite_sentence_infons(Win, NoFr) :-
   confer_infon(Id, NoFr, SnX, _, _),
   infon(Id, Fact),
   writenl(Win, Fact), 
   fail. 
nwrite_sentence_infons(_,_).

find_all_top_sents(SortedEnts, N, NewFrs):-
   findall_top_sents(SortedEnts, N, Frs),
   Frs\=[],
   appiattisci(Frs, Frss),
   most_important_sent(Frss),
   sort(Frss, Ents),
   findall(Dr,discrelfor(Dr), Drs),
   check_disc_str(Ents, Drs, NewFrs),
   !.

find_all_topsents(SortedEnts, N, NewFrs):-
   findall_topsents(SortedEnts, N, Frs),
   Frs\=[],
   appiattisci(Frs, Frss),
   sort(Frss, Ents),
   findall(Dr,discrelfor(Dr), Drs),
   check_disc_str(Ents, Drs, NewFrs),
   !.

findall_top_sents([Score-Ind|SortedEnts], N, [Frs|Ents]):-
   N < 10,
   findall(NoFr, 
               confer_topic(NoFr, Type, Ind, _, PropNode), Frs),
   length(Frs, L),
   L1 is N + L,
   findall_top_sents(SortedEnts, L1, Ents),!.
findall_top_sents(SortedEnts, L1, Ents).

findall_topsents([Ind-_|SortedEnts], N, [Frs|Ents]):-
   N < 10,
   ctopic(Topics),
   Topics\=[],
   findall(NoFr, 
               on(NoFr-Ind-Type, Topics), Frs),
   length(Frs, L),
   L1 is N + L,
   findall_topsents(SortedEnts, L1, Ents),!.

findall_topsents(SortedEnts, L1, Ents).


save_confer_infon:-
   findall(NoFr-Ind-Type, 
               confer_topic(NoFr, Type, Ind, _, PropNode), Frs),
   assert(ctopic(Frs)),!.
   
check_disc_str(Frss, FDiscRel, NewFrs):-
   findall(NoFr, (on(NoFr,Frss), sinfo(NoFr, Node, FunRole, View, Intens, Change, Rel,VerbCat, Verb,TempRel, DiscRel, DiscDom, SubjConsc), on(DiscRel,FDiscRel)), Ds),
    sort(Ds,NewFrs),
    NewFrs\=[],
    !.
check_disc_str(Frss, FDiscRel, Frss).

most_important_sent(Frs):-
   sort(Frs,K,[],1),
   count_sort(K, Fr),
   sort(Fr, [_-NoFr|_], [],1),
   sent_banner,
   get_sent(NoFr,Sent),
   writeseqnl(user,Sent),
   !.

get_sent(N,Sent):-
   pname(N,N1),
   fp(NoFr,Sent),
   stringof(NoFrs,NoFr),
   reverse(NoFrs, [N1|_]),!.
get_sent(N,Sent):-
   pname(N,N1),
   fp(NoFr,Sent),
   !.


dangling_sentences([], []):-!.
dangling_sentences([Sent|Ents], [PSent,Sent|NEnts]):-
   risolto(Sent,SnX,Anaf,Pred),
   PSent is Sent - 1,
   dangling_sentences(Ents, NEnts),
   !.
dangling_sentences([Sent|Ents], [Sent|NEnts]):-
   dangling_sentences(Ents, NEnts),
   !.    

get_id_mod(NoFr, Testa, Resto, NewRefs, SnX, Id, NRefs):-
   nonvar(Testa),Testa\=[],
   lemmatize_dic(Testa, Lemma, S),
   crearef_ex(Testa, Resto, Ref, Mods),
   (Ref=..[ref_ex,Ind,Lemma,Tab|_], Lem=Lemma
     ;
    Ref=..[ref_ex,Ind,Testa,Tab|_], Lem=Testa
     ;
    Ref=..[ref_ex,Ind,Lemm,Tab|_], Lem=Lemm),
   Tab=[Re, Def, Quant, Card, _, _, Class],
   mcoreference(NoFr, Lem, Id),
   (Mods\=[], 
    find_restrict(Mods, Id, Lem, Pros, Ps, Mod),
    evaluate_properties(Id,Mod,NoFr,SnX,Resto, Ref, Pros, Ps)
    ;
    Mods=[]
    ;
    true),
    append([Ref/100], NewRefs, NRefs),
    !.
get_id_mod(NoFr, Testa, Resto, Refs, SnX, Id, NRefss):-
   nonvar(Testa),Testa\=[],
   crearef_ex(Testa, Resto, Ref, Mods),
   (
    shasserisci_proprieta_multiw(NoFr,Resto,Ref,SnXx,Id)
     ;
     shasserisci_proprieta_multiw(NoFr,Testa,Ref,SnXx,Id)),
    append([Ref/100], Refs, NRef),
   (
    Mods\=[], 
    length(Mods,L),
    remove(Mod, Mods, Mods1),
    asserisci_proprieta(Id,Mod,NoFr,SnY,Resto, NRef, NRefs),
     (L=1
      ;
      1<L,Mods1\=[],
      crearef_ex(Test, Mods1, Ref1, Modss),
      append([Ref1/100], NRefs, NRefss),
      shasserisci_proprieta_multiw(NoFr,Test,Ref1,SnZ,Idd) )    
    ;
    Mods=[], NRefss=NRef
    ;
    true, NRefss=NRef),
   asserisci_topicreffunc(NoFr, Testa, Resto, Id, SnXx),
   !.

get_id_mod(NoFr, Testa, Resto, NewRefs, SnX, Id, NewRefs):-
   nonvar(Testa),Testa\=[],
   lemmatize_dic(Testa, Lemma, S),
   (Lem=Testa;Lem=Lemma),
   nogen_member(ref_ex(SnX,Lem,Tab,_,Gen,Num,Cats,F/Role)/P,NewRefs),
   shcreatert(NoFr,class,[],SnX,Lem,Card,Quant,Num,Id,univ, univ),
   shdefault_properties(NoFr, Gen,SnX, Cats, Lem, Id,univ, univ),
   shasserisci(NoFr,SnX,fact(isa,[ind:Id,class:Lem],1,univ,univ)),
   asserisci_topicreffunc(NoFr, Lem, Resto, Id, SnX),
   !.

get_id_mod(NoFr, Testa, Resto, Refs, SnX, Id, NRefs):-
   nonvar(Testa), Testa\=[],
   lemmatize_dic(Testa, Lemma, S),
   crearef_ex(Testa, Resto, Ref, Mods),
   (Ref=..[ref_ex,Ind,Lemma,Tab_,Gen|_], Lem=Lemma
     ;
    Ref=..[ref_ex,Ind,Testa,Tab_,Gen|_], Lem=Testa
     ;
    Ref=..[ref_ex,Ind,Lemm,Tab_,Gen|_], Lem=Lemm),
   Tab=[Re, Def, Quant, Card, _, _, Class],
   shcreatert(NoFr,class,[],SnX,Lem,Card,Quant,Num,Id,univ, univ),
   shdefault_properties(NoFr, Gen,SnX, Cats, Lem, Id,univ, univ),
   shasserisci(NoFr,SnX,fact(isa,[ind:Id,class:Lem],1,univ,univ)),
    append([Ref/100], Refs, NRefs),
   asserisci_topicreffunc(NoFr, Lem, Resto, Id, Ind),
   !.


